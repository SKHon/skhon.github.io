<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>前端架构之路</title>
  <icon>https://www.gravatar.com/avatar/bafeed710faffad62197c060e0e91fda</icon>
  <subtitle>我宁愿犯错，也不想什么都不做</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://skhon.github.io/"/>
  <updated>2022-05-18T15:50:57.918Z</updated>
  <id>https://skhon.github.io/</id>
  
  <author>
    <name>liujianghong</name>
    <email>ljhtianhong@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【稳定性建设】项目依赖分析</title>
    <link href="https://skhon.github.io/2022/05/18/engineering/dep/"/>
    <id>https://skhon.github.io/2022/05/18/engineering/dep/</id>
    <published>2022-05-18T15:46:46.301Z</published>
    <updated>2022-05-18T15:50:57.918Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>分析项目的依赖为树图，对比两次上线的 diff，得出受影响的页面，方便进行回归测试</p></blockquote><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>平台组件应用情况复杂，模块众多，在修改代码后，如何尽可能准确地回归受影响的模块依赖开发去检查。通过项目依赖的分析，能够：</p><ol><li>在上线打包时自动对模块进行分析，解析出受影响的页面，提供用于测试的回归列表</li></ol><ol start="2"><li>分析出未使用的模块，缩减无用代码</li></ol><ol start="3"><li>对项目的依赖关系进行分析，了解代码组织结构，为代码重构与拆分提供参考</li></ol><ol start="4"><li>多页面 repo 而言，通过依赖分析拿到此次需要构建的资源，可以做到单页面发布</li></ol><h1 id="Webpack-依赖解析"><a href="#Webpack-依赖解析" class="headerlink" title="Webpack 依赖解析"></a>Webpack 依赖解析</h1><h2 id="Webpack-对于依赖对处理的过程"><a href="#Webpack-对于依赖对处理的过程" class="headerlink" title="Webpack 对于依赖对处理的过程"></a>Webpack 对于依赖对处理的过程</h2><p>webpack 拿到入口文件 entry 后，会通过先获取资源的正确路径，再经过 loader 解析文件，最后通过遍历 ast 来拿到模块中引用的依赖 dependences ，再对 dependences 做递归处理，最终拿到依赖树。 这跟我们最初设想的思路基本一致，同时借助 loader 可以将不同的资源无法解析的问题也一并解决了。</p><h2 id="Why-Plugin"><a href="#Why-Plugin" class="headerlink" title="Why Plugin"></a>Why Plugin</h2><p>webpack 官方已经给出了 webpack-bundle-analyzer 这类的工具了， 每次构建后 stats 中都能拿到文件依赖，不直接使用它的原因是：</p><ol><li>构建过程非常缓慢，特别是有几十个页面存在的情况下</li></ol><ol start="2"><li>我们只是想拿到资源依赖，不想对整个前端 repo 进行一次构建，也不想生成任何 bundle</li></ol><p>所以能不能既可以使用 loader 找到文件依赖，又不需要生成和压缩 bundle 呢，这个时候我们就需要使用 Webpack Plugin</p><h2 id="编写-Plugin"><a href="#编写-Plugin" class="headerlink" title="编写 Plugin"></a>编写 Plugin</h2><p>我们需要的 Plugin 整体结构比较简单，在 apply 函数中，我们将 webpack 的钩子与相应函数进行绑定。我们需要的主要有三个钩子：beforeResolve/afterResolve/finishModules。 在 beforeResolve 中，我们对不需要分析的模块，例如 node_modules 的模块进行拦截终止。 在 afterResolve 中，将文件及其依赖传入，进行依赖树的构建。 在 finishModules 中，可以使用最终生成的依赖树做一些操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class DependencesAnalysisPlugin &#123;</span><br><span class="line">  beforeResolve(resolveData, callback) &#123;</span><br><span class="line">    if (analysisBreak(request, issuer)) &#123;</span><br><span class="line">      callback(null, null);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      callback(null, resolveData);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  afterResolve(result, callback) &#123;</span><br><span class="line">    const &#123; resourceResolveData &#125; = result;</span><br><span class="line">    const &#123;</span><br><span class="line">      context: &#123; issuer &#125;,</span><br><span class="line">      path,</span><br><span class="line">    &#125; = resourceResolveData;</span><br><span class="line">    tree.addDependency(issuer, path);</span><br><span class="line">    callback(null, result);</span><br><span class="line">  &#125;</span><br><span class="line">  handleFinishModules(modules, callback) &#123;</span><br><span class="line">    // handle tree, etc: upload...</span><br><span class="line">    callback(null, modules);</span><br><span class="line">  &#125;</span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    compiler.hooks.normalModuleFactory.tap(pluginName, (nmf) =&gt; &#123;</span><br><span class="line">      nmf.hooks.beforeResolve.tapAsync(pluginName, this.beforeResolve);</span><br><span class="line">      nmf.hooks.afterResolve.tapAsync(pluginName, this.afterResolve);</span><br><span class="line">    &#125;);</span><br><span class="line">    compiler.hooks.compilation.tap(pluginName, (compilation) =&gt; &#123;</span><br><span class="line">      compilation.hooks.finishModules.tapAsync(</span><br><span class="line">        pluginName,</span><br><span class="line">        this.handleFinishModules</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = DependencesAnalysisPlugin;</span><br></pre></td></tr></table></figure></p><h1 id="构建依赖树"><a href="#构建依赖树" class="headerlink" title="构建依赖树"></a>构建依赖树</h1><p>构建依赖树有几点需要注意：</p><ol><li>同一个文件可能被不同的模块进行引用，在模块插入子节点时，应该为所有路径相同的模块插入子模块</li></ol><ol start="2"><li>可能会出现重复依赖的情况，例如组件 A 引用了组件 B，但是组件 B 同时使用了组件 A 中定义的一些常量</li></ol><p>为了解决第一个问题，在构建树时，我们同时维护一个节点列表，使用节点的引用进行构建树，当插入子节点时，只需要从列表中找到引用，操作引用的子节点。</p><p>当构建完依赖树，还需要进行一步对树的剪枝，在这一步我们解决循环依赖的问题。以树的来看，我们需要的最终结果是在标记节点修改时，要将父节点也同时标记为已修改。在从根结点到叶节点上，不同的节点只需要出现一次，所以做一遍遍历，同一条路径中只保留第一次出现的不重复节点，重复节点进行删除。</p><h1 id="获取-Git-diff"><a href="#获取-Git-diff" class="headerlink" title="获取 Git diff"></a>获取 Git diff</h1><p>在产出最终的 json 之前，需要获取到更改的文件。通过 打包平台 中的环境变量，我们可以拿到这一次构建的 Commit ID 和分支。通过 打包平台 API，可以拿到分支下构建的历史版本信息。取到两次的 Commit ID，通过 gitlab API，可以获取到两次 commit 之间的 diff，也就能获取到更改的文件列表。</p><h1 id="完整插件代码"><a href="#完整插件代码" class="headerlink" title="完整插件代码"></a>完整插件代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&quot;fs&quot;);</span><br><span class="line">const path = require(&quot;path&quot;);</span><br><span class="line">const &#123; exec &#125; = require(&quot;child_process&quot;);</span><br><span class="line">const axios = require(&quot;axios&quot;);</span><br><span class="line">const &#123; default: routerConfig &#125; = require(&quot;../config/router.config&quot;);</span><br><span class="line">const pluginName = &quot;DependencesAnalysisPlugin&quot;;</span><br><span class="line">const ignoreDependenciesArr = Object.keys(</span><br><span class="line">  require(&quot;../package.json&quot;).dependencies</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">const analysisBreak = (request, issuer) =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    (issuer &amp;&amp; issuer.includes(&quot;node_modules&quot;)) ||</span><br><span class="line">    (request &amp;&amp; request.includes(&quot;node_modules&quot;))</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const getRouterInfo = (config) =&gt; &#123;</span><br><span class="line">  if (!config.component &amp;&amp; (!config.routes || !config.routes.length)) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  const pagePath = path.resolve(__dirname, &quot;../src/pages/&quot;);</span><br><span class="line">  const proRoot = path.resolve(__dirname, &quot;../&quot;);</span><br><span class="line">  let children = undefined;</span><br><span class="line">  if (config.routes &amp;&amp; config.routes.length) &#123;</span><br><span class="line">    children = config.routes.map(getRouterInfo).filter(Boolean);</span><br><span class="line">  &#125;</span><br><span class="line">  return &#123;</span><br><span class="line">    route: config.path,</span><br><span class="line">    path: config.component</span><br><span class="line">      ? path.relative(</span><br><span class="line">          proRoot,</span><br><span class="line">          require.resolve(path.resolve(pagePath, config.component))</span><br><span class="line">        )</span><br><span class="line">      : undefined,</span><br><span class="line">    children,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class DependencyTree &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.uniqNodes = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 遍历树找到对应的结点列表</span><br><span class="line">   * @param &#123;*&#125; issuer</span><br><span class="line">   */</span><br><span class="line">  traverseTree(issuer) &#123;</span><br><span class="line">    const nodes = this.uniqNodes.filter((n) =&gt; n.name === issuer);</span><br><span class="line">    return nodes;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 为结点列表添加子节点</span><br><span class="line">   * @param &#123;*&#125; nodes</span><br><span class="line">   * @param &#123;*&#125; request</span><br><span class="line">   */</span><br><span class="line">  addChildNode(nodes, request) &#123;</span><br><span class="line">    let uniqNode = this.uniqNodes.find((n) =&gt; n.name === request);</span><br><span class="line">    if (!uniqNode) &#123;</span><br><span class="line">      uniqNode = &#123;</span><br><span class="line">        name: request,</span><br><span class="line">      &#125;;</span><br><span class="line">      this.uniqNodes.push(uniqNode);</span><br><span class="line">    &#125;</span><br><span class="line">    nodes.forEach((node) =&gt; &#123;</span><br><span class="line">      if (!node.children) &#123;</span><br><span class="line">        node.children = [uniqNode];</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        if (!node.children.find((n) =&gt; n.name === request)) &#123;</span><br><span class="line">          node.children.push(uniqNode);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 增加一个依赖信息</span><br><span class="line">   * @param &#123;*&#125; issuer</span><br><span class="line">   * @param &#123;*&#125; request</span><br><span class="line">   */</span><br><span class="line">  addDependency(issuer, request) &#123;</span><br><span class="line">    if (!this.root) &#123;</span><br><span class="line">      const firstChildNode = &#123;</span><br><span class="line">        name: request,</span><br><span class="line">      &#125;;</span><br><span class="line">      const rootNode = &#123;</span><br><span class="line">        name: issuer,</span><br><span class="line">        children: [firstChildNode],</span><br><span class="line">      &#125;;</span><br><span class="line">      this.root = rootNode;</span><br><span class="line">      this.uniqNodes.push(rootNode, firstChildNode);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    const nodes = this.traverseTree(issuer);</span><br><span class="line">    this.addChildNode(nodes, request);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 遍历树，将同一条链路上的重复出现的结点删除，第一次出现的保留</span><br><span class="line">   */</span><br><span class="line">  clearTree(root, nodes) &#123;</span><br><span class="line">    if (root.changed) &#123;</span><br><span class="line">      nodes.forEach((n) =&gt; &#123;</span><br><span class="line">        n.changed = true;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!root.children) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    const indexes = root.children</span><br><span class="line">      .map((child) =&gt; nodes.find((n) =&gt; n.name === child.name))</span><br><span class="line">      .reduce((iter, cur, index) =&gt; iter.concat(cur ? index : []), []);</span><br><span class="line">    root.children = root.children.reduce((iter, cur, index) =&gt; &#123;</span><br><span class="line">      if (indexes.includes(index)) &#123;</span><br><span class="line">        return iter;</span><br><span class="line">      &#125;</span><br><span class="line">      return iter.concat(cur);</span><br><span class="line">    &#125;, []);</span><br><span class="line">    root.children.forEach((child) =&gt; &#123;</span><br><span class="line">      this.clearTree(child, nodes.concat(root));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getFiles(filePath) &#123;</span><br><span class="line">    const sum = [];</span><br><span class="line">    const files = fs.readdirSync(filePath);</span><br><span class="line">    for (const file of files) &#123;</span><br><span class="line">      const stat = fs.statSync(path.resolve(filePath, file));</span><br><span class="line">      if (stat.isFile()) &#123;</span><br><span class="line">        sum.push(path.resolve(filePath, file));</span><br><span class="line">      &#125; else if (stat.isDirectory()) &#123;</span><br><span class="line">        sum.push(...this.getFiles(path.resolve(filePath, file)));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  unusedFiles() &#123;</span><br><span class="line">    const root = path.resolve(__dirname, &quot;../src/&quot;);</span><br><span class="line">    const proRoot = path.resolve(__dirname, &quot;../&quot;);</span><br><span class="line">    const proFiles = this.getFiles(root).map((filePath) =&gt;</span><br><span class="line">      path.relative(proRoot, filePath)</span><br><span class="line">    );</span><br><span class="line">    const unused = proFiles.filter(</span><br><span class="line">      (filePath) =&gt; !this.uniqNodes.find((node) =&gt; node.name === filePath)</span><br><span class="line">    );</span><br><span class="line">    const filePath = `unused.json`;</span><br><span class="line">    fs.writeFileSync(filePath, JSON.stringify(unused, null, 2));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  gitDiffFiles(commitHash, branch) &#123;</span><br><span class="line">    return axios</span><br><span class="line">      .get(</span><br><span class="line">        `xxx` // 获取此次打包的信息</span><br><span class="line">      )</span><br><span class="line">      .then((res) =&gt; res &amp;&amp; res.data)</span><br><span class="line">      .then((res) =&gt; &#123;</span><br><span class="line">        if (!res || !res.results || !res.results.length) &#123;</span><br><span class="line">          return Promise.reject(&quot;当前分支无上线版本，无法进行依赖分析&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        const index = res.results.findIndex(</span><br><span class="line">          (r) =&gt; r.base_commit_hash === commitHash</span><br><span class="line">        );</span><br><span class="line">        return res.results[</span><br><span class="line">          index === -1 || index &gt;= res.results.length - 1 ? 0 : index + 1</span><br><span class="line">        ].base_commit_hash;</span><br><span class="line">      &#125;)</span><br><span class="line">      .then((lastHash) =&gt; &#123;</span><br><span class="line">        console.log(&quot;Diff hash from: &quot;, lastHash, &quot; to: &quot;, commitHash);</span><br><span class="line">        return axios.get(</span><br><span class="line">          `xxx` // get git diff files from gitlab</span><br><span class="line">        );</span><br><span class="line">      &#125;)</span><br><span class="line">      .then((res) =&gt; res.data)</span><br><span class="line">      .then((res) =&gt; res.diffs.map((diff) =&gt; diff.new_path));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  generate(commitHash, branch) &#123;</span><br><span class="line">    const router = getRouterInfo(routerConfig[0]);</span><br><span class="line">    return this.gitDiffFiles(commitHash, branch)</span><br><span class="line">      .then((filesTemp) =&gt; &#123;</span><br><span class="line">        const files = filesTemp.filter((p) =&gt; p.match(&quot;^src/&quot;));</span><br><span class="line">        console.log(&quot;Diff files: &quot;, files);</span><br><span class="line">        return files;</span><br><span class="line">      &#125;)</span><br><span class="line">      .then((files) =&gt; &#123;</span><br><span class="line">        this.uniqNodes.forEach((node) =&gt; &#123;</span><br><span class="line">          if (files.includes(node.name)) &#123;</span><br><span class="line">            node.changed = true;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        this.clearTree(this.root, []);</span><br><span class="line">        return this.root;</span><br><span class="line">      &#125;)</span><br><span class="line">      .then((data) =&gt;</span><br><span class="line">        axios(&#123;</span><br><span class="line">          url: &quot;xxx&quot;, // upload result</span><br><span class="line">          method: &quot;POST&quot;,</span><br><span class="line">          data: &#123; body: data, commitHash, router, branch &#125;,</span><br><span class="line">          headers: &#123; &quot;Content-Type&quot;: &quot;application/json&quot; &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">      )</span><br><span class="line">      .then((res) =&gt; res.data)</span><br><span class="line">      .then((res) =&gt; &#123;</span><br><span class="line">        if (res.code === 0) &#123;</span><br><span class="line">          console.log(&quot;依赖分析构建成功！&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          console.error(&quot;依赖分析构建失败：&quot;, res.message);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch((err) =&gt; &#123;</span><br><span class="line">        console.error(&quot;依赖分析构建失败：&quot;, err);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const tree = new DependencyTree();</span><br><span class="line"></span><br><span class="line">class DependencesAnalysisPlugin &#123;</span><br><span class="line">  constructor(options = &#123;&#125;) &#123;</span><br><span class="line">    this.options = options;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  afterResolve(result, callback) &#123;</span><br><span class="line">    const &#123; resourceResolveData &#125; = result;</span><br><span class="line">    const &#123;</span><br><span class="line">      context: &#123; issuer &#125;,</span><br><span class="line">      path,</span><br><span class="line">      descriptionFileRoot,</span><br><span class="line">    &#125; = resourceResolveData;</span><br><span class="line">    if (!analysisBreak(path, issuer)) &#123;</span><br><span class="line">      tree.addDependency(</span><br><span class="line">        issuer &amp;&amp; issuer.replace(new RegExp(`^$&#123;descriptionFileRoot&#125;/`), &quot;&quot;),</span><br><span class="line">        path.replace(new RegExp(`^$&#123;descriptionFileRoot&#125;/`), &quot;&quot;)</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    callback(null, result);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    compiler.hooks.normalModuleFactory.tap(pluginName, (nmf) =&gt; &#123;</span><br><span class="line">      nmf.hooks.afterResolve.tapAsync(pluginName, this.afterResolve);</span><br><span class="line">    &#125;);</span><br><span class="line">    compiler.hooks.done.tap(pluginName, (</span><br><span class="line">      stats /* stats is passed as an argument when done hook is tapped.  */</span><br><span class="line">    ) =&gt; &#123;</span><br><span class="line">      tree.generate(this.options.commitId, this.options.branch);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = DependencesAnalysisPlugin;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;分析项目的依赖为树图，对比两次上线的 diff，得出受影响的页面，方便进行回归测试&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/
      
    
    </summary>
    
      <category term="工程化建设" scheme="https://skhon.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%BB%BA%E8%AE%BE/"/>
    
    
      <category term="Engineering" scheme="https://skhon.github.io/tags/Engineering/"/>
    
  </entry>
  
  <entry>
    <title>【规范建设】基于Lerna管理 - Monorepo项目的最佳实践</title>
    <link href="https://skhon.github.io/2022/05/18/engineering/monorepo/"/>
    <id>https://skhon.github.io/2022/05/18/engineering/monorepo/</id>
    <published>2022-05-18T15:10:49.225Z</published>
    <updated>2022-05-18T15:35:44.921Z</updated>
    
    <content type="html"><![CDATA[<p>对于维护过多个package的同学来说，都会遇到一个选择题，这些package是放在一个仓库里维护还是放在多个仓库里单独维护，本文通过一个示例讲述了如何基于Lerna管理多个package，并和其它工具整合，打造高效、完美的工作流，最终形成一个最佳实践</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在工作中接触到一个项目，这个项目是维护一套 CLI，发到 npm 上供开发者使用。先看一张图：</p><image src="/images/monorepo/m1.png"><p>项目仓库中的根目录上就三个子模块的文件夹，分别对应三个 package，在熟悉了构建和发布流程后，有点傻了。工作流程如图中所示：</p><ol><li><p>使用webpack、babel和uglifyjs把 pkg-a 的 src 编译到 dist</p></li><li><p>使用webpack、babel和uglifyjs把 pkg-b 的 src 编译到 dist</p></li><li><p>使用webpack、babel和uglifyjs把 pkg-main 的 src 编译到 dist</p></li><li><p>最后使用拷贝文件的方式，把pkg-main、pkg-a、pkg-b中编译后的文件组装到 pkg-npm 中，最终用于发布到 npm 上去。</p></li></ol><h2 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h2><ol><li><p>不好调试。因为最终的包是通过文件拷贝的方式组装到一起的，并且都是压缩过的，无法组建一个自上到下的调试流程（实际工作中只能加log，然后重新把包编译组装一遍看效果）</p></li><li><p>包的依赖关系不清晰。pkg-a、pkg-b索性没有版本管理，更像是源码级别的，但逻辑又比较独立。pkg-main中的package.json最终会拷贝到 pkg-npm 中，但又依赖pkg-a、pkg-b中的某些包，所以要把pkg-a、pkg-b中的依赖合并到pkg-main中。pkg-main和pkg-npm的package.json耦合在一起，导致一些本来是工程的开发依赖也会发布到 npm 上去，变成pkg-npm 的依赖包。</p></li><li><p>依赖的包冗余。可以看到，pkg-a、pkg-b、pkg-main要分别编译，都依赖了babel、webpack等，要分别 cd 到各个目录安装依赖。</p></li><li><p>发布需要手动修改版本号。 因为最终只发布了一个包，但实际逻辑要求这个包即要全局安装又要本地安装，业务没有拆开，导致要安装两遍。耦合一起，即便使用 npm link 也会导致调试困难，</p></li><li><p>发版没有 CHANGELOG.md。 因为pkg-a、pkg-b都没有真正管理版本，所以也没有完善的CHANGELOG来记录自上个版本发布已来的变动。</p></li></ol><p>整个项目像是一个没有被管理起来的 Monorepo。那什么又是 Monorepo 呢？</p><h2 id="Monorepo-vs-Multirepo"><a href="#Monorepo-vs-Multirepo" class="headerlink" title="Monorepo vs Multirepo"></a>Monorepo vs Multirepo</h2><p>Monorepo 的全称是 monolithic repository，即单体式仓库，与之对应的是 Multirepo(multiple repository)，这里的“单”和“多”是指每个仓库中所管理的模块数量。</p><p>Multirepo 是比较传统的做法，即每一个 package 都单独用一个仓库来进行管理。例如：Rollup, …</p><p>Monorep 是把所有相关的 package 都放在一个仓库里进行管理，每个 package 独立发布。例如：React, Angular, Babel, Jest, Umijs, Vue …</p><p>一图胜千言：</p><image src="/images/monorepo/m2.png"><p>当然到底哪一种管理方式更好，仁者见仁，智者见智。前者允许多元化发展（各项目可以有自己的构建工具、依赖管理策略、单元测试方法），后者希望集中管理，减少项目间的差异带来的沟通成本。</p><p>虽然拆分子仓库、拆分子 npm 包是进行项目隔离的天然方案，但当仓库内容出现关联时，没有任何一种调试方式比源码放在一起更高效。</p><p>结合我们项目的实际场景和业务需要，天然的 MonoRepo ! 因为工程化的最终目的是让业务开发可以 100% 聚焦在业务逻辑上，那么这不仅仅是脚手架、框架需要从自动化、设计上解决的问题，这涉及到仓库管理的设计。</p><p>一个理想的开发环境可以抽象成这样：</p><p><strong>“只关心业务代码，可以直接跨业务复用而不关心复用方式，调试时所有代码都在源码中。”</strong></p><p>在前端开发环境中，多 Git Repo，多 npm 则是这个理想的阻力，它们导致复用要关心版本号，调试需要 npm link。而这些是 MonoRepo 最大的优势。</p><p>上图中提到的利用相关工具就是今天的主角 Lerna ! Lerna是业界知名度最高的 Monorepo 管理工具，功能完整。</p><h2 id="Lerna"><a href="#Lerna" class="headerlink" title="Lerna"></a>Lerna</h2><h3 id="Lerna-是什么"><a href="#Lerna-是什么" class="headerlink" title="Lerna 是什么"></a>Lerna 是什么</h3><blockquote><p>A tool for managing JavaScript projects with multiple packages.</p><p>Lerna is a tool that optimizes the workflow around managing multi-package repositories with git and npm.</p></blockquote><p>Lerna 是一个管理多个 npm 模块的工具，是 Babel 自己用来维护自己的 Monorepo 并开源出的一个项目。优化维护多包的工作流，解决多个包互相依赖，且发布需要手动维护多个包的问题。</p><p>Lerna 现在已经被很多著名的项目组织使用，如：Babel, React, Vue, Angular, Ember, Meteor, Jest 。</p><p>一个基本的 Lerna 管理的仓库结构如下：</p><image src="/images/monorepo/m3.png"><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h4><blockquote><p>推荐全局安装，因为会经常用到 lerna 命令</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g lerna</span><br></pre></td></tr></table></figure><h4 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a><strong>项目构建</strong></h4><p> <strong>1.初始化</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lerna init</span><br></pre></td></tr></table></figure><blockquote><p>init 命令详情 请参考 lerna init</p></blockquote><image src="/images/monorepo/m4.png"><p>其中 package.json &amp; lerna.json 如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;root&quot;,</span><br><span class="line">  &quot;private&quot;: true, // 私有的，不会被发布，是管理整个项目，与要发布到npm的解耦</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;lerna&quot;: &quot;^3.15.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// lerna.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;packages&quot;: [</span><br><span class="line">    &quot;packages/*&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;version&quot;: &quot;0.0.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>2.增加两个 packages</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lerna create @mo-demo/cli</span><br><span class="line">lerna create @mo-demo/cli-shared-utils</span><br></pre></td></tr></table></figure><blockquote><p>create 命令详情 请参考 lerna create</p></blockquote><image src="/images/monorepo/m5.png"><p> <strong>3.分别给相应的 package 增加依赖模块</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lerna add chalk                                           // 为所有 package 增加 chalk 模块</span><br><span class="line">lerna add semver --scope @mo-demo/cli-shared-utils        // 为 @mo-demo/cli-shared-utils 增加 semver 模块</span><br><span class="line">lerna add @mo-demo/cli-shared-utils --scope @mo-demo/cli  // 增加内部模块之间的依赖</span><br></pre></td></tr></table></figure><blockquote><p>add 命令详情 请参考 lerna add</p></blockquote><image src="/images/monorepo/m6.png"><p> <strong>4.发布</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lerna publish</span><br></pre></td></tr></table></figure><blockquote><p>publish 命令详情 请参考 lerna publish</p></blockquote><image src="/images/monorepo/m7.png"><p>如下是发布的情况，lerna会让你选择要发布的版本号，我发了@0.0.1-alpha.0 的版本。</p><blockquote><p> <strong>发布 npm 包需要登陆 npm 账号</strong> </p></blockquote><image src="/images/monorepo/m8.png"><image src="/images/monorepo/m9.png"><p> <strong>5.安装依赖包 &amp; 清理依赖包</strong> </p><p>上述1-4步已经包含了 Lerna 整个生命周期的过程了，但当我们维护这个项目时，新拉下来仓库的代码后，需要为各个 package 安装依赖包。</p><p>我们在第4步 lerna add 时也发现了，为某个 package 安装的包被放到了这个 package 目录下的 node_modules 目录下。这样对于多个 package 都依赖的包，会被多个 package 安装多次，并且每个 package 下都维护 node_modules ，也不清爽。于是我们使用 –hoist 来把每个 package 下的依赖包都提升到工程根目录，来降低安装以及管理的成本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lerna bootstrap --hoist</span><br></pre></td></tr></table></figure><blockquote><p>bootstrap 命令详情 请参考 lerna bootstrap</p></blockquote><image src="/images/monorepo/m10.png"><p> <strong>为了省去每次都输入 –hoist 参数的麻烦，可以在 lerna.json 配置：</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;packages&quot;: [</span><br><span class="line">    &quot;packages/*&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;command&quot;: &#123;</span><br><span class="line">    &quot;bootstrap&quot;: &#123;</span><br><span class="line">      &quot;hoist&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.1-alpha.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置好后，对于之前依赖包已经被安装到各个 package 下的情况，我们只需要清理一下安装的依赖即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lerna clean</span><br></pre></td></tr></table></figure><p>然后执行 lerna bootstrap 即可看到 package 的依赖都被安装到根目录下的 node_modules 中了。</p><image src="/images/monorepo/m11.png"><h2 id="Lerna的最佳实践"><a href="#Lerna的最佳实践" class="headerlink" title="Lerna的最佳实践"></a>Lerna的最佳实践</h2><p>lerna不负责构建，测试等任务，它提出了一种集中管理package的目录模式，提供了一套自动化管理程序，让开发者不必再深耕到具体的组件里维护内容，在项目根目录就可以全局掌控，基于 npm scripts，使用者可以很好地完成组件构建，代码格式化等操作。接下来我们就来看看，如果基于 Lerna，并结合其它工具来搭建 Monorepo 项目的最佳实践。</p><h3 id="一、优雅的提交"><a href="#一、优雅的提交" class="headerlink" title="一、优雅的提交"></a>一、优雅的提交</h3><p> <strong>1.commitizen &amp;&amp; cz-lerna-changelog</strong> </p><p>commitizen 是用来格式化 git commit message 的工具，它提供了一种问询式的方式去获取所需的提交信息。</p><p>cz-lerna-changelog 是专门为 Lerna 项目量身定制的提交规范，在问询的过程，会有类似影响哪些 package 的选择。如下：</p><image src="/images/monorepo/m12.png"><p>我们使用 commitizen 和 cz-lerna-changelog 来规范提交，为后面自动生成日志作好准备。</p><p>因为这是整个工程的开发依赖，所以在根目录安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i -D commitizen</span><br><span class="line">npm i -D cz-lerna-changelog</span><br></pre></td></tr></table></figure><p>安装完成后，在 package.json 中增加 config 字段，把 cz-lerna-changelog 配置给 commitizen。同时因为commitizen不是全局安全的，所以需要添加 scripts 脚本来执行 git-cz</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;root&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;c&quot;: &quot;git-cz&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;config&quot;: &#123;</span><br><span class="line">    &quot;commitizen&quot;: &#123;</span><br><span class="line">      &quot;path&quot;: &quot;./node_modules/cz-lerna-changelog&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;commitizen&quot;: &quot;^3.1.1&quot;,</span><br><span class="line">    &quot;cz-lerna-changelog&quot;: &quot;^2.0.2&quot;,</span><br><span class="line">    &quot;lerna&quot;: &quot;^3.15.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后在常规的开发中就可以使用 npm run c 来根据提示一步一步输入，来完成代码的提交。</p><image src="/images/monorepo/m13.png"><p> <strong>2.commitlint &amp;&amp; husky</strong> </p><p>上面我们使用了 commitizen 来规范提交，但这个要靠开发自觉使用 npm run c 。万一忘记了，或者直接使用 git commit 提交怎么办？答案就是在提交时对提交信息进行校验，如果不符合要求就不让提交，并提示。校验的工作由 commitlint 来完成，校验的时机则由 husky 来指定。husky 继承了 Git 下所有的钩子，在触发钩子的时候，husky 可以阻止不合法的 commit,push 等等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 安装 commitlint 以及要遵守的规范</span><br><span class="line">npm i -D @commitlint/cli @commitlint/config-conventional</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 在工程根目录为 commitlint 增加配置文件 commitlint.config.js 为commitlint 指定相应的规范</span><br><span class="line">module.exports = &#123; extends: [&apos;@commitlint/config-conventional&apos;] &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 安装 husky</span><br><span class="line">npm i -D husky</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 在 package.json 中增加如下配置</span><br><span class="line">&quot;husky&quot;: &#123;</span><br><span class="line">  &quot;hooks&quot;: &#123;</span><br><span class="line">    &quot;commit-msg&quot;: &quot;commitlint -E HUSKY_GIT_PARAMS&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“commit-msg”是git提交时校验提交信息的钩子，当触发时便会使用 commitlit 来校验。安装配置完成后，想通过 git commit 或者其它第三方工具提交时，只要提交信息不符合规范就无法提交。从而约束开发者使用 npm run c 来提交。</p><p> <strong>3.standardjs &amp;&amp; lint-staged</strong> </p><p>除了规范提交信息，代码本身肯定也少了靠规范来统一风格。</p><p>standardjs就是完整的一套 JavaScript 代码规范，自带 linter &amp; 代码自动修正。它无需配置，自动格式化代码并修正，提前发现风格以及程序问题。</p><p>lint-staged staged 是 Git 里的概念，表示暂存区，lint-staged 表示只检查并矫正暂存区中的文件。一来提高校验效率，二来可以为老的项目带去巨大的方便。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 安装</span><br><span class="line">npm i -D standard lint-staged</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;root&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;c&quot;: &quot;git-cz&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;config&quot;: &#123;</span><br><span class="line">    &quot;commitizen&quot;: &#123;</span><br><span class="line">      &quot;path&quot;: &quot;./node_modules/cz-lerna-changelog&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;husky&quot;: &#123;</span><br><span class="line">    &quot;hooks&quot;: &#123;</span><br><span class="line">      &quot;pre-commit&quot;: &quot;lint-staged&quot;,</span><br><span class="line">      &quot;commit-msg&quot;: &quot;commitlint -E HUSKY_GIT_PARAMS&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;lint-staged&quot;: &#123;</span><br><span class="line">    &quot;*.js&quot;: [</span><br><span class="line">      &quot;standard --fix&quot;,</span><br><span class="line">      &quot;git add&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;@commitlint/cli&quot;: &quot;^8.1.0&quot;,</span><br><span class="line">    &quot;@commitlint/config-conventional&quot;: &quot;^8.1.0&quot;,</span><br><span class="line">    &quot;commitizen&quot;: &quot;^3.1.1&quot;,</span><br><span class="line">    &quot;cz-lerna-changelog&quot;: &quot;^2.0.2&quot;,</span><br><span class="line">    &quot;husky&quot;: &quot;^3.0.0&quot;,</span><br><span class="line">    &quot;lerna&quot;: &quot;^3.15.0&quot;,</span><br><span class="line">    &quot;lint-staged&quot;: &quot;^9.2.0&quot;,</span><br><span class="line">    &quot;standard&quot;: &quot;^13.0.2&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安装完成后，在 package.json 增加 lint-staged 配置，如上所示表示对暂存区中的 js 文件执行 standard –fix 校验并自动修复。那什么时候去校验呢，就又用到了上面安装的 husky ，husky的配置中增加’pre-commit’的钩子用来执行 lint-staged 的校验操作，如上所示。</p><p>此时提交 js 文件时，便会自动修正并校验错误。即保证了代码风格统一，又能提高代码质量。</p><h3 id="二、自动生成日志"><a href="#二、自动生成日志" class="headerlink" title="二、自动生成日志"></a>二、自动生成日志</h3><p>有了之前的规范提交，自动生成日志便水到渠成了。再详细看下 lerna publish 时做了哪些事情：</p><p>1.调用 lerna version</p><ul><li><p>找出从上一个版本发布以来有过变更的 package</p></li><li><p>提示开发者确定要发布的版本号</p></li><li><p>将所有更新过的的 package 中的package.json的version字段更新</p></li><li><p>将依赖更新过的 package 的 包中的依赖版本号更新</p></li><li><p>更新 lerna.json 中的 version 字段</p></li><li><p>提交上述修改，并打一个 tag</p></li><li><p>推送到 git 仓库</p></li></ul><image src="/images/monorepo/m14.png"><p>2.使用 npm publish 将新版本推送到 npm</p><p>CHANGELOG 很明显是和 version 一一对应的，所以需要在 lerna version 中想办法，查看 lerna version 命令的详细说明后，会看到一个配置参数 –conventional-commits。没错，只要我们按规范提交后，在 lerna version 的过程中会便会自动生成当前这个版本的 CHANGELOG。为了方便，不用每次输入参数，可以配置在 lerna.json中，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;packages&quot;: [</span><br><span class="line">    &quot;packages/*&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;command&quot;: &#123;</span><br><span class="line">    &quot;bootstrap&quot;: &#123;</span><br><span class="line">      &quot;hoist&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;version&quot;: &#123;</span><br><span class="line">      &quot;conventionalCommits&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;ignoreChanges&quot;: [</span><br><span class="line">    &quot;**/*.md&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;version&quot;: &quot;0.0.1-alpha.1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>lerna version 会检测从上一个版本发布以来的变动，但有一些文件的提交，我们不希望触发版本的变动，譬如 .md 文件的修改，并没有实际引起 package 逻辑的变化，不应该触发版本的变更。可以通过 ignoreChanges 配置排除。如上。</p></blockquote><image src="/images/monorepo/m15.png"><blockquote><p>实际 lerna version 很少直接使用，因为它包含在 lerna publish 中了，直接使用 lerna publish就好了。</p><p>Lerna 在管理 package 的版本号上，提供了两种模式供选择 Fixed or Independent。默认是 Fixed，更多细节，以及 Lerna 的更多玩法，请参考官网文档：</p><p><a href="https://github.com/lerna/lerna/blob/master/README.md" target="_blank" rel="noopener"> <em>https://github.com/lerna/lerna/blob/master/README.md</em> </a></p></blockquote><h3 id="三、编译、压缩、调试"><a href="#三、编译、压缩、调试" class="headerlink" title="三、编译、压缩、调试"></a>三、编译、压缩、调试</h3><p> <strong>采用 Monorepo 结构的项目，各个 package 的结构最好保持统一。</strong> </p><p>根据目前的项目状况，设计如下：</p><ol><li><p>各 package 入口统一为 index.js</p></li><li><p>各 package 源码入口统一为 src/index.js</p></li><li><p>各 package 编译入口统一为 dist/index.js</p></li><li><p>各 package 统一使用 ES6 语法、使用 Babel 编译、压缩并输出到 dist</p></li><li><p>各 package 发布时只发布 dist 目录，不发布 src 目录</p></li><li><p>各 package 注入 LOCAL_DEBUG 环境变量， 在index.js 中区分是调试还是发布环境，调试环境 ruquire(./src/index.js) 保证所有源码可调试。发布环境 ruquire(./dist/index.js) 保证所有源码不被发布。</p></li></ol><blockquote><p>因为 dist 是 Babel 编译后的目录，我们在搜索时不希望搜索它的内容，所以在工程的设置中把 dist 目录排除在搜索的范围之外。</p></blockquote><p>接下来，我们按上面的规范，搭建 package 的结构。</p><p> <strong>首先安装依赖</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i -D @babel/cli @babel/core @babel/preset-env  // 使用 Babel 必备 详见官网用法</span><br><span class="line">npm i -D @babel/node                               // 用于调试 因为用了 import&amp;export 等 ES6 的语法</span><br><span class="line">npm i -D babel-preset-minify                       // 用于压缩代码</span><br></pre></td></tr></table></figure><blockquote><p>由于各 package 的结构统一，所以类似 Babel 这样的工具，只在根目录安装就好了，不需要在各 package 中安装，简直是清爽的要死了。</p></blockquote><p> <strong>增加 Babel 配置</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 根目录新建 babel.config.js</span><br><span class="line">module.exports = function (api) &#123;</span><br><span class="line">  api.cache(true)</span><br><span class="line"> </span><br><span class="line">  const presets = [</span><br><span class="line">    [</span><br><span class="line">      &apos;@babel/env&apos;,</span><br><span class="line">      &#123;</span><br><span class="line">        targets: &#123;</span><br><span class="line">          node: &apos;8.9&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line"> </span><br><span class="line">  // 非本地调试模式才压缩代码，不然调试看不到实际变量名</span><br><span class="line">  if (!process.env[&apos;LOCAL_DEBUG&apos;]) &#123;</span><br><span class="line">    presets.push([</span><br><span class="line">      &apos;minify&apos;</span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  const plugins = []</span><br><span class="line"> </span><br><span class="line">  return &#123;</span><br><span class="line">    presets,</span><br><span class="line">    plugins,</span><br><span class="line">    ignore: [&apos;node_modules&apos;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>修改各 package 的代码</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// @mo-demo/cli/index.js</span><br><span class="line">if (process.env.LOCAL_DEBUG) &#123;</span><br><span class="line">  require(&apos;./src/index&apos;)                        // 如果是调试模式，加载src中的源码</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  require(&apos;./dist/index&apos;)                       // dist会发到npm</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// @mo-demo/cli/src/index.js</span><br><span class="line">import &#123; log &#125; from &apos;@mo-demo/cli-shared-utils&apos;  // 从 utils 模块引入依赖并使用 log 函数</span><br><span class="line">log(&apos;cli/index.js as cli entry exec!&apos;)</span><br><span class="line"> </span><br><span class="line">// @mo-demo/cli/package.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;files&quot;: [</span><br><span class="line">    &quot;dist&quot;                                       // 发布 dist</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">// @mo-demo/cli-shared-utils/index.js</span><br><span class="line">if (process.env.LOCAL_DEBUG) &#123;</span><br><span class="line">  module.exports = require(&apos;./src/index&apos;)        // 如果是调试模式，加载src中的源码</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  module.exports = require(&apos;./dist/index&apos;)       // dist会发到npm</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// @mo-demo/cli-shared-utils/src/index.js</span><br><span class="line">const log = function (str) &#123;</span><br><span class="line">  console.log(str)</span><br><span class="line">&#125;</span><br><span class="line">export &#123;                                         //导出 log 接口</span><br><span class="line">  log</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// @mo-demo/cli-shared-utils/package.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;files&quot;: [</span><br><span class="line">    &quot;dist&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>修改发布的脚本</strong> </p><p>npm run b 用来对各 pacakge 执行 babel 的编译，从 src 目录输出出 dist 目录，使用根目录的配置文件 babel.config.js。</p><p>npm run p 用来取代 lerna publish，在 publish 前先执行 npm run b来编译。</p><p>其它常用的 lerna 命令也添加到 scripts 中来，方便使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 工程根目录 package.json</span><br><span class="line"> &quot;scripts&quot;: &#123;</span><br><span class="line">   &quot;c&quot;: &quot;git-cz&quot;,</span><br><span class="line">   &quot;i&quot;: &quot;lerna bootstrap&quot;,</span><br><span class="line">   &quot;u&quot;: &quot;lerna clean&quot;,</span><br><span class="line">   &quot;p&quot;: &quot;npm run b &amp;&amp; lerna publish&quot;,</span><br><span class="line">   &quot;b&quot;: &quot;lerna exec -- babel src -d dist --config-file ../../babel.config.js&quot;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> <strong>调试</strong> </p><p>我们使用vscode自带的调试功能调试，也可以使用 Node + Chrome 调试，看开发者习惯。</p><p>我们就 vscode 为例，请参考 <a href="https://code.visualstudio.com/docs/editor/debugging" target="_blank" rel="noopener"> <em>https://code.visualstudio.com/docs/editor/debugging</em> </a>。</p><p>增加如下调试配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// .vscode/launch.json</span><br><span class="line">&#123;</span><br><span class="line">    // 使用 IntelliSense 了解相关属性。</span><br><span class="line">    // 悬停以查看现有属性的描述。</span><br><span class="line">    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;node&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;debug cli&quot;,</span><br><span class="line">            &quot;runtimeExecutable&quot;: &quot;$&#123;workspaceRoot&#125;/node_modules/.bin/babel-node&quot;,</span><br><span class="line">            &quot;runtimeArgs&quot;: [</span><br><span class="line">                &quot;$&#123;workspaceRoot&#125;/packages/cli/src/index.js&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;env&quot;: &#123;</span><br><span class="line">                &quot;LOCAL_DEBUG&quot;: &quot;true&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;console&quot;: &quot;integratedTerminal&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 src 的代码是 ES6 的，所以要使用 babel-node去跑调试，@babel/node 已经在前面安装过了。</p><image src="/images/monorepo/m16.png"><p> <strong>最棒的是，可以直接使用单步调试，调到依赖的模块中去，</strong> 如上图，我们要执行 @mo-demo/cli-shared-utils 模块中的 log 方法，单步进入，会直接跳到 @mo-demo/cli-shared-utils src 源码中去执行。如下图</p><image src="/images/monorepo/m17.png"><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>到这里，基本上已经构建了基于 Lerna 管理 packages 的 Monorepo 项目的最佳实践了，该有的功能都有：</p><ul><li><p>完善的工作流</p></li><li><p>流畅的调试体验</p></li><li><p>风格统一的编码</p></li><li><p>一键式的发布机制</p></li><li><p>完美的更新日志</p></li><li><p>……</p></li></ul><image src="/images/monorepo/m18.png"><p>当然，Lerna 还有更多的功能等待着你去发掘，还有很多可以结合 Lerna 一起使用的工具。构建一套完善的仓库管理机制，可能它的收益不是一些量化的指标可以衡量出来的，也没有直接的价值输出，但 <strong>它能在日常的工作中极大的提高工作效率，解放生产力，节省大量的人力成本。</strong> </p></image></image></image></image></image></image></image></image></image></image></image></image></image></image></image></image></image></image>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于维护过多个package的同学来说，都会遇到一个选择题，这些package是放在一个仓库里维护还是放在多个仓库里单独维护，本文通过一个示例讲述了如何基于Lerna管理多个package，并和其它工具整合，打造高效、完美的工作流，最终形成一个最佳实践&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
      <category term="工程化建设" scheme="https://skhon.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%BB%BA%E8%AE%BE/"/>
    
    
      <category term="Engineering" scheme="https://skhon.github.io/tags/Engineering/"/>
    
  </entry>
  
  <entry>
    <title>【稳定性建设】UI自动化测试+测试覆盖率(二)</title>
    <link href="https://skhon.github.io/2022/05/16/engineering/ui-auto-test2/"/>
    <id>https://skhon.github.io/2022/05/16/engineering/ui-auto-test2/</id>
    <published>2022-05-16T15:20:48.242Z</published>
    <updated>2022-05-16T15:22:57.072Z</updated>
    
    <content type="html"><![CDATA[<p>困死了，先来个todo吧。<br>主要是用的阿里的<a href="https://macacajs.github.io/zh/guide/#%E5%A4%9A%E7%AB%AF%E6%94%AF%E6%8C%81" target="_blank" rel="noopener">Macaca</a>,来做UI自动化测试，这个有测试覆盖率的能力。有待实战。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;困死了，先来个todo吧。&lt;br&gt;主要是用的阿里的&lt;a href=&quot;https://macacajs.github.io/zh/guide/#%E5%A4%9A%E7%AB%AF%E6%94%AF%E6%8C%81&quot; target=&quot;_blank&quot; rel=&quot;noopene
      
    
    </summary>
    
      <category term="工程化建设" scheme="https://skhon.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%BB%BA%E8%AE%BE/"/>
    
    
      <category term="Engineering" scheme="https://skhon.github.io/tags/Engineering/"/>
    
  </entry>
  
  <entry>
    <title>【稳定性建设】UI自动化测试(一)</title>
    <link href="https://skhon.github.io/2022/05/16/engineering/ui-auto-test/"/>
    <id>https://skhon.github.io/2022/05/16/engineering/ui-auto-test/</id>
    <published>2022-05-16T13:09:22.088Z</published>
    <updated>2022-05-16T15:20:20.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>通过Puppeteer模拟用户操作</p><h2 id="Puppeteer介绍"><a href="#Puppeteer介绍" class="headerlink" title="Puppeteer介绍"></a>Puppeteer介绍</h2><p>你可以在浏览器中手动完成的大部分事情都可以使用 Puppeteer 完成！你可以从以下几个示例开始：</p><ul><li>生成页面的截图和PDF。</li><li>抓取SPA并生成预先呈现的内容（即“SSR”）。</li><li>从网站抓取你需要的内容。</li><li>自动表单提交，UI测试，键盘输入等</li><li>创建一个最新的自动化测试环境。使用最新的JavaScript和浏览器功能，直接在最新版本的Chrome中运行测试。</li><li>捕获您的网站的时间线跟踪，以帮助诊断性能问题。</li></ul><p>还有一些可用于工程化相关的建设：</p><ul><li>自动化工具 如自动提交表单，自动下载</li><li>自动化 UI 测试 如记录下正确 DOM 结构或截图，然后自动执行指定操作后，检查 DOM 结构或截图是否匹配(UI 断言)</li><li>定时监控工具 如定时截图发周报，或定时巡查重要业务路径下的页面是否处于可用状态，配合邮件告警</li></ul><h2 id="Puppeteer文档"><a href="#Puppeteer文档" class="headerlink" title="Puppeteer文档"></a>Puppeteer文档</h2><p>个人感觉，这个<a href="https://zhaoqize.github.io/puppeteer-api-zh_CN/#?product=Puppeteer&amp;version=v10.4.0&amp;show=outline" target="_blank" rel="noopener">文档</a>比较适合我。里面api比较详细，还有写小demo。</p><h2 id="为什么要进行UI自动化测试"><a href="#为什么要进行UI自动化测试" class="headerlink" title="为什么要进行UI自动化测试"></a>为什么要进行UI自动化测试</h2><p>业务的更新迭代频繁，传统测试大部分都还是手工、肉眼的模式来进行，无法满足产品敏捷开发、快速迭代的需求。而UI自动化能让全功能的回归变得简单，释放纯手工测试的人力资源，并且回归测试能够覆盖到所有的逻辑场景，这对测试的效率，以及整个开发流程的效率都是很大的提升，并且能够规避很多人的主观和客观因素导致的漏测或者疏忽。<br>其他测试方式的局限性：</p><p><strong>单元测试（Unit Testing）</strong><br>事实上，单元测试确实能够帮助我们发现大部分的问题，但是在复杂的前端交互中，单纯的单元测试并不能真实地反映用户操作的路径，而单元测试一般的场景是测试一系列的功能集合。</p><p><strong>快照测试（Snapshot Testing）</strong><br>DOM结构并不能完全反映页面的视觉效果，DOM结构不变并不完全等于样式不变。此外，大多数工具都是React专用，非React应用基本不支持。</p><blockquote><p>很多人认为，UI总是频繁的变动，导致测试用例维护成本高，性价比低，因此UI自动化测试比较适合场景稳定的业务。其实不是，这里的UI不仅仅指的是视觉，更多的是业务逻辑。UI可以多变，但业务逻辑一定是趋于稳定的，尤其是核心业务，想一想用户得多辛苦才能适应这种业务逻辑频繁变更的产品啊。</p></blockquote><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="第1步：确定功能测试方案"><a href="#第1步：确定功能测试方案" class="headerlink" title="第1步：确定功能测试方案"></a>第1步：确定功能测试方案</h3><p>我们将在以下情况下逐步展示执行Puppeteer自动化的方法–<br>·启动Web浏览器。<br>·调用Amazon Web应用程序。</p><ul><li>搜索书籍“ Testing Book”。</li><li>从结果中将书添加到购物车中。</li><li>打开购物车，然后检查购物车中是否有书籍。</li><li>捕获屏幕并关闭浏览器。</li></ul><h3 id="Step2＃安装Puppeteer并创建测试用例"><a href="#Step2＃安装Puppeteer并创建测试用例" class="headerlink" title="Step2＃安装Puppeteer并创建测试用例"></a>Step2＃安装Puppeteer并创建测试用例</h3><p>在特定文件夹中创建一个空的javascript文件作为“ sample_script.js”。 在这里，我们将根文件夹视为SampleProject。 要安装Puppeteer，我们将使用命令–“ npm install puppeteer”。 根据网络速度，安装过程会花费一些时间。 它将下载大约350MB的数据。 安装后，将在示例Puppeteer项目根文件夹中创建包含不同的puppeteer组件和package-lock.json文件的node_modules文件夹。</p><h3 id="Step3＃捕获测试对象的标识属性"><a href="#Step3＃捕获测试对象的标识属性" class="headerlink" title="Step3＃捕获测试对象的标识属性"></a>Step3＃捕获测试对象的标识属性</h3><p>我们可以使用Chrome网络浏览器的开发者工具捕获标识属性。 分析不同的属性，例如id，name，XPath等，我们将选择可以在脚本执行任何操作中使用的正确属性。 在本“ Puppeteer自动化测试”教程中，我们将在脚本中使用XPath。 按照以下步骤获取XPATH或任何其他属性，</p><ol><li><p>打开“菜单-&gt;更多工具”下可用的开发人员工具，然后转到“元素”选项卡。</p></li><li><p>使用 Finder 工具（单击 Elements 选项卡左上角可用的箭头图标），突出显示应用程序中的测试对象。 在这里，我们将检查搜索框。<br><img src="/images/ui-test/ui1.png"></p></li><li><p>分析突出显示的源代码以识别期望的属性。 要获取测试对象的XPATH属性，请右键单击突出显示的部分，然后单击“复制-&gt;复制Xpath”以将XPATH属性复制到剪贴板中。<br><img src="/images/ui-test/ui2.png"></p></li><li><p>现在，将Xpath粘贴到查找器文本框中，然后按Enter键以检查Xpath是否在唯一地标识对象。<br><img src="/images/ui-test/ui3.png"></p></li><li><p>同样，我们还需要捕获另一个测试对象的标识属性。</p></li></ol><h3 id="Step4＃Puppeteer自动化开发步骤"><a href="#Step4＃Puppeteer自动化开发步骤" class="headerlink" title="Step4＃Puppeteer自动化开发步骤"></a>Step4＃Puppeteer自动化开发步骤</h3><p>现在，我们已经了解了使功能场景自动化的基本技术步骤。 基于这些知识，我们可以通过下面的Puppeteer Automation测试案例。 最常用的类和方法的详细概述将在后续文章中进行解释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @name Amazon search</span><br><span class="line"> */</span><br><span class="line">const puppeteer = require(&apos;puppeteer&apos;);</span><br><span class="line">const reportPath = &apos;C:\\LambdaGeeks\\puppteer_proj_sample\\output\\&apos;;</span><br><span class="line">const screenshot = &apos;screen1.png&apos;;</span><br><span class="line">// Used to export the file into a .docx file</span><br><span class="line">try &#123;</span><br><span class="line">  (async () =&gt; &#123;</span><br><span class="line">    const browser = await puppeteer.launch(&#123; headless: false &#125;);</span><br><span class="line">    const pageNew = await browser.newPage()</span><br><span class="line">    await pageNew.setViewport(&#123; width: 1280, height: 800 &#125;);</span><br><span class="line">    await pageNew.goto(&apos;https://www.amazon.in/&apos;);</span><br><span class="line">    //Enter Search criteria</span><br><span class="line">    let searchBox = await page.waitForXPath(&quot;//*[@id=&apos;twotabsearchtextbox&apos;]&quot;,&#123; visible: true &#125;);</span><br><span class="line">    if (searchBox === null)</span><br><span class="line">    &#123;</span><br><span class="line">        console.log(&apos;Amazon screen is not displayed&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;       </span><br><span class="line">        await searchBox.type(&quot;Testing Book&quot;);</span><br><span class="line">        console.log(&apos;Search criteria has been entered&apos;);</span><br><span class="line">    &#125;       </span><br><span class="line">    //Clicked on search button</span><br><span class="line">    let btnSearch = await pageNew.waitForXPath(&quot;//*/input[@id=&apos;nav-search-submit-button&apos;]&quot;,&#123; visible: true &#125;);</span><br><span class="line">    if (btnSearch === null)</span><br><span class="line">    &#123;</span><br><span class="line">        console.log(&apos;Search button is not showing&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        await btnSearch.click();</span><br><span class="line">        console.log(&apos;Clicked on search button&apos;);</span><br><span class="line">    &#125;   </span><br><span class="line">    //Click on specific search result</span><br><span class="line">    let myBook = await pageNew.waitForXPath(&quot;//*[contains(text(),&apos;Selenium Testing Tools Cookbook Second Edition&apos;)]&quot;,&#123; visible: true &#125;)</span><br><span class="line">    if (myBook === null)</span><br><span class="line">    &#123;</span><br><span class="line">        console.log(&apos;Book is not available&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        await myBook.click();</span><br><span class="line">        console.log(&apos;Click on specific book to order&apos;);</span><br><span class="line">    &#125;   </span><br><span class="line">    // Identify if the new tab has opened</span><br><span class="line">    const pageTarget = pageNew.target();</span><br><span class="line">    const newTarget = await browser.waitForTarget(target =&gt; target.opener() === pageTarget);</span><br><span class="line">    //get the new page object:</span><br><span class="line">    const page2 = await newTarget.pageNew();    </span><br><span class="line">    await page2.setViewport(&#123; width: 1280, height: 800 &#125;);</span><br><span class="line">     </span><br><span class="line">    //Add to cart</span><br><span class="line">    let addToCart = await page2.waitForXPath(&quot;//*/input[@id=&apos;add-to-cart-button&apos;]&quot;,&#123; visible: true &#125;);</span><br><span class="line">    if (addToCart === null)</span><br><span class="line">    &#123;</span><br><span class="line">        console.log(&apos;Add to cart button is not available&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        console.log(&apos;Click on add to Cart button&apos;);</span><br><span class="line">        await addToCart.click();        </span><br><span class="line">    &#125;       </span><br><span class="line">    //Verify add to cart process    </span><br><span class="line">    let successMessage = await page2.waitForXPath(&quot;//*[contains(text(),&apos;Added to Cart&apos;)]&quot;,&#123; visible: true &#125;);</span><br><span class="line">    if (successMessage === null)</span><br><span class="line">    &#123;</span><br><span class="line">        console.log(&apos;Item is not added to cart&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        console.log(&apos;Item is added to cart successfully&apos;);      </span><br><span class="line">    &#125;       </span><br><span class="line">    // Capture no of cart</span><br><span class="line">    let cartCount = await page2.waitForXPath(&quot;//*/span[@id=&apos;nav-cart-count&apos;]&quot;,&#123; visible: true&#125;);</span><br><span class="line">    let value = await page2.evaluate(el =&gt; el.textContent, cartCount)</span><br><span class="line">    console.log(&apos;Cart count: &apos; + value);</span><br><span class="line">    cartCount.focus();</span><br><span class="line">    await page2.screenshot(&#123; path: screenshot &#125;);</span><br><span class="line">     </span><br><span class="line">    await pageNew.waitForTimeout(2000);    </span><br><span class="line">    await page2.close();</span><br><span class="line">    await pageNew.close();</span><br><span class="line">    await browser.close();</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125; catch (err) &#123;</span><br><span class="line">  console.error(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step5＃木偶自动化测试执行"><a href="#Step5＃木偶自动化测试执行" class="headerlink" title="Step5＃木偶自动化测试执行"></a>Step5＃木偶自动化测试执行</h3><p>我们可以使用以下命令启动执行 节点sample_script.js 通过命令提示符。 在执行过程中，将打开Chromium浏览器并自动执行功能步骤，并存储最后一页的屏幕截图。 屏幕截图和控制台输出如下所示。<br><img src="/images/ui-test/ui4.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;p&gt;通过Puppeteer模拟用户操作&lt;/p&gt;
&lt;h2 id=&quot;Puppeteer介绍&quot;&gt;&lt;a href=&quot;#Puppeteer介绍&quot; clas
      
    
    </summary>
    
      <category term="工程化建设" scheme="https://skhon.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%BB%BA%E8%AE%BE/"/>
    
    
      <category term="Engineering" scheme="https://skhon.github.io/tags/Engineering/"/>
    
  </entry>
  
  <entry>
    <title>【node监控】关于node监控的一些整理</title>
    <link href="https://skhon.github.io/2022/05/15/engineering/node-apm/"/>
    <id>https://skhon.github.io/2022/05/15/engineering/node-apm/</id>
    <published>2022-05-14T16:18:26.359Z</published>
    <updated>2022-05-14T16:30:12.533Z</updated>
    
    <content type="html"><![CDATA[<h2 id="业界开源工具"><a href="#业界开源工具" class="headerlink" title="业界开源工具"></a>业界开源工具</h2><p>阿里的 <a href="https://www.yuque.com/hyj1991/easy-monitor/past-and-present" target="_blank" rel="noopener">easy monitor</a></p><h2 id="关于node的一些调试技巧"><a href="#关于node的一些调试技巧" class="headerlink" title="关于node的一些调试技巧"></a>关于node的一些调试技巧</h2><p><a href="https://wizardforcel.gitbooks.io/node-in-debugging/content/" target="_blank" rel="noopener">node调试指南</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;业界开源工具&quot;&gt;&lt;a href=&quot;#业界开源工具&quot; class=&quot;headerlink&quot; title=&quot;业界开源工具&quot;&gt;&lt;/a&gt;业界开源工具&lt;/h2&gt;&lt;p&gt;阿里的 &lt;a href=&quot;https://www.yuque.com/hyj1991/easy-monito
      
    
    </summary>
    
      <category term="工程化建设" scheme="https://skhon.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%BB%BA%E8%AE%BE/"/>
    
    
      <category term="Engineering" scheme="https://skhon.github.io/tags/Engineering/"/>
    
  </entry>
  
  <entry>
    <title>【面试总结】前端面试题目</title>
    <link href="https://skhon.github.io/2022/05/14/interview/detail/"/>
    <id>https://skhon.github.io/2022/05/14/interview/detail/</id>
    <published>2022-05-14T12:01:38.290Z</published>
    <updated>2022-05-14T12:02:23.834Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/haizlin/fe-interview" target="_blank" rel="noopener">前端面试</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/haizlin/fe-interview&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;前端面试&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="面试" scheme="https://skhon.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Interview" scheme="https://skhon.github.io/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>【质量建设】路由依赖分析</title>
    <link href="https://skhon.github.io/2022/05/14/engineering/dep-analysis/"/>
    <id>https://skhon.github.io/2022/05/14/engineering/dep-analysis/</id>
    <published>2022-05-14T11:57:41.277Z</published>
    <updated>2022-05-14T11:58:59.658Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6898151378351292430#heading-0" target="_blank" rel="noopener">路由依赖分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6898151378351292430#heading-0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;路由依赖分析&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="工程化建设" scheme="https://skhon.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%BB%BA%E8%AE%BE/"/>
    
    
      <category term="Engineering" scheme="https://skhon.github.io/tags/Engineering/"/>
    
  </entry>
  
  <entry>
    <title>【质量建设】Webpack - 路径解析库(enhanced-resolve)</title>
    <link href="https://skhon.github.io/2022/05/14/engineering/enhanced-resolve/"/>
    <id>https://skhon.github.io/2022/05/14/engineering/enhanced-resolve/</id>
    <published>2022-05-14T11:45:02.463Z</published>
    <updated>2022-05-14T11:59:15.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="路径解析"><a href="#路径解析" class="headerlink" title="路径解析"></a>路径解析</h2><p>Webpack封装了一套解析库<font color="red">enhanced-resolve</font>专门用于解析路径，例如我们写了<font color="red">require(‘./index’)</font>，Webpack在打包时就会用它来解析出./index的完整路径。<br>我们可以看到他的官方介绍：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Offers an async require.resolve function. It&apos;s highly configurable. Features:</span><br><span class="line">- plug in system</span><br><span class="line">- provide a custom filesystem</span><br><span class="line">- sync and async node.js filesystems included</span><br></pre></td></tr></table></figure></p><p>可以看到官方定义他是一个可配置化的异步require.resolve。如果不了解reqire.resolve的同学可以先看看<a href="https://juejin.cn/post/6844904055806885895" target="_blank" rel="noopener">require.resolve</a>是什么</p><h2 id="reqire-resolve的不足"><a href="#reqire-resolve的不足" class="headerlink" title="reqire.resolve的不足"></a>reqire.resolve的不足</h2><p>可以看到本质上他们做的事情都是一样的，只是在解析路径的规则上enhanced-resolve提供了更强的扩展性，以满足Webpack对解析文件的需求。<br>由于require.resolve只能用在node的环境下，所以在设计时require.resolve只配置了node相关的依赖规则，而Webpack面对的环境多种多样，以下列举一些Webpack做的增强内容：</p><h3 id="扩展名查询配置"><a href="#扩展名查询配置" class="headerlink" title="扩展名查询配置"></a>扩展名查询配置</h3><p>例如解析./index时由于没有提供扩展名，所以它们都会去尝试遍历可能会有的文件，node会去尝试路径下是否有.js .json .node文件，而Webpack需要面对的文件扩展不止这三种，可通过配置扩展。</p><h3 id="文件夹查询"><a href="#文件夹查询" class="headerlink" title="文件夹查询"></a>文件夹查询</h3><p>require.resolve只会去解析文件的完整路径，但是enhanced-resolve既可以查询文件也可以查询文件夹。这个功能在Webpack中非常有用，可以通过它导入一个文件夹下的多个文件，只需要配置resolveToContext: true，就会尝试解析目录的完整路径。</p><h3 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h3><p>在解析成功时，require.resolve的返回值只有一个完整路径，enhanced-resolve的返回值还包含了描述文件等较为丰富的数据。</p><h3 id="别名配置"><a href="#别名配置" class="headerlink" title="别名配置"></a>别名配置</h3><p>node下使用别名是挺麻烦的事，但是enhanced-resolve非常好地支持了这个功能，即能让我们代码看上去更整洁，配合缓存还能提高解析效率。</p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><p>可以到github: enhanced-resolve下载一份源码，本次我们使用4.1.1版本解析，下载完成后切换到对应分支，yarn add下载依赖模块。<br>在项目的package.json里，我们可以找到项目的导出文件是”main”: “lib/node.js”，可以从这个文件入手开始探究源码。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在主目录新建index.js，这里演示了常用的操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var resolve = require(&quot;./lib/node&quot;);</span><br><span class="line">// 解析相对目录下index.js文件</span><br><span class="line">resolve(__dirname, &apos;./index.js&apos;, (err, p, result) =&gt; &#123;</span><br><span class="line">    // p = /Users/enhanced-resolve/index.js</span><br><span class="line">    console.log(err, p, result)</span><br><span class="line">&#125;)</span><br><span class="line">// 解析模块diff导出文件</span><br><span class="line">resolve(__dirname, &apos;diff&apos;, (err, p, result) =&gt; &#123;</span><br><span class="line">    // p = /Users/enhanced-resolve/node_modules/diff/diff.js</span><br><span class="line">    console.log(err, p, result)</span><br><span class="line">&#125;)</span><br><span class="line">// 解析绝对目录下的index.js文件</span><br><span class="line">resolve(__dirname, &apos;/Users/enhanced-resolve/index.js&apos;, (err, p, result) =&gt; &#123;</span><br><span class="line">    // p = /Users/enhanced-resolve/index.js</span><br><span class="line">    console.log(err, p, result)</span><br><span class="line">&#125;)</span><br><span class="line">// 解析相对路径下的目录</span><br><span class="line">resolve.context(__dirname, &apos;./&apos;, (err, p, result) =&gt; &#123;</span><br><span class="line">    // p = /Users/enhanced-resolve</span><br><span class="line">    console.log(err, p, result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="打印调试信息"><a href="#打印调试信息" class="headerlink" title="打印调试信息"></a>打印调试信息</h3><p>由于项目使用Tapable来组织流程，调试起来比较累，好在它提供的调试打印信息还算丰富，我们在Resolver.js第176行加上配置log: console.log，可以打印调试信息到控制台：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    return this.doResolve(</span><br><span class="line">        this.hooks.resolve,</span><br><span class="line">        obj,</span><br><span class="line">        message,</span><br><span class="line">        &#123;</span><br><span class="line">            missing: resolveContext.missing,</span><br><span class="line">            stack: resolveContext.stack,</span><br><span class="line">+           log: console.log,</span><br><span class="line">        &#125;,</span><br></pre></td></tr></table></figure></p><h2 id="复制代码核心源码分析"><a href="#复制代码核心源码分析" class="headerlink" title="复制代码核心源码分析"></a>复制代码核心源码分析</h2><h3 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h3><p>这个文件为我们提供了开箱即用的解析函数，根据不同场景预定义了默认参数，最终通过ResolverFactory.createResolver创建并执行路径解析，主要有以下三种场景：</p><ul><li>文件路径解析：默认文件后缀为[“.js”, “.json”, “.node”]</li><li>文件夹路径解析：只判断文件夹是否存在</li><li>Loader路径解析：专门用于Webpack的Loader文件路径解析</li></ul><p>另外每种场景都提供同步和异步调用方式，且默认文件操作通过CachedInputFileSystem包装提供缓存功能。</p><h3 id="ResolverFactory-js"><a href="#ResolverFactory-js" class="headerlink" title="ResolverFactory.js"></a>ResolverFactory.js</h3><p>主要做了两件事，一是参数解析，二是初始化插件，首先会根据参数来将需要用到的插件创建出来，调用他们的apply方法来初始化插件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">plugins = []</span><br><span class="line">plugins.push(new ParsePlugin(&quot;resolve&quot;, &quot;parsed-resolve&quot;));</span><br><span class="line">//...</span><br><span class="line">plugins.push(new ResultPlugin(resolver.hooks.resolved));</span><br><span class="line">plugins.forEach(plugin =&gt; &#123;</span><br><span class="line">    plugin.apply(resolver);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>复制代码enhanced-resolve通过Tapable将所有插件串联起来，每个插件负责一件事情，通过事件流的方式传递每个插件的解析结果。所以只要看懂了插件之间的流转过程，就能明白它的工作原理。</p><h3 id="Resolver-js"><a href="#Resolver-js" class="headerlink" title="Resolver.js"></a>Resolver.js</h3><p>这里是整个解析流程的核心，它继承了Tapable类，下面我们重点分析里面的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Resolver extends Tapable &#123;</span><br><span class="line">constructor(fileSystem) &#123;</span><br><span class="line">super();</span><br><span class="line">this.fileSystem = fileSystem;</span><br><span class="line">this.hooks = &#123;</span><br><span class="line">resolve: new AsyncSeriesBailHook([&quot;request&quot;, &quot;resolveContext&quot;])</span><br><span class="line">&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="ensureHook"><a href="#ensureHook" class="headerlink" title="ensureHook()"></a>ensureHook()</h4><p>这个函数主要用与动态添加钩子，在构造函数中只定义了3个钩子，但是实际用到的不止这么少，所以在使用某个钩子前，都会调用这个方法保证钩子已经定义。这里创建的钩子都是AsyncSeriesBailHook类型，异步，串行执行，获取第一个返回值不为空的结果。<br>如果name的前缀带有before或after，则会调整调用优先级<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ensureHook(name) &#123;</span><br><span class="line">    // ...</span><br><span class="line">    const hook = this.hooks[name];</span><br><span class="line">    if (!hook) &#123;</span><br><span class="line">        return this.hooks[name] =</span><br><span class="line">            new AsyncSeriesBailHook([&quot;request&quot;, &quot;resolveContext&quot;])</span><br><span class="line">    &#125;</span><br><span class="line">    return hook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>例如有两个插件挂在一个钩子上，此时调用钩子hook.callAsync时，因为优先级高会先进入plugin-a的回调，如果返回值是空继续执行after-plugin-a的回调，否则直接执行hook.callAsync的回调：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">this.ensureHook(&apos;myhook&apos;).tapAsync(&apos;after-plugin-a&apos;,() =&gt; &#123;&#125;)</span><br><span class="line">this.ensureHook(&apos;myhook&apos;).tapAsync(&apos;plugin-a&apos;,(request, resolveContext, callback) =&gt; &#123;</span><br><span class="line">    callback(null, &apos;ok from plugin-a&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">this.hooks.myhook.callAsync(request, resolveContext, (err, result) =&gt; &#123;</span><br><span class="line">    console.log(result) // ok from plugin-a</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="doResolve"><a href="#doResolve" class="headerlink" title="doResolve()"></a>doResolve()</h4><p>这个函数是两个插件的链接点，核心很简单就是直接调用钩子执行下一个流程而已，源码中还有一大堆代码主要是用来记录日志。<br>hook.callAsync负责真正的调用，会开始执行挂在这个钩子上的事件。在钩子里又会调用doResolve执行下一个钩子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">doResolve(hook, request, message, resolveContext, callback) &#123;</span><br><span class="line">    // ...</span><br><span class="line">    return hook.callAsync(request, innerContext, (err, result) =&gt; &#123;</span><br><span class="line">        if (err) return callback(err);</span><br><span class="line">        if (result) return callback(null, result);</span><br><span class="line">        callback();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="XXXPlugin"><a href="#XXXPlugin" class="headerlink" title="XXXPlugin"></a>XXXPlugin</h3><p>在创建插件时一般会传入source和target两个参数：</p><ul><li>source：插件拿到Resolver.hooks[‘source’]钩子，并调tap或tapAsync添加处理函数事件。当解析器接收到了source事件时，会执行注册的处理函数；</li><li>target：在处理完毕后，调用doResolve触发一个target事件，交由下一个监听target事件的插件处理。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class ParsePlugin &#123;</span><br><span class="line">constructor(source, target) &#123;</span><br><span class="line">this.source = source;</span><br><span class="line">this.target = target;</span><br><span class="line">&#125;</span><br><span class="line">apply(resolver) &#123;</span><br><span class="line">const target = resolver.ensureHook(this.target);</span><br><span class="line">resolver.getHook(this.source)</span><br><span class="line">.tapAsync(&quot;ParsePlugin&quot;, (request, resolveContext, callback) =&gt; &#123;</span><br><span class="line">                // ...</span><br><span class="line">resolver.doResolve(target, obj, null, resolveContext, callback);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>有了注册事件tapAsync和触发事件doResolve，各个插件就可以像积木一样链接起来</p><h2 id="实战举例"><a href="#实战举例" class="headerlink" title="实战举例"></a>实战举例</h2><p>我们通过分析一个解析目录是否存在的流程，来将上面内容串起来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// index.js</span><br><span class="line">resolve.context(__dirname, &apos;./&apos;, (err, p, result) =&gt; &#123;</span><br><span class="line">    // p = /Users/enhanced-resolve</span><br><span class="line">    console.log(err, p, result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>打印出来的调试结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resolve &apos;./&apos; in &apos;/Users/enhanced-resolve&apos;  </span><br><span class="line">Parsed request is a directory  </span><br><span class="line">using description file: /Users/enhanced-resolve/package.json (relative path: .)  </span><br><span class="line">using description file: /Users/enhanced-resolve/package.json (relative path: .)  </span><br><span class="line">as directory  </span><br><span class="line">existing directory  </span><br><span class="line">reporting result /Users/enhanced-resolve</span><br></pre></td></tr></table></figure></p><p>根据配置一共注册了以下插件，下面我们逐个分析这里用到的插件，插件流转路径如图示：<br><img src="/images/engineering/webpack1.png"></p><h3 id="ParsePlugin"><a href="#ParsePlugin" class="headerlink" title="ParsePlugin"></a>ParsePlugin</h3><p>用于预解析查询参数供后续插件使用：</p><p>解析查询路径中的query参数，如require(‘./index?id=1’)，这是webpack特有的语法，见文档__resourceQuery;<br>判断查询路径是否是模块<br>判断查询路径是否是目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">parse(identifier) &#123;</span><br><span class="line">    const idxQuery = identifier.indexOf(&quot;?&quot;);</span><br><span class="line">    const part = &#123;</span><br><span class="line">        request: identifier.slice(0, idxQuery),</span><br><span class="line">        query: identifier.slice(idxQuery),</span><br><span class="line">        file: false</span><br><span class="line">    &#125;;</span><br><span class="line">    part.module = this.isModule(part.request);</span><br><span class="line">    part.directory = this.isDirectory(part.request);</span><br><span class="line">    return part;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="DescriptionFilePlugin"><a href="#DescriptionFilePlugin" class="headerlink" title="DescriptionFilePlugin"></a>DescriptionFilePlugin</h3><p>用于获取描述文件路径，会在directory下搜索是否有package.json文件，如果该目录没有，就去上一级目录下查找，并计算出相对与directory的路径，下面是简化版的伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function loadDescriptionFile(directory, callback) &#123;</span><br><span class="line">    const descriptionFiles = [&apos;package.json&apos;]</span><br><span class="line">    let json</span><br><span class="line">    let descriptionFilePath</span><br><span class="line">    for(let i = 0; i &lt; descriptionFiles.length; i++) &#123;</span><br><span class="line">        descriptionFilePath = path.join(directory, descriptionFiles[i])</span><br><span class="line">        if(json = fileSystem.readJson(descriptionFilePath)) break</span><br><span class="line">    &#125;</span><br><span class="line">    if(json === null) &#123;</span><br><span class="line">        directory = cdUp(directory)</span><br><span class="line">        if (!directory) &#123;</span><br><span class="line">            return callback(&apos;err&apos;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            loadDescriptionFile(directory, callback);</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    const relativePath = &quot;.&quot; + request.path.substr(result.directory.length).replace(/\\/g, &quot;/&quot;);</span><br><span class="line">    callback(null, &#123;</span><br><span class="line">        content: json,</span><br><span class="line">        directory: directory,</span><br><span class="line">        path: descriptionFilePath,</span><br><span class="line">        relativePath,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">function cdUp(directory) &#123;</span><br><span class="line">if (directory === &quot;/&quot;) return null;</span><br><span class="line">const i = directory.lastIndexOf(&quot;/&quot;),</span><br><span class="line">j = directory.lastIndexOf(&quot;\\&quot;);</span><br><span class="line">const p = i &lt; 0 ? j : j &lt; 0 ? i : i &lt; j ? j : i;</span><br><span class="line">if (p &lt; 0) return null;</span><br><span class="line">return directory.substr(0, p || 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="ModuleKindPlugin"><a href="#ModuleKindPlugin" class="headerlink" title="ModuleKindPlugin"></a>ModuleKindPlugin</h3><p>如果ParsePlugin解析出来是模块路径，就引导至raw-module钩子，否则往下继续执行JoinRequestPlugin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(request, resolveContext, callback) =&gt; &#123;</span><br><span class="line">    if (!request.module) return callback();</span><br><span class="line">    const obj = Object.assign(&#123;&#125;, request);</span><br><span class="line">    delete obj.module;</span><br><span class="line">    resolver.doResolve(target, obj, &quot;resolve as module&quot;, resolveContext, callback);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="JoinRequestPlugin"><a href="#JoinRequestPlugin" class="headerlink" title="JoinRequestPlugin"></a>JoinRequestPlugin</h3><p>这里将会输出两个路径供后续查找：</p><p>path：指要查找的文件完整路径<br>relativePath：指描述文件路径相对于待查找文件的路径</p><p>关键输入参数：</p><p>request.path：在哪个路径下查找<br>request.request：查找的文件<br>request.relativePath：描述文件路径相对于request.path的路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(request, resolveContext, callback) =&gt; &#123;</span><br><span class="line">    const obj = Object.assign(&#123;&#125;, request, &#123;</span><br><span class="line">        path: resolver.join(request.path, request.request),</span><br><span class="line">        relativePath: request.relativePath &amp;&amp;</span><br><span class="line">            resolver.join(request.relativePath, request.request),</span><br><span class="line">        request: undefined</span><br><span class="line">    &#125;);</span><br><span class="line">    resolver.doResolve(target, obj, null, resolveContext, callback);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="FileKindPlugin"><a href="#FileKindPlugin" class="headerlink" title="FileKindPlugin"></a>FileKindPlugin</h3><p>如果ParsePlugin解析出来是路径，就往下继续执行TryNextPlugin，否则就引导至described-relative钩子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(request, resolveContext, callback) =&gt; &#123;</span><br><span class="line">    if (request.directory) return callback();</span><br><span class="line">    const obj = Object.assign(&#123;&#125;, request);</span><br><span class="line">    delete obj.directory;</span><br><span class="line">    resolver.doResolve(target, obj, null, resolveContext, callback)</span><br></pre></td></tr></table></figure></p><h3 id="TryNextPlugin"><a href="#TryNextPlugin" class="headerlink" title="TryNextPlugin"></a>TryNextPlugin</h3><p>直接引导到执行下一个插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(request, resolveContext, callback) =&gt; &#123;</span><br><span class="line">    resolver.doResolve(target, obj, message, resolveContext, callback)</span><br></pre></td></tr></table></figure></p><h3 id="DirectoryExistsPlugin"><a href="#DirectoryExistsPlugin" class="headerlink" title="DirectoryExistsPlugin"></a>DirectoryExistsPlugin</h3><p>判断文件夹是否存在<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(request, resolveContext, callback) =&gt; &#123;</span><br><span class="line">    const fs = resolver.fileSystem;</span><br><span class="line">    const directory = request.path;</span><br><span class="line">    fs.stat(directory, (err, stat) =&gt; &#123;</span><br><span class="line">        if (err || !stat || !stat.isDirectory()) &#123;</span><br><span class="line">            return callback();</span><br><span class="line">        &#125;</span><br><span class="line">        resolver.doResolve(target, obj, &quot;existing directory&quot;, resolveContext, callback)</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p><h3 id="NextPlugin"><a href="#NextPlugin" class="headerlink" title="NextPlugin"></a>NextPlugin</h3><p>直接引导到执行下一个插件，和TryNextPlugin区别在于有没有携带message日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(request, resolveContext, callback) =&gt; &#123;</span><br><span class="line">    resolver.doResolve(target, obj, null, resolveContext, callback)</span><br></pre></td></tr></table></figure></p><h3 id="ResultPlugin"><a href="#ResultPlugin" class="headerlink" title="ResultPlugin"></a>ResultPlugin</h3><p>直接返回解析结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(request, resolverContext, callback) =&gt; &#123;</span><br><span class="line">    // ...</span><br><span class="line">    callback(null, request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;路径解析&quot;&gt;&lt;a href=&quot;#路径解析&quot; class=&quot;headerlink&quot; title=&quot;路径解析&quot;&gt;&lt;/a&gt;路径解析&lt;/h2&gt;&lt;p&gt;Webpack封装了一套解析库&lt;font color=&quot;red&quot;&gt;enhanced-resolve&lt;/font&gt;专门用于解析
      
    
    </summary>
    
      <category term="工程化建设" scheme="https://skhon.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%BB%BA%E8%AE%BE/"/>
    
    
      <category term="Engineering" scheme="https://skhon.github.io/tags/Engineering/"/>
    
  </entry>
  
  <entry>
    <title>【规范建设】为代码自动生成文档</title>
    <link href="https://skhon.github.io/2022/05/14/engineering/jsdoc/"/>
    <id>https://skhon.github.io/2022/05/14/engineering/jsdoc/</id>
    <published>2022-05-14T11:01:29.305Z</published>
    <updated>2022-05-14T11:59:22.060Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/jsdoc/jsdoc" target="_blank" rel="noopener">JSDoc</a> 是一个自动化生成 JavaScript 文档工具，它是利用对 JavaScript 函数的特定注释来编译成 HTML 文件的一个文档工具。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install jsdoc -g</span><br><span class="line">npm install jsdoc -save-dev</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>只要在 JavaScript  中写好注释，利用命令即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jsdoc a.js b.js ...</span><br></pre></td></tr></table></figure></p><p>复制代码当然我们也可以在项目下定义 jsdoc.json 配置文件，通过 -c 参数来指定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jsdoc -c jsdoc.json</span><br></pre></td></tr></table></figure></p><p>复制代码可以在 package.json 中的 scripts 添加命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;docs&quot;: &quot;jsdoc -c jsdoc.json&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>复制代码这样我们就可以通过在项目下执行 npm run docs 命令来生成文档了。</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>常用的配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;source&quot;: &#123;</span><br><span class="line">    &quot;include&quot;: [ &quot;src/&quot; ],</span><br><span class="line">    &quot;exclude&quot;: [ &quot;src/libs&quot; ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;opts&quot;: &#123;</span><br><span class="line">    &quot;template&quot;: &quot;templates/default&quot;,</span><br><span class="line">    &quot;encoding&quot;: &quot;utf8&quot;,</span><br><span class="line">    &quot;destination&quot;: &quot;./docs/&quot;,</span><br><span class="line">    &quot;recurse&quot;: true,</span><br><span class="line">    &quot;verbose&quot;: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><font color="red">source</font> 表示传递给 JSDOC 的文件</li><li><font color="red">source.include</font> 表示 JSDOC 需要扫描哪些文件</li><li><font color="red">source.exclude</font> 表示 JSDOC 需要排除哪些文件</li><li><font color="red">opts</font> 表示传递给 JSDOC 的选项</li><li><font color="red">opts.template</font> 生成文档的模板，默认是 templates/default</li><li><font color="red">opts.encoding</font> 读取文件的编码，默认是 utf8</li><li><font color="red">opts.destination</font> 生成文档的路径，默认是 ./out/</li><li><font color="red">opts.recurse</font> 运行时是否递归子目录</li><li><font color="red">opts.verbose</font> 运行时是否输出详细信息，默认是 false</li></ul><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @author Mondo</span><br><span class="line">* @description list 数据结构 转换成 树结构</span><br><span class="line">* @param &#123;Array&#125; data 需要转换的数据</span><br><span class="line">* @param &#123;String&#125; id 节点 id</span><br><span class="line">* @param &#123;String&#125; pid 父级节点 id</span><br><span class="line">* @param &#123;String&#125; child 子树为节点对象的某个属性值</span><br><span class="line">* @param &#123;Object&#125; labels 需要新增的字段名集合 &#123; label: &apos;category_name&apos; &#125;</span><br><span class="line">* @return &#123;Array&#125;</span><br><span class="line">*</span><br><span class="line">* @example</span><br><span class="line">* formatListToTree(&#123;data: [&#123;id:1&#125;, &#123;id: 2&#125;, &#123;id: 3, pid: 1&#125;]&#125;)</span><br><span class="line">* =&gt;</span><br><span class="line">* [ &#123; id: 1, children: [ &#123;id: 3, pid: 1&#125; ] &#125;, &#123; id: 2 &#125; ]</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>常见的 JavaScript 块级注释，必须以 /** 开头，不然会被忽略掉。<br>下面介绍一些常见的级块标签：</p><ul><li><font color="red">@author</font> 该类/方法的作者。</li><li><font color="red">@class</font>  表示这是一个类。</li><li><font color="red">@function/@method</font>  表示这是一个函数/方法(这是同义词)。</li><li><font color="red">@private</font> 表示该类/方法是私有的，JSDOC 不会为其生成文档。</li><li><font color="red">@name</font> 该类/方法的名字。</li><li><font color="red">@description</font> 该类/方法的描述。</li><li><font color="red">@param</font> 该类/方法的参数，可重复定义。</li><li><font color="red">@return</font> 该类/方法的返回类型。</li><li><font color="red">@link</font> 创建超链接，生成文档时可以为其链接到其他部分。</li><li><font color="red">@example</font> 创建例子。</li></ul><p>这里是所有的<a href="https://jsdoc.app/" target="_blank" rel="noopener">Block Tags</a></p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>JSDoc 默认的主题可能不近如人意，不过大型交友网站上给我们提供了还不错的主题，只要我们对应 install 下来配置就行。推荐两款还不错的主题：</p><ul><li>docdash</li><li>minami</li></ul><p>使用方式为：</p><ol><li><p>安装依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install docdash --save-dev</span><br></pre></td></tr></table></figure></li><li><p>配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;templates&quot;: &#123;</span><br><span class="line">    &quot;cleverLinks&quot;: true,</span><br><span class="line">    &quot;default&quot;: &#123;</span><br><span class="line">      &quot;layoutFile&quot;: &quot;node_modules/docdash&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="/images/engineering/jsdoc.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/jsdoc/jsdoc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JSDoc&lt;/a&gt; 是一个自动化生成 JavaScript 文档工具，它是利用对 JavaScript 函数的特定注释来编译成 H
      
    
    </summary>
    
      <category term="工程化建设" scheme="https://skhon.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%BB%BA%E8%AE%BE/"/>
    
    
      <category term="Engineering" scheme="https://skhon.github.io/tags/Engineering/"/>
    
  </entry>
  
  <entry>
    <title>【规范建设】如何搭建一个文档站点</title>
    <link href="https://skhon.github.io/2022/03/03/engineering/documentation/"/>
    <id>https://skhon.github.io/2022/03/03/engineering/documentation/</id>
    <published>2022-03-03T09:04:51.792Z</published>
    <updated>2022-05-14T11:59:05.780Z</updated>
    
    <content type="html"><![CDATA[<p>关于搭建一个好的文档站点，对于我们平时开发的项目、框架了都能有一个好的说明，方便用户使用。这里收集一下，方便后续查询使用。</p><h2 id="Docusaurus"><a href="#Docusaurus" class="headerlink" title="Docusaurus"></a>Docusaurus</h2><p>比较好用的一个工具<a href="https://docusaurus.io/" target="_blank" rel="noopener">Docusaurus</a>。里面有一些好用的 <a href="https://docusaurus.io/showcase" target="_blank" rel="noopener">模板</a></p><h2 id="vuepress"><a href="#vuepress" class="headerlink" title="vuepress"></a>vuepress</h2><p>还有一个好用的<a href="https://vuepress.vuejs.org/zh/" target="_blank" rel="noopener">vuepress</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于搭建一个好的文档站点，对于我们平时开发的项目、框架了都能有一个好的说明，方便用户使用。这里收集一下，方便后续查询使用。&lt;/p&gt;
&lt;h2 id=&quot;Docusaurus&quot;&gt;&lt;a href=&quot;#Docusaurus&quot; class=&quot;headerlink&quot; title=&quot;Doc
      
    
    </summary>
    
      <category term="工程化建设" scheme="https://skhon.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%BB%BA%E8%AE%BE/"/>
    
    
      <category term="Engineering" scheme="https://skhon.github.io/tags/Engineering/"/>
    
  </entry>
  
  <entry>
    <title>【基础积累】typescript整理</title>
    <link href="https://skhon.github.io/2021/12/28/fe/typescript/"/>
    <id>https://skhon.github.io/2021/12/28/fe/typescript/</id>
    <published>2021-12-28T10:16:41.992Z</published>
    <updated>2022-05-14T12:00:36.132Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-ts-安装和编译"><a href="#1-ts-安装和编译" class="headerlink" title="1 ts 安装和编译"></a><strong>1</strong> <strong>ts</strong> <strong>安装和编译</strong></h3><ul><li>第一步 新建一个空文件夹用来学习 ts</li></ul><!----><ul><li>第二步 全局安装 ts 和 ts-node</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cnpm i typescript -g //全局安装ts</span><br><span class="line">cnpm i -g ts-node //全局安装ts-node</span><br></pre></td></tr></table></figure><ul><li>第三步 生成 tsconfig.js 配置文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --init</span><br></pre></td></tr></table></figure><p>我们就先按照自动生成的 tsconfig 配置项去使用 里面的配置咱们可以先不去管他 后续熟练了再去配置</p><ul><li>第四步 在项目下新建一个<code>index.ts</code>直接写入</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const a: string = &quot;hello&quot;;</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure><ul><li>第五步 编译 ts 为 js 在控制台（终端）输入命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc index.ts</span><br></pre></td></tr></table></figure><p>神奇的事情发生了 项目下出现了一个同名的 index.js 文件 至此我们已经可以把 ts 文件编译成 js 文件了</p><p>不过到这里聪明的小伙伴就会发现了 我们全局安装的 「ts-node」 有什么作用呢 其实这个包是帮助我们在不需要编译成 js 的前提下就可以直接执行 ts 代码 比如 我们在控制台输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ts-node index.ts</span><br></pre></td></tr></table></figure><p>可以看到我们打印的<code>hello</code>已经输出了</p><p>那可能 还有的小伙伴会发现 我们每次改动都要手动去执行编译 这样很麻烦 其实我们可以加一个参数来实现每次文件变动 ts 帮我们「自动编译成 js」 的效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --watch index.ts</span><br></pre></td></tr></table></figure><p>好了 环境安装完毕了 接下来出发去学习 ts 核心吧</p><h3 id="2-TS-类型"><a href="#2-TS-类型" class="headerlink" title="2 TS 类型"></a><strong>2</strong> <strong>TS</strong> <strong>类型</strong></h3><h5 id="2-1-布尔类型-boolean"><a href="#2-1-布尔类型-boolean" class="headerlink" title="2.1 布尔类型(boolean)"></a><strong>2.1 布尔类型(boolean)</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const flag: boolean = true;</span><br></pre></td></tr></table></figure><h5 id="2-2-Number-类型"><a href="#2-2-Number-类型" class="headerlink" title="2.2 Number 类型"></a><strong>2.2 Number 类型</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const flag: number = 1;</span><br></pre></td></tr></table></figure><h5 id="2-3-String-类型"><a href="#2-3-String-类型" class="headerlink" title="2.3 String 类型"></a><strong>2.3 String 类型</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const flag: string = &quot;hello&quot;;</span><br></pre></td></tr></table></figure><h5 id="2-4-Enum-类型"><a href="#2-4-Enum-类型" class="headerlink" title="2.4 Enum 类型"></a><strong>2.4</strong> <strong>Enum</strong> <strong>类型</strong></h5><p>使用枚举我们可以很好的描述一些特定的业务场景，比如一年中的春、夏、秋、冬，还有每周的周一到周天，还有各种颜色，以及可以用它来描述一些状态信息，比如错误码等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> // 普通枚举 初始值默认为 0 其余的成员会会按顺序自动增长 可以理解为数组下标</span><br><span class="line">enum Color &#123;</span><br><span class="line">  RED,</span><br><span class="line">  PINK,</span><br><span class="line">  BLUE,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const pink: Color = Color.PINK;</span><br><span class="line">console.log(pink); // 1</span><br><span class="line"></span><br><span class="line">// 设置初始值</span><br><span class="line">enum Color &#123;</span><br><span class="line">  RED = 10,</span><br><span class="line">  PINK,</span><br><span class="line">  BLUE,</span><br><span class="line">&#125;</span><br><span class="line">const pink: Color = Color.PINK;</span><br><span class="line">console.log(pink); // 11</span><br><span class="line"></span><br><span class="line">// 字符串枚举 每个都需要声明</span><br><span class="line">enum Color &#123;</span><br><span class="line">  RED = &quot;红色&quot;,</span><br><span class="line">  PINK = &quot;粉色&quot;,</span><br><span class="line">  BLUE = &quot;蓝色&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const pink: Color = Color.PINK;</span><br><span class="line">console.log(pink); // 粉色</span><br><span class="line"></span><br><span class="line">// 常量枚举 它是使用 const 关键字修饰的枚举，常量枚举与普通枚举的区别是，整个枚举会在编译阶段被删除 我们可以看下编译之后的效果</span><br><span class="line"></span><br><span class="line">const enum Color &#123;</span><br><span class="line">  RED,</span><br><span class="line">  PINK,</span><br><span class="line">  BLUE,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const color: Color[] = [Color.RED, Color.PINK, Color.BLUE];</span><br><span class="line"></span><br><span class="line">//编译之后的js如下：</span><br><span class="line">var color = [0 /* RED */ , 1 /* PINK */ , 2 /* BLUE */ ];</span><br><span class="line">// 可以看到我们的枚举并没有被编译成js代码 只是把color这个数组变量编译出来了</span><br></pre></td></tr></table></figure><h5 id="2-5-数组类型-array"><a href="#2-5-数组类型-array" class="headerlink" title="2.5 数组类型(array)"></a><strong>2.5 数组类型(array)</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const flag1: number[] = [1, 2, 3];</span><br><span class="line">const flag2: Array&lt;number&gt; = [1, 2, 3];</span><br></pre></td></tr></table></figure><h5 id="2-6-元组类型-tuple"><a href="#2-6-元组类型-tuple" class="headerlink" title="2.6 元组类型(tuple)"></a><strong>2.6 元组类型(tuple)</strong></h5><p>在 TypeScript 的基础类型中，元组（ Tuple ）表示一个已知「数量」和「类型」的数组 其实可以理解为他是一种特殊的数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const flag: [string, number] = [&quot;hello&quot;, 1];</span><br></pre></td></tr></table></figure><h5 id="2-7-Symbol"><a href="#2-7-Symbol" class="headerlink" title="2.7 Symbol"></a><strong>2.7 Symbol</strong></h5><p>我们在使用 Symbol 的时候，必须添加 es6 的编译辅助库 需要在 tsconfig.json 的 <code>libs</code> 字段加上<code>ES`</code>2015`Symbol 的值是唯一不变的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const sym1 = Symbol(&quot;hello&quot;);</span><br><span class="line">const sym2 = Symbol(&quot;hello&quot;);</span><br><span class="line">console.log(Symbol(&quot;hello&quot;) === Symbol(&quot;hello&quot;));</span><br></pre></td></tr></table></figure><h5 id="2-8-任意类型-any"><a href="#2-8-任意类型-any" class="headerlink" title="2.8 任意类型(any)"></a><strong>2.8 任意类型(any)</strong></h5><p>任何类型都可以被归为 <code>any</code> 类型 这让 <code>any</code> 类型成为了类型系统的 顶级类型 (也被称作 全局超级类型) TypeScript 允许我们对 <code>any</code> 类型的值执行任何操作 而无需事先执行任何形式的检查</p><p>一般使用场景：第三方库没有提供类型文件时可以使用 <code>any</code>类型转换遇到困难或者数据结构太复杂难以定义 不过不要太依赖 <code>any</code> 否则就失去了 ts 的意义了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const flag: any = document.getElementById(&quot;root&quot;);</span><br></pre></td></tr></table></figure><h5 id="2-9-null-和-undefined"><a href="#2-9-null-和-undefined" class="headerlink" title="2.9 null 和 undefined"></a><strong>2.9 null 和 undefined</strong></h5><p><code>undefined</code> 和 <code>null</code> 两者有各自的类型分别为 <code>undefined</code> 和 <code>null</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let u: undefined = undefined;</span><br><span class="line">let n: null = null;</span><br></pre></td></tr></table></figure><h5 id="2-10-Unknown-类型"><a href="#2-10-Unknown-类型" class="headerlink" title="2.10 Unknown 类型"></a><strong>2.10 Unknown 类型</strong></h5><p><code>unknown</code> 和 <code>any</code> 的主要区别是 <code>unknown</code> 类型会更加严格 在对 <code>unknown</code> 类型的值执行大多数操作之前 我们必须进行某种形式的检查 而在对 <code>any</code> 类型的值执行操作之前 我们不必进行任何检查 所有类型都可以被归为 <code>unknown</code> 但<code>unknown</code>类型只能被赋值给 <code>any</code> 类型和 <code>unknown</code> 类型本身 而 <code>any</code> 啥都能分配和被分配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let value: unknown;</span><br><span class="line"></span><br><span class="line">value = true; // OK</span><br><span class="line">value = 42; // OK</span><br><span class="line">value = &quot;Hello World&quot;; // OK</span><br><span class="line">value = []; // OK</span><br><span class="line">value = &#123;&#125;; // OK</span><br><span class="line"></span><br><span class="line">let value1: unknown = value; // OK</span><br><span class="line">let value2: any = value; // OK</span><br><span class="line">let value3: boolean = value; // Error</span><br><span class="line">let value4: number = value; // Error</span><br><span class="line">let value5: string = value; // Error</span><br><span class="line">let value6: object = value; // Error</span><br></pre></td></tr></table></figure><h5 id="2-11-void-类型"><a href="#2-11-void-类型" class="headerlink" title="2.11 void 类型"></a><strong>2.11 void 类型</strong></h5><p><code>void</code> 表示没有任何类型 当一个函数没有返回值时 TS 会认为它的返回值是 <code>void</code> 类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function hello(name: string): void &#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="2-12-never-类型"><a href="#2-12-never-类型" class="headerlink" title="2.12 never 类型"></a><strong>2.12 never 类型</strong></h5><p><code>never</code> 一般表示用户无法达到的类型 例如<code>never</code> 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function neverReach(): never &#123;</span><br><span class="line">  throw new Error(&quot;an error&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>❝</strong></p></blockquote><blockquote><p>思考:never 和 void 的区别 void 可以被赋值为 null 和 undefined 的类型。never 则是一个不包含值的类型。拥有 void 返回值类型的函数能正常运行。拥有 never 返回值类型的函数无法正常返回，无法终止，或会抛出异常。</p></blockquote><blockquote><p>❞</p></blockquote><h5 id="2-13-BigInt-大数类型"><a href="#2-13-BigInt-大数类型" class="headerlink" title="2.13 BigInt 大数类型"></a><strong>2.13 BigInt 大数类型</strong></h5><p>使用 <code>BigInt</code> 可以安全地存储和操作大整数 我们在使用 <code>BigInt</code> 的时候 必须添加 <code>ESNext</code> 的编译辅助库 需要在 tsconfig.json 的 <code>libs</code> 字段加上<code>ESNext</code>要使用<code>1n</code>需要 <code>&quot;target&quot;: &quot;ESNext&quot;number</code> 和 <code>BigInt</code> 类型不一样 不兼容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const max1 = Number.MAX_SAFE_INTEGER; // 2**53-1</span><br><span class="line">console.log(max1 + 1 === max1 + 2); //true</span><br><span class="line"></span><br><span class="line">const max2 = BigInt(Number.MAX_SAFE_INTEGER);</span><br><span class="line">console.log(max2 + 1n === max2 + 2n); //false</span><br><span class="line"></span><br><span class="line">let foo: number;</span><br><span class="line">let bar: bigint;</span><br><span class="line">foo = bar; //error</span><br><span class="line">bar = foo; //error</span><br></pre></td></tr></table></figure><h5 id="2-14-object-Object-和-类型"><a href="#2-14-object-Object-和-类型" class="headerlink" title="2.14 object, Object 和 {} 类型"></a><strong>2.14 object, Object 和 {} 类型</strong></h5><p>「object」 类型用于表示非原始类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let objectCase: object;</span><br><span class="line">objectCase = 1; // error</span><br><span class="line">objectCase = &quot;a&quot;; // error</span><br><span class="line">objectCase = true; // error</span><br><span class="line">objectCase = null; // error</span><br><span class="line">objectCase = undefined; // error</span><br><span class="line">objectCase = &#123;&#125;; // ok</span><br></pre></td></tr></table></figure><p>「大 Object」 代表所有拥有 toString、hasOwnProperty 方法的类型 所以所有原始类型、非原始类型都可以赋给 Object(严格模式下 <code>null</code> 和 <code>undefined</code> 不可以)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let ObjectCase: Object;</span><br><span class="line">ObjectCase = 1; // ok</span><br><span class="line">ObjectCase = &quot;a&quot;; // ok</span><br><span class="line">ObjectCase = true; // ok</span><br><span class="line">ObjectCase = null; // error</span><br><span class="line">ObjectCase = undefined; // error</span><br><span class="line">ObjectCase = &#123;&#125;; // ok</span><br></pre></td></tr></table></figure><p>「{}」 空对象类型和大 Object 一样 也是表示原始类型和非原始类型的集合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let simpleCase: &#123;&#125;;</span><br><span class="line">simpleCase = 1; // ok</span><br><span class="line">simpleCase = &quot;a&quot;; // ok</span><br><span class="line">simpleCase = true; // ok</span><br><span class="line">simpleCase = null; // error</span><br><span class="line">simpleCase = undefined; // error</span><br><span class="line">simpleCase = &#123;&#125;; // ok</span><br></pre></td></tr></table></figure><h5 id="2-15-类型推论"><a href="#2-15-类型推论" class="headerlink" title="2.15 类型推论"></a><strong>2.15 类型推论</strong></h5><p>指编程语言中能够自动推导出值的类型的能力 它是一些强静态类型语言中出现的特性 定义时未赋值就会推论成 <code>any</code> 类型 如果定义的时候就赋值就能利用到类型推论</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let flag; //推断为any</span><br><span class="line">let count = 123; //为number类型</span><br><span class="line">let hello = &quot;hello&quot;; //为string类型</span><br></pre></td></tr></table></figure><h5 id="2-16-联合类型"><a href="#2-16-联合类型" class="headerlink" title="2.16 联合类型"></a><strong>2.16 联合类型</strong></h5><p>联合类型（Union Types）表示取值可以为多种类型中的一种 未赋值时联合类型上只能访问两个类型共有的属性和方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let name: string | number;</span><br><span class="line">console.log(name.toString());</span><br><span class="line">name = 1;</span><br><span class="line">console.log(name.toFixed(2));</span><br><span class="line">name = &quot;hello&quot;;</span><br><span class="line">console.log(name.length);</span><br></pre></td></tr></table></figure><h5 id="2-17-类型断言"><a href="#2-17-类型断言" class="headerlink" title="2.17 类型断言"></a><strong>2.17 类型断言</strong></h5><p>有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。其实就是你需要手动告诉 ts 就按照你断言的那个类型通过编译（这一招很关键 有时候可以帮助你解决很多编译报错）</p><p>类型断言有两种形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> // 尖括号 语法</span><br><span class="line">let someValue: any = &quot;this is a string&quot;;</span><br><span class="line">let strLength: number = (&lt;string&gt;someValue).length;</span><br><span class="line"></span><br><span class="line">// as 语法</span><br><span class="line">let someValue: any = &quot;this is a string&quot;;</span><br><span class="line">let strLength: number = (someValue as string).length;</span><br></pre></td></tr></table></figure><blockquote><p><strong>❝</strong></p></blockquote><blockquote><p>以上两种方式虽然没有任何区别，但是尖括号格式会与 react 中 JSX 产生语法冲突，因此我们更推荐使用 as 语法。</p></blockquote><blockquote><p>❞</p></blockquote><p>「非空断言」在上下文中当类型检查器无法断定类型时 一个新的后缀表达式操作符 ! 可以用于断言操作对象是非 <code>null</code> 和非 <code>undefined</code> 类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let flag: null | undefined | string;</span><br><span class="line">flag!.toString(); // ok</span><br><span class="line">flag.toString(); // error</span><br></pre></td></tr></table></figure><h5 id="2-18-字面量类型"><a href="#2-18-字面量类型" class="headerlink" title="2.18 字面量类型"></a><strong>2.18 字面量类型</strong></h5><p>在 TypeScript 中，字面量不仅可以表示值，还可以表示类型，即所谓的字面量类型。目前，TypeScript 支持 3 种字面量类型：字符串字面量类型、数字字面量类型、布尔字面量类型，对应的字符串字面量、数字字面量、布尔字面量分别拥有与其值一样的字面量类型，具体示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let flag1: &quot;hello&quot; = &quot;hello&quot;;</span><br><span class="line">let flag2: 1 = 1;</span><br><span class="line">let flag3: true = true;</span><br></pre></td></tr></table></figure><h5 id="2-19-类型别名"><a href="#2-19-类型别名" class="headerlink" title="2.19 类型别名"></a><strong>2.19 类型别名</strong></h5><p>类型别名用来给一个类型起个新名字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type flag = string | number;</span><br><span class="line"></span><br><span class="line">function hello(value: flag) &#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="2-20-交叉类型"><a href="#2-20-交叉类型" class="headerlink" title="2.20 交叉类型"></a><strong>2.20 交叉类型</strong></h5><p>交叉类型是将多个类型合并为一个类型。通过 &amp; 运算符可以将现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type Flag1 = &#123; x: number &#125;;</span><br><span class="line">type Flag2 = Flag1 &amp; &#123; y: string &#125;;</span><br><span class="line"></span><br><span class="line">let flag3: Flag2 = &#123;</span><br><span class="line">  x: 1,</span><br><span class="line">  y: &quot;hello&quot;,</span><br><span class="line">  henb,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="2-21-类型保护"><a href="#2-21-类型保护" class="headerlink" title="2.21 类型保护"></a><strong>2.21 类型保护</strong></h5><p>类型保护就是一些表达式，他们在编译的时候就能通过类型信息确保某个作用域内变量的类型 其主要思想是尝试检测属性、方法或原型，以确定如何处理值</p><p>「typeof 类型保护」</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function double(input: string | number | boolean) &#123;</span><br><span class="line">  if (typeof input === &quot;string&quot;) &#123;</span><br><span class="line">    return input + input;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if (typeof input === &quot;number&quot;) &#123;</span><br><span class="line">      return input * 2;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return !input;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>「in 关键字」</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface Bird &#123;</span><br><span class="line">  fly: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Dog &#123;</span><br><span class="line">  leg: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getNumber(value: Bird | Dog) &#123;</span><br><span class="line">  if (&quot;fly&quot; in value) &#123;</span><br><span class="line">    return value.fly;</span><br><span class="line">  &#125;</span><br><span class="line">  return value.leg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>「instanceof 类型保护」</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  name!: string;</span><br><span class="line">&#125;</span><br><span class="line">class Bird extends Animal &#123;</span><br><span class="line">  fly!: number;</span><br><span class="line">&#125;</span><br><span class="line">function getName(animal: Animal) &#123;</span><br><span class="line">  if (animal instanceof Bird) &#123;</span><br><span class="line">    console.log(animal.fly);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(animal.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>「自定义类型保护」</p><p>通过 <code>type is xxx</code>这样的类型谓词来进行类型保护</p><p>例如下面的例子 <code>value is object</code>就会认为如果函数返回 true 那么定义的 value 就是 object 类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function isObject(value: unknown): value is object &#123;</span><br><span class="line">  return typeof value === &quot;object&quot; &amp;&amp; value !== null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn(x: string | object) &#123;</span><br><span class="line">  if (isObject(x)) &#123;</span><br><span class="line">    // ....</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // .....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-函数"><a href="#3-函数" class="headerlink" title="3 函数"></a><strong>3 函数</strong></h3><h5 id="3-1-函数的定义"><a href="#3-1-函数的定义" class="headerlink" title="3.1 函数的定义"></a><strong>3.1 函数的定义</strong></h5><p>可以指定参数的类型和返回值的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function hello(name: string): void &#123;</span><br><span class="line">  console.log(&quot;hello&quot;, name);</span><br><span class="line">&#125;</span><br><span class="line">hello(&quot;hahaha&quot;);</span><br></pre></td></tr></table></figure><h5 id="3-2-函数表达式"><a href="#3-2-函数表达式" class="headerlink" title="3.2 函数表达式"></a><strong>3.2 函数表达式</strong></h5><p>定义函数类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type SumFunc = (x: number, y: number) =&gt; number;</span><br><span class="line"></span><br><span class="line">let countNumber: SumFunc = function (a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="3-3-可选参数"><a href="#3-3-可选参数" class="headerlink" title="3.3 可选参数"></a><strong>3.3 可选参数</strong></h5><p>在 TS 中函数的形参和实参必须一样，不一样就要配置可选参数,而且必须是「最后一个参数」</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function print(name: string, age?: number): void &#123;</span><br><span class="line">  console.log(name, age);</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;hahaha&quot;);</span><br></pre></td></tr></table></figure><h5 id="3-4-默认参数"><a href="#3-4-默认参数" class="headerlink" title="3.4 默认参数"></a><strong>3.4 默认参数</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function ajax(url: string, method: string = &quot;GET&quot;) &#123;</span><br><span class="line">  console.log(url, method);</span><br><span class="line">&#125;</span><br><span class="line">ajax(&quot;/users&quot;);</span><br></pre></td></tr></table></figure><h5 id="3-5-剩余参数"><a href="#3-5-剩余参数" class="headerlink" title="3.5 剩余参数"></a><strong>3.5 剩余参数</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function sum(...numbers: number[]) &#123;</span><br><span class="line">  return numbers.reduce((val, item) =&gt; (val += item), 0);</span><br><span class="line">&#125;</span><br><span class="line">console.log(sum(1, 2, 3));</span><br></pre></td></tr></table></figure><h5 id="3-6-函数重载"><a href="#3-6-函数重载" class="headerlink" title="3.6 函数重载"></a><strong>3.6 函数重载</strong></h5><p>函数重载或方法重载是使用相同名称和不同参数数量或类型创建多个方法的一种能力。在 TypeScript 中，表现为给同一个函数提供多个函数类型定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let obj: any = &#123;&#125;;</span><br><span class="line">function attr(val: string): void;</span><br><span class="line">function attr(val: number): void;</span><br><span class="line">function attr(val: any): void &#123;</span><br><span class="line">  if (typeof val === &quot;string&quot;) &#123;</span><br><span class="line">    obj.name = val;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    obj.age = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">attr(&quot;hahaha&quot;);</span><br><span class="line">attr(9);</span><br><span class="line">attr(true);</span><br><span class="line">console.log(obj);</span><br></pre></td></tr></table></figure><blockquote><p><strong>❝</strong></p></blockquote><blockquote><p>注意：函数重载真正执行的是同名函数最后定义的函数体 在最后一个函数体定义之前全都属于函数类型定义 不能写具体的函数实现方法 只能定义类型</p></blockquote><blockquote><p>❞</p></blockquote><h3 id="4-类"><a href="#4-类" class="headerlink" title="4 类"></a><strong>4 类</strong></h3><h5 id="4-1-类的定义"><a href="#4-1-类的定义" class="headerlink" title="4.1 类的定义"></a><strong>4.1 类的定义</strong></h5><p>在 TypeScript 中，我们可以通过 <code>Class</code> 关键字来定义一个类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  name!: string; //如果初始属性没赋值就需要加上!</span><br><span class="line">  constructor(_name: string) &#123;</span><br><span class="line">    this.name = _name;</span><br><span class="line">  &#125;</span><br><span class="line">  getName(): void &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p1 = new Person(&quot;hello&quot;);</span><br><span class="line">p1.getName();</span><br></pre></td></tr></table></figure><p>当然 如果我们图省事 我们也可以把属性定义直接写到构造函数的参数里面去(不过一般不建议这样写 因为会让代码增加阅读难度)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  constructor(public name: string) &#123;&#125;</span><br><span class="line">  getName(): void &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p1 = new Person(&quot;hello&quot;);</span><br><span class="line">p1.getName();</span><br></pre></td></tr></table></figure><blockquote><p><strong>❝</strong></p></blockquote><blockquote><p>注意：当我们定义一个类的时候,会得到 「2 个类型」一个是构造函数类型的函数类型(当做普通构造函数的类型) 另一个是类的实例类型（代表实例）</p></blockquote><blockquote><p>❞</p></blockquote><p>具体看例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Component &#123;</span><br><span class="line">  static myName: string = &quot;静态名称属性&quot;;</span><br><span class="line">  myName: string = &quot;实例名称属性&quot;;</span><br><span class="line">&#125;</span><br><span class="line">//ts 一个类型 一个叫值</span><br><span class="line">//放在=后面的是值</span><br><span class="line">let com = Component; //这里是代表构造函数</span><br><span class="line">//冒号后面的是类型</span><br><span class="line">let c: Component = new Component(); //这里是代表实例类型</span><br><span class="line">let f: typeof Component = com;</span><br></pre></td></tr></table></figure><h5 id="4-2-存取器"><a href="#4-2-存取器" class="headerlink" title="4.2 存取器"></a><strong>4.2 存取器</strong></h5><p>在 TypeScript 中，我们可以通过存取器来改变一个类中属性的读取和赋值行为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  myname: string;</span><br><span class="line">  constructor(myname: string) &#123;</span><br><span class="line">    this.myname = myname;</span><br><span class="line">  &#125;</span><br><span class="line">  get name() &#123;</span><br><span class="line">    return this.myname;</span><br><span class="line">  &#125;</span><br><span class="line">  set name(value) &#123;</span><br><span class="line">    this.myname = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let user = new User(&quot;hello&quot;);</span><br><span class="line">user.name = &quot;world&quot;;</span><br><span class="line">console.log(user.name);</span><br></pre></td></tr></table></figure><p>其实我们可以看看翻译成 es5 的代码 原理很简单 就是使用了 Object.defineProperty 在类的原型上面拦截了属性对应的 get 和 set 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var User = /** @class */ (function () &#123;</span><br><span class="line">  function User(myname) &#123;</span><br><span class="line">    this.myname = myname;</span><br><span class="line">  &#125;</span><br><span class="line">  Object.defineProperty(User.prototype, &quot;name&quot;, &#123;</span><br><span class="line">    get: function () &#123;</span><br><span class="line">      return this.myname;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function (value) &#123;</span><br><span class="line">      this.myname = value;</span><br><span class="line">    &#125;,</span><br><span class="line">    enumerable: false,</span><br><span class="line">    configurable: true,</span><br><span class="line">  &#125;);</span><br><span class="line">  return User;</span><br><span class="line">&#125;)();</span><br><span class="line">var user = new User(&quot;hello&quot;);</span><br><span class="line">user.name = &quot;world&quot;;</span><br><span class="line">console.log(user.name);</span><br></pre></td></tr></table></figure><h5 id="4-3-readonly-只读属性"><a href="#4-3-readonly-只读属性" class="headerlink" title="4.3 readonly 只读属性"></a><strong>4.3 readonly 只读属性</strong></h5><p>readonly 修饰的变量只能在「构造函数」中初始化 TypeScript 的类型系统同样也允许将 interface、type、 class 上的属性标识为 readonly readonly 实际上只是在编译阶段进行代码检查。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  public readonly name: string;</span><br><span class="line">  constructor(name: string) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  changeName(name: string) &#123;</span><br><span class="line">    this.name = name; //这个ts是报错的</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = new Animal(&quot;hello&quot;);</span><br></pre></td></tr></table></figure><h5 id="4-4-继承"><a href="#4-4-继承" class="headerlink" title="4.4 继承"></a><strong>4.4 继承</strong></h5><p>子类继承父类后子类的实例就拥有了父类中的属性和方法，可以增强代码的可复用性</p><p>将子类公用的方法抽象出来放在父类中，自己的特殊逻辑放在子类中重写父类的逻辑</p><p>super 可以调用父类上的方法和属性</p><p>在 TypeScript 中，我们可以通过 extends 关键字来实现继承</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  name: string; //定义实例的属性，默认省略public修饰符</span><br><span class="line">  age: number;</span><br><span class="line">  constructor(name: string, age: number) &#123;</span><br><span class="line">    //构造函数</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  getName(): string &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">  setName(name: string): void &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Student extends Person &#123;</span><br><span class="line">  no: number;</span><br><span class="line">  constructor(name: string, age: number, no: number) &#123;</span><br><span class="line">    super(name, age);</span><br><span class="line">    this.no = no;</span><br><span class="line">  &#125;</span><br><span class="line">  getNo(): number &#123;</span><br><span class="line">    return this.no;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let s1 = new Student(&quot;hello&quot;, 10, 1);</span><br><span class="line">console.log(s1);</span><br></pre></td></tr></table></figure><h5 id="4-5-类里面的修饰符"><a href="#4-5-类里面的修饰符" class="headerlink" title="4.5 类里面的修饰符"></a><strong>4.5 类里面的修饰符</strong></h5><p>「public」 类里面 子类 其它任何地方外边都可以访问「protected」 类里面 子类 都可以访问,其它任何地方不能访问「private」 类里面可以访问，子类和其它任何地方都不可以访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123;</span><br><span class="line">  public name: string;</span><br><span class="line">  protected age: number;</span><br><span class="line">  private car: number;</span><br><span class="line">  constructor(name: string, age: number, car: number) &#123;</span><br><span class="line">    //构造函数</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.car = car;</span><br><span class="line">  &#125;</span><br><span class="line">  getName(): string &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">  setName(name: string): void &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">  constructor(name: string, age: number, car: number) &#123;</span><br><span class="line">    super(name, age, car);</span><br><span class="line">  &#125;</span><br><span class="line">  desc() &#123;</span><br><span class="line">    console.log(`$&#123;this.name&#125; $&#123;this.age&#125; $&#123;this.car&#125;`); //car访问不到 会报错</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let child = new Child(&quot;hello&quot;, 10, 1000);</span><br><span class="line">console.log(child.name);</span><br><span class="line">console.log(child.age); //age访问不到 会报错</span><br><span class="line">console.log(child.car); //car访问不到 会报错</span><br></pre></td></tr></table></figure><h5 id="4-6-静态属性-静态方法"><a href="#4-6-静态属性-静态方法" class="headerlink" title="4.6 静态属性 静态方法"></a><strong>4.6 静态属性 静态方法</strong></h5><p>类的静态属性和方法是直接定义在类本身上面的 所以也只能通过直接调用类的方法和属性来访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123;</span><br><span class="line">  static mainName = &quot;Parent&quot;;</span><br><span class="line">  static getmainName() &#123;</span><br><span class="line">    console.log(this); //注意静态方法里面的this指向的是类本身 而不是类的实例对象 所以静态方法里面只能访问类的静态属性和方法</span><br><span class="line">    return this.mainName;</span><br><span class="line">  &#125;</span><br><span class="line">  public name: string;</span><br><span class="line">  constructor(name: string) &#123;</span><br><span class="line">    //构造函数</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(Parent.mainName);</span><br><span class="line">console.log(Parent.getmainName());</span><br></pre></td></tr></table></figure><h5 id="4-7-抽象类和抽象方法"><a href="#4-7-抽象类和抽象方法" class="headerlink" title="4.7 抽象类和抽象方法"></a><strong>4.7 抽象类和抽象方法</strong></h5><p>抽象类，无法被实例化，只能被继承并且无法创建抽象类的实例 子类可以对抽象类进行不同的实现</p><p>抽象方法只能出现在抽象类中并且抽象方法不能在抽象类中被具体实现，只能在抽象类的子类中实现（必须要实现）</p><p>使用场景：我们一般用抽象类和抽象方法抽离出事物的共性 以后所有继承的子类必须按照规范去实现自己的具体逻辑 这样可以增加代码的可维护性和复用性</p><p>使用 <code>abstract</code> 关键字来定义抽象类和抽象方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">abstract class Animal &#123;</span><br><span class="line">  name!: string;</span><br><span class="line">  abstract speak(): void;</span><br><span class="line">&#125;</span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">  speak() &#123;</span><br><span class="line">    console.log(&quot;喵喵喵&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let animal = new Animal(); //直接报错 无法创建抽象类的实例</span><br><span class="line">let cat = new Cat();</span><br><span class="line">cat.speak();</span><br></pre></td></tr></table></figure><blockquote><p><strong>❝</strong></p></blockquote><blockquote><p>思考 1:重写(override)和重载(overload)的区别</p></blockquote><blockquote><p>❞</p></blockquote><p>「重写」是指子类重写继承自父类中的方法「重载」是指为同一个函数提供多个类型定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  speak(word: string): string &#123;</span><br><span class="line">    return &quot;动物:&quot; + word;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">  speak(word: string): string &#123;</span><br><span class="line">    return &quot;猫:&quot; + word;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let cat = new Cat();</span><br><span class="line">console.log(cat.speak(&quot;hello&quot;));</span><br><span class="line">// 上面是重写</span><br><span class="line">//--------------------------------------------</span><br><span class="line">// 下面是重载</span><br><span class="line">function double(val: number): number;</span><br><span class="line">function double(val: string): string;</span><br><span class="line">function double(val: any): any &#123;</span><br><span class="line">  if (typeof val == &quot;number&quot;) &#123;</span><br><span class="line">    return val * 2;</span><br><span class="line">  &#125;</span><br><span class="line">  return val + val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let r = double(1);</span><br><span class="line">console.log(r);</span><br></pre></td></tr></table></figure><blockquote><p><strong>❝</strong></p></blockquote><blockquote><p>思考 2:什么是「多态」</p></blockquote><blockquote><p>❞</p></blockquote><p>在父类中定义一个方法，在子类中有多个实现，在程序运行的时候，根据不同的对象执行不同的操作，实现运行时的绑定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">abstract class Animal &#123;</span><br><span class="line">  // 声明抽象的方法，让子类去实现</span><br><span class="line">  abstract sleep(): void;</span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">  sleep() &#123;</span><br><span class="line">    console.log(&quot;dog sleep&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let dog = new Dog();</span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">  sleep() &#123;</span><br><span class="line">    console.log(&quot;cat sleep&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let cat = new Cat();</span><br><span class="line">let animals: Animal[] = [dog, cat];</span><br><span class="line">animals.forEach((i) =&gt; &#123;</span><br><span class="line">  i.sleep();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="5-接口"><a href="#5-接口" class="headerlink" title="5 接口"></a><strong>5 接口</strong></h3><p>接口既可以在面向对象编程中表示为行为的抽象，也可以用来描述对象的形状</p><p>我们用 <code>interface</code> 关键字来定义接口 在接口中可以用分号或者逗号分割每一项，也可以什么都不加</p><h5 id="5-1-对象的形状"><a href="#5-1-对象的形状" class="headerlink" title="5.1 对象的形状"></a><strong>5.1 对象的形状</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> //接口可以用来描述`对象的形状`</span><br><span class="line">//接口可以用来描述`对象的形状`</span><br><span class="line">interface Speakable &#123;</span><br><span class="line">  speak(): void;</span><br><span class="line">  readonly lng: string; //readonly表示只读属性 后续不可以更改</span><br><span class="line">  name?: string; //？表示可选属性</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let speakman: Speakable = &#123;</span><br><span class="line">  //   speak() &#123;&#125;, //少属性会报错</span><br><span class="line">  name: &quot;hello&quot;,</span><br><span class="line">  lng: &quot;en&quot;,</span><br><span class="line">  age: 111, //多属性也会报错</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="5-2-行为的抽象"><a href="#5-2-行为的抽象" class="headerlink" title="5.2 行为的抽象"></a><strong>5.2 行为的抽象</strong></h5><p>接口可以把一些类中共有的属性和方法抽象出来,可以用来约束实现此接口的类</p><p>一个类可以实现多个接口，一个接口也可以被多个类实现</p><p>我们用 <code>implements</code>关键字来代表 实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> //接口可以在面向对象编程中表示为行为的抽象</span><br><span class="line">interface Speakable &#123;</span><br><span class="line">  speak(): void;</span><br><span class="line">&#125;</span><br><span class="line">interface Eatable &#123;</span><br><span class="line">  eat(): void;</span><br><span class="line">&#125;</span><br><span class="line">//一个类可以实现多个接口</span><br><span class="line">class Person implements Speakable, Eatable &#123;</span><br><span class="line">  speak() &#123;</span><br><span class="line">    console.log(&quot;Person说话&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  //   eat() &#123;&#125; //需要实现的接口包含eat方法 不实现会报错</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-3-定义任意属性"><a href="#5-3-定义任意属性" class="headerlink" title="5.3 定义任意属性"></a><strong>5.3 定义任意属性</strong></h5><p>如果我们在定义接口的时候无法预先知道有哪些属性的时候,可以使用 <code>[propName:string]:any</code>,propName 名字是任意的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  id: number;</span><br><span class="line">  name: string;</span><br><span class="line">  [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p1 = &#123;</span><br><span class="line">  id: 1,</span><br><span class="line">  name: &quot;hello&quot;,</span><br><span class="line">  age: 10,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个接口表示 必须要有 id 和 name 这两个字段 然后还可以新加其余的未知字段</p><h5 id="5-4-接口的继承"><a href="#5-4-接口的继承" class="headerlink" title="5.4 接口的继承"></a><strong>5.4 接口的继承</strong></h5><p>我们除了类可以继承 接口也可以继承 同样的使用 <code>extends</code>关键字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface Speakable &#123;</span><br><span class="line">  speak(): void;</span><br><span class="line">&#125;</span><br><span class="line">interface SpeakChinese extends Speakable &#123;</span><br><span class="line">  speakChinese(): void;</span><br><span class="line">&#125;</span><br><span class="line">class Person implements SpeakChinese &#123;</span><br><span class="line">  speak() &#123;</span><br><span class="line">    console.log(&quot;Person&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  speakChinese() &#123;</span><br><span class="line">    console.log(&quot;speakChinese&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-5-函数类型接口"><a href="#5-5-函数类型接口" class="headerlink" title="5.5 函数类型接口"></a><strong>5.5 函数类型接口</strong></h5><p>可以用接口来定义函数类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface discount &#123;</span><br><span class="line">  (price: number): number;</span><br><span class="line">&#125;</span><br><span class="line">let cost: discount = function (price: number): number &#123;</span><br><span class="line">  return price * 0.8;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="5-6-构造函数的类型接口"><a href="#5-6-构造函数的类型接口" class="headerlink" title="5.6 构造函数的类型接口"></a><strong>5.6 构造函数的类型接口</strong></h5><p>使用特殊的 new()关键字来描述类的构造函数类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  constructor(public name: string) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">//不加new是修饰函数的,加new是修饰类的</span><br><span class="line">interface WithNameClass &#123;</span><br><span class="line">  new (name: string): Animal;</span><br><span class="line">&#125;</span><br><span class="line">function createAnimal(clazz: WithNameClass, name: string) &#123;</span><br><span class="line">  return new clazz(name);</span><br><span class="line">&#125;</span><br><span class="line">let a = createAnimal(Animal, &quot;hello&quot;);</span><br><span class="line">console.log(a.name);</span><br></pre></td></tr></table></figure><p>其实这样的用法一般出现在 当我们需要把一个类作为参数的时候 我们需要对传入的类的构造函数类型进行约束 所以需要使用 new 关键字代表是类的构造函数类型 用以和普通函数进行区分</p><hr><blockquote><p><strong>❝</strong></p></blockquote><blockquote><p>思考：接口和类型别名的区别 这个题目是经典的 「ts 面试题」</p></blockquote><blockquote><p>❞</p></blockquote><p>实际上，在大多数的情况下使用接口类型和类型别名的效果等价，但是在某些特定的场景下这两者还是存在很大区别。</p><p>1.基础数据类型 与接口不同，类型别名还可以用于其他类型，如基本类型（原始值）、联合类型、元组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> // primitive</span><br><span class="line">type Name = string;</span><br><span class="line"></span><br><span class="line">// union</span><br><span class="line">type PartialPoint = PartialPointX | PartialPointY;</span><br><span class="line"></span><br><span class="line">// tuple</span><br><span class="line">type Data = [number, string];</span><br><span class="line"></span><br><span class="line">// dom</span><br><span class="line">let div = document.createElement(&quot;div&quot;);</span><br><span class="line">type B = typeof div;</span><br></pre></td></tr></table></figure><p>2.重复定义</p><p>接口可以定义多次 会被自动合并为单个接口 类型别名不可以重复定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Point &#123;</span><br><span class="line">  x: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Point &#123;</span><br><span class="line">  y: number;</span><br><span class="line">&#125;</span><br><span class="line">const point: Point = &#123; x: 1, y: 2 &#125;;</span><br></pre></td></tr></table></figure><p>3.扩展 接口可以扩展类型别名，同理，类型别名也可以扩展接口。但是两者实现扩展的方式不同</p><p>接口的扩展就是继承，通过 extends 来实现。类型别名的扩展就是交叉类型，通过 &amp; 来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> // 接口扩展接口</span><br><span class="line">interface PointX &#123;</span><br><span class="line">  x: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Point extends PointX &#123;</span><br><span class="line">  y: number;</span><br><span class="line">&#125;</span><br><span class="line">// ----</span><br><span class="line">// 类型别名扩展类型别名</span><br><span class="line">type PointX = &#123;</span><br><span class="line">  x: number;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type Point = PointX &amp; &#123;</span><br><span class="line">  y: number;</span><br><span class="line">&#125;;</span><br><span class="line">// ----</span><br><span class="line">// 接口扩展类型别名</span><br><span class="line">type PointX = &#123;</span><br><span class="line">  x: number;</span><br><span class="line">&#125;;</span><br><span class="line">interface Point extends PointX &#123;</span><br><span class="line">  y: number;</span><br><span class="line">&#125;</span><br><span class="line">// ----</span><br><span class="line">// 类型别名扩展接口</span><br><span class="line">interface PointX &#123;</span><br><span class="line">  x: number;</span><br><span class="line">&#125;</span><br><span class="line">type Point = PointX &amp; &#123;</span><br><span class="line">  y: number;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>4.实现 这里有一个特殊情况 类无法实现定义了联合类型的类型别名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type PartialPoint = &#123; x: number &#125; | &#123; y: number &#125;;</span><br><span class="line"></span><br><span class="line">// A class can only implement an object type or</span><br><span class="line">// intersection of object types with statically known members.</span><br><span class="line">class SomePartialPoint implements PartialPoint &#123;</span><br><span class="line">  // Error</span><br><span class="line">  x = 1;</span><br><span class="line">  y = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-泛型"><a href="#6-泛型" class="headerlink" title="6 泛型"></a><strong>6 泛型</strong></h3><p>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性</p><p>为了更好的了解泛型的作用 我们可以看下面的一个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createArray(length: number, value: any): any[] &#123;</span><br><span class="line">  let result = [];</span><br><span class="line">  for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">    result[i] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray(3, &quot;x&quot;); // [&apos;x&apos;, &apos;x&apos;, &apos;x&apos;]</span><br></pre></td></tr></table></figure><p>上述这段代码用来生成一个长度为 length 值为 value 的数组 但是我们其实可以发现一个问题 不管我们传入什么类型的 value 返回值的数组永远是 any 类型 如果我们想要的效果是 我们预先不知道会传入什么类型 但是我们希望不管我们传入什么类型 我们的返回的数组的指里面的类型应该和参数保持一致 那么这时候 泛型就登场了</p><p>使用「泛型」改造</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;</span><br><span class="line">  let result: T[] = [];</span><br><span class="line">  for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">    result[i] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray&lt;string&gt;(3, &quot;x&quot;); // [&apos;x&apos;, &apos;x&apos;, &apos;x&apos;]</span><br></pre></td></tr></table></figure><p>我们可以使用&lt;&gt;的写法 然后再面传入一个变量 T 用来表示后续函数需要用到的类型 当我们真正去调用函数的时候再传入 T 的类型就可以解决很多预先无法确定类型相关的问题</p><h5 id="6-1-多个类型参数"><a href="#6-1-多个类型参数" class="headerlink" title="6.1 多个类型参数"></a><strong>6.1 多个类型参数</strong></h5><p>如果我们需要有多个未知的类型占位 那么我们可以定义任何的字母来表示不同的类型参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] &#123;</span><br><span class="line">  return [tuple[1], tuple[0]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">swap([7, &quot;seven&quot;]); // [&apos;seven&apos;, 7]</span><br></pre></td></tr></table></figure><h5 id="6-2-泛型约束"><a href="#6-2-泛型约束" class="headerlink" title="6.2 泛型约束"></a><strong>6.2 泛型约束</strong></h5><p>在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function loggingIdentity&lt;T&gt;(arg: T): T &#123;</span><br><span class="line">  console.log(arg.length);</span><br><span class="line">  return arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// index.ts(2,19): error TS2339: Property &apos;length&apos; does not exist on type &apos;T&apos;.</span><br></pre></td></tr></table></figure><p>上例中，泛型 T 不一定包含属性 length，所以编译的时候报错了。</p><p>这时，我们可以对泛型进行约束，只允许这个函数传入那些包含 length 属性的变量。这就是「泛型约束」</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Lengthwise &#123;</span><br><span class="line">  length: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123;</span><br><span class="line">  console.log(arg.length);</span><br><span class="line">  return arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>❝</strong></p></blockquote><blockquote><p>注意：我们在泛型里面使用<code>extends</code>关键字代表的是泛型约束 需要和类的继承区分开</p></blockquote><blockquote><p>❞</p></blockquote><h5 id="6-3-泛型接口"><a href="#6-3-泛型接口" class="headerlink" title="6.3 泛型接口"></a><strong>6.3 泛型接口</strong></h5><p>定义接口的时候也可以指定泛型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Cart&lt;T&gt; &#123;</span><br><span class="line">  list: T[];</span><br><span class="line">&#125;</span><br><span class="line">let cart: Cart&lt;&#123; name: string; price: number &#125;&gt; = &#123;</span><br><span class="line">  list: [&#123; name: &quot;hello&quot;, price: 10 &#125;],</span><br><span class="line">&#125;;</span><br><span class="line">console.log(cart.list[0].name, cart.list[0].price);</span><br></pre></td></tr></table></figure><p>我们定义了接口传入的类型 T 之后返回的对象数组里面 T 就是当时传入的参数类型</p><h5 id="6-4-泛型类"><a href="#6-4-泛型类" class="headerlink" title="6.4 泛型类"></a><strong>6.4 泛型类</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class MyArray&lt;T&gt; &#123;</span><br><span class="line">  private list: T[] = [];</span><br><span class="line">  add(value: T) &#123;</span><br><span class="line">    this.list.push(value);</span><br><span class="line">  &#125;</span><br><span class="line">  getMax(): T &#123;</span><br><span class="line">    let result = this.list[0];</span><br><span class="line">    for (let i = 0; i &lt; this.list.length; i++) &#123;</span><br><span class="line">      if (this.list[i] &gt; result) &#123;</span><br><span class="line">        result = this.list[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let arr = new MyArray();</span><br><span class="line">arr.add(1);</span><br><span class="line">arr.add(2);</span><br><span class="line">arr.add(3);</span><br><span class="line">let ret = arr.getMax();</span><br><span class="line">console.log(ret);</span><br></pre></td></tr></table></figure><p>上诉例子我们实现了一个在数组里面添加数字并且获取最大值的泛型类</p><h5 id="6-5-泛型类型别名"><a href="#6-5-泛型类型别名" class="headerlink" title="6.5 泛型类型别名"></a><strong>6.5 泛型类型别名</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Cart&lt;T&gt; = &#123; list: T[] &#125; | T[];</span><br><span class="line">let c1: Cart&lt;string&gt; = &#123; list: [&quot;1&quot;] &#125;;</span><br><span class="line">let c2: Cart&lt;number&gt; = [1];</span><br></pre></td></tr></table></figure><h5 id="6-6-泛型参数的默认类型"><a href="#6-6-泛型参数的默认类型" class="headerlink" title="6.6 泛型参数的默认类型"></a><strong>6.6 泛型参数的默认类型</strong></h5><p>我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function createArray&lt;T = string&gt;(length: number, value: T): Array&lt;T&gt; &#123;</span><br><span class="line">  let result: T[] = [];</span><br><span class="line">  for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">    result[i] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-实用技巧"><a href="#7-实用技巧" class="headerlink" title="7 实用技巧"></a><strong>7 实用技巧</strong></h3><h5 id="7-1-typeof-关键词"><a href="#7-1-typeof-关键词" class="headerlink" title="7.1 typeof 关键词"></a><strong>7.1 typeof 关键词</strong></h5><p><code>typeof</code> 关键词除了做类型保护 还可以从实现推出类型，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> //先定义变量，再定义类型</span><br><span class="line">let p1 = &#123;</span><br><span class="line">  name: &quot;hello&quot;,</span><br><span class="line">  age: 10,</span><br><span class="line">  gender: &quot;male&quot;,</span><br><span class="line">&#125;;</span><br><span class="line">type People = typeof p1;</span><br><span class="line">function getName(p: People): string &#123;</span><br><span class="line">  return p.name;</span><br><span class="line">&#125;</span><br><span class="line">getName(p1);</span><br></pre></td></tr></table></figure><p>上面的例子就是使用 typeof 获取一个变量的类型</p><h5 id="7-2-keyof-关键词"><a href="#7-2-keyof-关键词" class="headerlink" title="7.2 keyof 关键词"></a><strong>7.2 keyof 关键词</strong></h5><p><code>keyof</code> 可以用来取得一个对象接口的所有 key 值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">  gender: &quot;male&quot; | &quot;female&quot;;</span><br><span class="line">&#125;</span><br><span class="line">//type PersonKey = &apos;name&apos;|&apos;age&apos;|&apos;gender&apos;;</span><br><span class="line">type PersonKey = keyof Person;</span><br><span class="line"></span><br><span class="line">function getValueByKey(p: Person, key: PersonKey) &#123;</span><br><span class="line">  return p[key];</span><br><span class="line">&#125;</span><br><span class="line">let val = getValueByKey(&#123; name: &quot;hello&quot;, age: 10, gender: &quot;male&quot; &#125;, &quot;name&quot;);</span><br><span class="line">console.log(val);</span><br></pre></td></tr></table></figure><h5 id="7-3-索引访问操作符"><a href="#7-3-索引访问操作符" class="headerlink" title="7.3 索引访问操作符"></a><strong>7.3 索引访问操作符</strong></h5><p>使用 [] 操作符可以进行索引访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type x = Person[&quot;name&quot;]; // x is string</span><br></pre></td></tr></table></figure><h5 id="7-4-映射类型-in"><a href="#7-4-映射类型-in" class="headerlink" title="7.4 映射类型 in"></a><strong>7.4 映射类型 in</strong></h5><p>在定义的时候用 in 操作符去批量定义类型中的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">  gender: &quot;male&quot; | &quot;female&quot;;</span><br><span class="line">&#125;</span><br><span class="line">//批量把一个接口中的属性都变成可选的</span><br><span class="line">type PartPerson = &#123;</span><br><span class="line">  [Key in keyof Person]?: Person[Key];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let p1: PartPerson = &#123;&#125;;</span><br></pre></td></tr></table></figure><h5 id="7-5-infer-关键字"><a href="#7-5-infer-关键字" class="headerlink" title="7.5 infer 关键字"></a><strong>7.5 infer 关键字</strong></h5><p>在条件类型语句中，可以用 infer 声明一个类型变量并且对它进行使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type ReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; infer R ? R : any;</span><br></pre></td></tr></table></figure><p>以上代码中 infer R 就是声明一个变量来承载传入函数签名的返回值类型，简单说就是用它取到函数返回值的类型方便之后使用。</p><h5 id="7-6-内置工具类型"><a href="#7-6-内置工具类型" class="headerlink" title="7.6 内置工具类型"></a><strong>7.6 内置工具类型</strong></h5><ol><li>Exclude&lt;T,U&gt; 从 T 可分配给的类型中排除 U</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Exclude&lt;T, U&gt; = T extends U ? never : T;</span><br><span class="line"></span><br><span class="line">type E = Exclude&lt;string | number, string&gt;;</span><br><span class="line">let e: E = 10;</span><br></pre></td></tr></table></figure><ol start="2"><li>Extract&lt;T,U&gt; 从 T 可分配给的类型中提取 U</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Extract&lt;T, U&gt; = T extends U ? T : never;</span><br><span class="line"></span><br><span class="line">type E = Extract&lt;string | number, string&gt;;</span><br><span class="line">let e: E = &quot;1&quot;;</span><br></pre></td></tr></table></figure><ol start="3"><li>NonNullable从 T 中排除 <code>null</code> 和 <code>undefined</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type NonNullable&lt;T&gt; = T extends null | undefined ? never : T;</span><br><span class="line"></span><br><span class="line">type E = NonNullable&lt;string | number | null | undefined&gt;;</span><br><span class="line">let e: E = null;</span><br></pre></td></tr></table></figure><ol start="4"><li>ReturnType<code>infer</code> 最早出现在此 PR 中，表示在 <code>extends</code> 条件语句中待推断的类型变量</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type ReturnType&lt;T extends (...args: any[]) =&gt; any&gt; = T extends (</span><br><span class="line">  ...args: any[]</span><br><span class="line">) =&gt; infer R</span><br><span class="line">  ? R</span><br><span class="line">  : any;</span><br><span class="line">function getUserInfo() &#123;</span><br><span class="line">  return &#123; name: &quot;hello&quot;, age: 10 &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通过 ReturnType 将 getUserInfo 的返回值类型赋给了 UserInfo</span><br><span class="line">type UserInfo = ReturnType&lt;typeof getUserInfo&gt;;</span><br><span class="line"></span><br><span class="line">const userA: UserInfo = &#123;</span><br><span class="line">  name: &quot;hello&quot;,</span><br><span class="line">  age: 10,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可见 该工具类型主要是获取函数类型的返回类型</p><ol start="5"><li>Parameters该工具类型主要是获取函数类型的参数类型</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Parameters&lt;T&gt; = T extends (...args: infer R) =&gt; any ? R : any;</span><br><span class="line"></span><br><span class="line">type T0 = Parameters&lt;() =&gt; string&gt;; // []</span><br><span class="line">type T1 = Parameters&lt;(s: string) =&gt; void&gt;; // [string]</span><br><span class="line">type T2 = Parameters&lt;&lt;T&gt;(arg: T) =&gt; T&gt;; // [unknown]</span><br></pre></td></tr></table></figure><ol start="6"><li>PartialPartial 可以将传入的属性由非可选变为可选</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type Partial&lt;T&gt; = &#123; [P in keyof T]?: T[P] &#125;;</span><br><span class="line">interface A &#123;</span><br><span class="line">  a1: string;</span><br><span class="line">  a2: number;</span><br><span class="line">  a3: boolean;</span><br><span class="line">&#125;</span><br><span class="line">type aPartial = Partial&lt;A&gt;;</span><br><span class="line">const a: aPartial = &#123;&#125;; // 不会报错</span><br></pre></td></tr></table></figure><ol start="7"><li>RequiredRequired 可以将传入的属性中的可选项变为必选项，这里用了 -? 修饰符来实现。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">  gender?: &quot;male&quot; | &quot;female&quot;;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">* type Required&lt;T&gt; = &#123; [P in keyof T]-?: T[P] &#125;;</span><br><span class="line">*/</span><br><span class="line">let p: Required&lt;Person&gt; = &#123;</span><br><span class="line">  name: &quot;hello&quot;,</span><br><span class="line">  age: 10,</span><br><span class="line">  gender: &quot;male&quot;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="8"><li>ReadonlyReadonly 通过为传入的属性每一项都加上 readonly 修饰符来实现。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">  gender?: &quot;male&quot; | &quot;female&quot;;</span><br><span class="line">&#125;</span><br><span class="line">//type Readonly&lt;T&gt; = &#123; readonly [P in keyof T]: T[P] &#125;;</span><br><span class="line">let p: Readonly&lt;Person&gt; = &#123;</span><br><span class="line">  name: &quot;hello&quot;,</span><br><span class="line">  age: 10,</span><br><span class="line">  gender: &quot;male&quot;,</span><br><span class="line">&#125;;</span><br><span class="line">p.age = 11; //error</span><br></pre></td></tr></table></figure><ol start="9"><li>Pick&lt;T,K&gt; Pick 能够帮助我们从传入的属性中摘取某些返回</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface Todo &#123;</span><br><span class="line">  title: string;</span><br><span class="line">  description: string;</span><br><span class="line">  done: boolean;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">* From T pick a set of properties K</span><br><span class="line">* type Pick&lt;T, K extends keyof T&gt; = &#123; [P in K]: T[P] &#125;;</span><br><span class="line">*/</span><br><span class="line">type TodoBase = Pick&lt;Todo, &quot;title&quot; | &quot;done&quot;&gt;;</span><br><span class="line"></span><br><span class="line">// =</span><br><span class="line">type TodoBase = &#123;</span><br><span class="line">  title: string;</span><br><span class="line">  done: boolean;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="10"><li>Record&lt;K,T&gt; 构造一个类型，该类型具有一组属性 K，每个属性的类型为 T。可用于将一个类型的属性映射为另一个类型。Record 后面的泛型就是对象键和值的类型。</li></ol><p>简单理解：K 对应对应的 key，T 对应对象的 value，返回的就是一个声明好的对象 但是 K 对应的泛型约束是<code>keyof any</code> 也就意味着只能传入 <code>string|number|symbol</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> // type Record&lt;K extends keyof any, T&gt; = &#123;</span><br><span class="line">// [P in K]: T;</span><br><span class="line">// &#125;;</span><br><span class="line">type Point = &quot;x&quot; | &quot;y&quot;;</span><br><span class="line">type PointList = Record&lt;Point, &#123; value: number &#125;&gt;;</span><br><span class="line">const cars: PointList = &#123;</span><br><span class="line">  x: &#123; value: 10 &#125;,</span><br><span class="line">  y: &#123; value: 20 &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="11"><li>Omit&lt;K,T&gt; 基于已经声明的类型进行属性剔除获得新类型</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> // type Omit=Pick&lt;T,Exclude&lt;keyof T,K&gt;&gt;</span><br><span class="line">type User = &#123;</span><br><span class="line">id: string;</span><br><span class="line">name: string;</span><br><span class="line">email: string;</span><br><span class="line">&#125;;</span><br><span class="line">type UserWithoutEmail = Omit&lt;User, &quot;email&quot;&gt;; // UserWithoutEmail =&#123;id: string;name: string;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="8-TypeScript-装饰器"><a href="#8-TypeScript-装饰器" class="headerlink" title="8 TypeScript 装饰器"></a><strong>8</strong> <strong>TypeScript</strong> <strong>装饰器</strong></h3><p>装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上，可以修改类的行为</p><p>常见的装饰器有类装饰器、属性装饰器、方法装饰器和参数装饰器</p><p>装饰器的写法分为普通装饰器和装饰器工厂</p><p>使用@装饰器的写法需要把 tsconfig.json 的 <code>experimentalDecorators</code> 字段设置为 true</p><h5 id="8-1-类装饰器"><a href="#8-1-类装饰器" class="headerlink" title="8.1 类装饰器"></a><strong>8.1 类装饰器</strong></h5><p>类装饰器在类声明之前声明，用来监视、修改或替换类定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">namespace a &#123;</span><br><span class="line">  //当装饰器作为修饰类的时候，会把构造器传递进去</span><br><span class="line">  function addNameEat(constructor: Function) &#123;</span><br><span class="line">    constructor.prototype.name = &quot;hello&quot;;</span><br><span class="line">    constructor.prototype.eat = function () &#123;</span><br><span class="line">      console.log(&quot;eat&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  @addNameEat</span><br><span class="line">  class Person &#123;</span><br><span class="line">    name!: string;</span><br><span class="line">    eat!: Function;</span><br><span class="line">    constructor() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  let p: Person = new Person();</span><br><span class="line">  console.log(p.name);</span><br><span class="line">  p.eat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace b &#123;</span><br><span class="line">  //还可以使用装饰器工厂 这样可以传递额外参数</span><br><span class="line">  function addNameEatFactory(name: string) &#123;</span><br><span class="line">    return function (constructor: Function) &#123;</span><br><span class="line">      constructor.prototype.name = name;</span><br><span class="line">      constructor.prototype.eat = function () &#123;</span><br><span class="line">        console.log(&quot;eat&quot;);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  @addNameEatFactory(&quot;hello&quot;)</span><br><span class="line">  class Person &#123;</span><br><span class="line">    name!: string;</span><br><span class="line">    eat!: Function;</span><br><span class="line">    constructor() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  let p: Person = new Person();</span><br><span class="line">  console.log(p.name);</span><br><span class="line">  p.eat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace c &#123;</span><br><span class="line">  //还可以替换类,不过替换的类要与原类结构相同</span><br><span class="line">  function enhancer(constructor: Function) &#123;</span><br><span class="line">    return class &#123;</span><br><span class="line">      name: string = &quot;jiagou&quot;;</span><br><span class="line">      eat() &#123;</span><br><span class="line">        console.log(&quot;吃饭饭&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  @enhancer</span><br><span class="line">  class Person &#123;</span><br><span class="line">    name!: string;</span><br><span class="line">    eat!: Function;</span><br><span class="line">    constructor() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  let p: Person = new Person();</span><br><span class="line">  console.log(p.name);</span><br><span class="line">  p.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="8-2-属性装饰器"><a href="#8-2-属性装饰器" class="headerlink" title="8.2 属性装饰器"></a><strong>8.2 属性装饰器</strong></h5><p>属性装饰器表达式会在运行时当作函数被调用，传入 2 个参数 第一个参数对于静态成员来说是类的构造函数，对于实例成员是类的原型对象 第二个参数是属性的名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> //修饰实例属性</span><br><span class="line">function upperCase(target: any, propertyKey: string) &#123;</span><br><span class="line">  let value = target[propertyKey];</span><br><span class="line">  const getter = function () &#123;</span><br><span class="line">    return value;</span><br><span class="line">  &#125;;</span><br><span class="line">  // 用来替换的setter</span><br><span class="line">  const setter = function (newVal: string) &#123;</span><br><span class="line">    value = newVal.toUpperCase();</span><br><span class="line">  &#125;;</span><br><span class="line">  // 替换属性，先删除原先的属性，再重新定义属性</span><br><span class="line">  if (delete target[propertyKey]) &#123;</span><br><span class="line">    Object.defineProperty(target, propertyKey, &#123;</span><br><span class="line">      get: getter,</span><br><span class="line">      set: setter,</span><br><span class="line">      enumerable: true,</span><br><span class="line">      configurable: true,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">  @upperCase</span><br><span class="line">  name!: string;</span><br><span class="line">&#125;</span><br><span class="line">let p: Person = new Person();</span><br><span class="line">p.name = &quot;world&quot;;</span><br><span class="line">console.log(p.name);</span><br></pre></td></tr></table></figure><h5 id="8-3-方法装饰器"><a href="#8-3-方法装饰器" class="headerlink" title="8.3 方法装饰器"></a><strong>8.3 方法装饰器</strong></h5><p>方法装饰器顾名思义，用来装饰类的方法。它接收三个参数：target: Object - 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象 propertyKey: string | symbol - 方法名 descriptor: TypePropertyDescript - 属性描述符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> //修饰实例方法</span><br><span class="line">function noEnumerable(</span><br><span class="line">  target: any,</span><br><span class="line">  property: string,</span><br><span class="line">  descriptor: PropertyDescriptor</span><br><span class="line">) &#123;</span><br><span class="line">  console.log(&quot;target.getName&quot;, target.getName);</span><br><span class="line">  console.log(&quot;target.getAge&quot;, target.getAge);</span><br><span class="line">  descriptor.enumerable = false;</span><br><span class="line">&#125;</span><br><span class="line">//重写方法</span><br><span class="line">function toNumber(</span><br><span class="line">  target: any,</span><br><span class="line">  methodName: string,</span><br><span class="line">  descriptor: PropertyDescriptor</span><br><span class="line">) &#123;</span><br><span class="line">  let oldMethod = descriptor.value;</span><br><span class="line">  descriptor.value = function (...args: any[]) &#123;</span><br><span class="line">    args = args.map((item) =&gt; parseFloat(item));</span><br><span class="line">    return oldMethod.apply(this, args);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">class Person &#123;</span><br><span class="line">  name: string = &quot;hello&quot;;</span><br><span class="line">  public static age: number = 10;</span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line">  @noEnumerable</span><br><span class="line">  getName() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">  @toNumber</span><br><span class="line">  sum(...args: any[]) &#123;</span><br><span class="line">    return args.reduce((accu: number, item: number) =&gt; accu + item, 0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p: Person = new Person();</span><br><span class="line">for (let attr in p) &#123;</span><br><span class="line">  console.log(&quot;attr=&quot;, attr);</span><br><span class="line">&#125;</span><br><span class="line">p.getName();</span><br><span class="line">console.log(p.sum(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;));</span><br></pre></td></tr></table></figure><h5 id="8-4-参数装饰器"><a href="#8-4-参数装饰器" class="headerlink" title="8.4 参数装饰器"></a><strong>8.4 参数装饰器</strong></h5><p>参数装饰器顾名思义，是用来装饰函数参数，它接收三个参数：</p><p>target: Object - 被装饰的类 propertyKey: string | symbol - 方法名 parameterIndex: number - 方法中参数的索引值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Log(target: Function, key: string, parameterIndex: number) &#123;</span><br><span class="line">  let functionLogged = key || target.prototype.constructor.name;</span><br><span class="line">  console.log(`The parameter in position $&#123;parameterIndex&#125; at $&#123;functionLogged&#125; has</span><br><span class="line"> been decorated`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Greeter &#123;</span><br><span class="line">  greeting: string;</span><br><span class="line">  constructor(@Log phrase: string) &#123;</span><br><span class="line">    this.greeting = phrase;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码成功运行后，控制台会输出以下结果：<code>&quot;The parameter in position 0 at Greeter has been decorated&quot;</code></p><h5 id="8-5-装饰器执行顺序"><a href="#8-5-装饰器执行顺序" class="headerlink" title="8.5 装饰器执行顺序"></a><strong>8.5 装饰器执行顺序</strong></h5><p>有多个参数装饰器时：从最后一个参数依次向前执行</p><p>方法和方法参数中参数装饰器先执行。方法和属性装饰器，谁在前面谁先执行。因为参数属于方法一部分，所以参数会一直紧紧挨着方法执行</p><p>类装饰器总是最后执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">function Class1Decorator() &#123;</span><br><span class="line">  return function (target: any) &#123;</span><br><span class="line">    console.log(&quot;类1装饰器&quot;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">function Class2Decorator() &#123;</span><br><span class="line">  return function (target: any) &#123;</span><br><span class="line">    console.log(&quot;类2装饰器&quot;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">function MethodDecorator() &#123;</span><br><span class="line">  return function (</span><br><span class="line">    target: any,</span><br><span class="line">    methodName: string,</span><br><span class="line">    descriptor: PropertyDescriptor</span><br><span class="line">  ) &#123;</span><br><span class="line">    console.log(&quot;方法装饰器&quot;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">function Param1Decorator() &#123;</span><br><span class="line">  return function (target: any, methodName: string, paramIndex: number) &#123;</span><br><span class="line">    console.log(&quot;参数1装饰器&quot;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">function Param2Decorator() &#123;</span><br><span class="line">  return function (target: any, methodName: string, paramIndex: number) &#123;</span><br><span class="line">    console.log(&quot;参数2装饰器&quot;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">function PropertyDecorator(name: string) &#123;</span><br><span class="line">  return function (target: any, propertyName: string) &#123;</span><br><span class="line">    console.log(name + &quot;属性装饰器&quot;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Class1Decorator()</span><br><span class="line">@Class2Decorator()</span><br><span class="line">class Person &#123;</span><br><span class="line">  @PropertyDecorator(&quot;name&quot;)</span><br><span class="line">  name: string = &quot;hello&quot;;</span><br><span class="line">  @PropertyDecorator(&quot;age&quot;)</span><br><span class="line">  age: number = 10;</span><br><span class="line">  @MethodDecorator()</span><br><span class="line">  greet(@Param1Decorator() p1: string, @Param2Decorator() p2: string) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">name属性装饰器</span><br><span class="line">age属性装饰器</span><br><span class="line">参数2装饰器</span><br><span class="line">参数1装饰器</span><br><span class="line">方法装饰器</span><br><span class="line">类2装饰器</span><br><span class="line">类1装饰器</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h3 id="9-编译"><a href="#9-编译" class="headerlink" title="9 编译"></a><strong>9 编译</strong></h3><h5 id="9-1-tsconfig-json-的作用"><a href="#9-1-tsconfig-json-的作用" class="headerlink" title="9.1 tsconfig.json 的作用"></a><strong>9.1 tsconfig.json 的作用</strong></h5><ul><li>用于标识 TypeScript 项目的根路径；</li></ul><!----><ul><li>用于配置 TypeScript 编译器；</li></ul><!----><ul><li>用于指定编译的文件。</li></ul><h5 id="9-2-tsconfig-json-重要字段"><a href="#9-2-tsconfig-json-重要字段" class="headerlink" title="9.2 tsconfig.json 重要字段"></a><strong>9.2 tsconfig.json 重要字段</strong></h5><ul><li>files - 设置要编译的文件的名称；</li></ul><!----><ul><li>include - 设置需要进行编译的文件，支持路径模式匹配；</li></ul><!----><ul><li>exclude - 设置无需进行编译的文件，支持路径模式匹配；</li></ul><!----><ul><li>compilerOptions - 设置与编译流程相关的选项。</li></ul><h5 id="9-3-compilerOptions-选项"><a href="#9-3-compilerOptions-选项" class="headerlink" title="9.3 compilerOptions 选项"></a><strong>9.3 compilerOptions 选项</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line"></span><br><span class="line">    /* 基本选项 */</span><br><span class="line">    &quot;target&quot;: &quot;es5&quot;,                       // 指定 ECMAScript 目标版本: &apos;ES3&apos; (default), &apos;ES5&apos;, &apos;ES6&apos;/&apos;ES2015&apos;, &apos;ES2016&apos;, &apos;ES2017&apos;, or &apos;ESNEXT&apos;</span><br><span class="line">    &quot;module&quot;: &quot;commonjs&quot;,                  // 指定使用模块: &apos;commonjs&apos;, &apos;amd&apos;, &apos;system&apos;, &apos;umd&apos; or &apos;es2015&apos;</span><br><span class="line">    &quot;lib&quot;: [],                             // 指定要包含在编译中的库文件</span><br><span class="line">    &quot;allowJs&quot;: true,                       // 允许编译 javascript 文件</span><br><span class="line">    &quot;checkJs&quot;: true,                       // 报告 javascript 文件中的错误</span><br><span class="line">    &quot;jsx&quot;: &quot;preserve&quot;,                     // 指定 jsx 代码的生成: &apos;preserve&apos;, &apos;react-native&apos;, or &apos;react&apos;</span><br><span class="line">    &quot;declaration&quot;: true,                   // 生成相应的 &apos;.d.ts&apos; 文件</span><br><span class="line">    &quot;sourceMap&quot;: true,                     // 生成相应的 &apos;.map&apos; 文件</span><br><span class="line">    &quot;outFile&quot;: &quot;./&quot;,                       // 将输出文件合并为一个文件</span><br><span class="line">    &quot;outDir&quot;: &quot;./&quot;,                        // 指定输出目录</span><br><span class="line">    &quot;rootDir&quot;: &quot;./&quot;,                       // 用来控制输出目录结构 --outDir.</span><br><span class="line">    &quot;removeComments&quot;: true,                // 删除编译后的所有的注释</span><br><span class="line">    &quot;noEmit&quot;: true,                        // 不生成输出文件</span><br><span class="line">    &quot;importHelpers&quot;: true,                 // 从 tslib 导入辅助工具函数</span><br><span class="line">    &quot;isolatedModules&quot;: true,               // 将每个文件做为单独的模块 （与 &apos;ts.transpileModule&apos; 类似）.</span><br><span class="line"></span><br><span class="line">    /* 严格的类型检查选项 */</span><br><span class="line">    &quot;strict&quot;: true,                        // 启用所有严格类型检查选项</span><br><span class="line">    &quot;noImplicitAny&quot;: true,                 // 在表达式和声明上有隐含的 any类型时报错</span><br><span class="line">    &quot;strictNullChecks&quot;: true,              // 启用严格的 null 检查</span><br><span class="line">    &quot;noImplicitThis&quot;: true,                // 当 this 表达式值为 any 类型的时候，生成一个错误</span><br><span class="line">    &quot;alwaysStrict&quot;: true,                  // 以严格模式检查每个模块，并在每个文件里加入 &apos;use strict&apos;</span><br><span class="line"></span><br><span class="line">    /* 额外的检查 */</span><br><span class="line">    &quot;noUnusedLocals&quot;: true,                // 有未使用的变量时，抛出错误</span><br><span class="line">    &quot;noUnusedParameters&quot;: true,            // 有未使用的参数时，抛出错误</span><br><span class="line">    &quot;noImplicitReturns&quot;: true,             // 并不是所有函数里的代码都有返回值时，抛出错误</span><br><span class="line">    &quot;noFallthroughCasesInSwitch&quot;: true,    // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）</span><br><span class="line"></span><br><span class="line">    /* 模块解析选项 */</span><br><span class="line">    &quot;moduleResolution&quot;: &quot;node&quot;,            // 选择模块解析策略： &apos;node&apos; (Node.js) or &apos;classic&apos; (TypeScript pre-1.6)</span><br><span class="line">    &quot;baseUrl&quot;: &quot;./&quot;,                       // 用于解析非相对模块名称的基目录</span><br><span class="line">    &quot;paths&quot;: &#123;&#125;,                           // 模块名到基于 baseUrl 的路径映射的列表</span><br><span class="line">    &quot;rootDirs&quot;: [],                        // 根文件夹列表，其组合内容表示项目运行时的结构内容</span><br><span class="line">    &quot;typeRoots&quot;: [],                       // 包含类型声明的文件列表</span><br><span class="line">    &quot;types&quot;: [],                           // 需要包含的类型声明文件名列表</span><br><span class="line">    &quot;allowSyntheticDefaultImports&quot;: true,  // 允许从没有设置默认导出的模块中默认导入。</span><br><span class="line"></span><br><span class="line">    /* Source Map Options */</span><br><span class="line">    &quot;sourceRoot&quot;: &quot;./&quot;,                    // 指定调试器应该找到 TypeScript 文件而不是源文件的位置</span><br><span class="line">    &quot;mapRoot&quot;: &quot;./&quot;,                       // 指定调试器应该找到映射文件而不是生成文件的位置</span><br><span class="line">    &quot;inlineSourceMap&quot;: true,               // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件</span><br><span class="line">    &quot;inlineSources&quot;: true,                 // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性</span><br><span class="line"></span><br><span class="line">    /* 其他选项 */</span><br><span class="line">    &quot;experimentalDecorators&quot;: true,        // 启用装饰器</span><br><span class="line">    &quot;emitDecoratorMetadata&quot;: true          // 为装饰器提供元数据的支持</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-模块和声明文件"><a href="#10-模块和声明文件" class="headerlink" title="10 模块和声明文件"></a><strong>10 模块和声明文件</strong></h3><h5 id="10-1-全局模块"><a href="#10-1-全局模块" class="headerlink" title="10.1 全局模块"></a><strong>10.1 全局模块</strong></h5><p>在默认情况下，当你开始在一个新的 TypeScript 文件中写下代码时，它处于全局命名空间中</p><p>使用全局变量空间是危险的，因为它会与文件内的代码命名冲突。我们推荐使用下文中将要提到的文件模块</p><p>foo.ts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const foo = 123;</span><br></pre></td></tr></table></figure><p>bar.ts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const bar = foo; // allowed</span><br></pre></td></tr></table></figure><h5 id="10-2-文件模块"><a href="#10-2-文件模块" class="headerlink" title="10.2 文件模块"></a><strong>10.2 文件模块</strong></h5><ul><li>文件模块也被称为外部模块。如果在你的 TypeScript 文件的根级别位置含有 import 或者 export，那么它会在这个文件中创建一个本地的作用域</li></ul><!----><ul><li>模块是 TS 中外部模块的简称，侧重于代码和复用</li></ul><!----><ul><li>模块在其自身的作用域里执行，而不是在全局作用域里</li></ul><!----><ul><li>一个模块里的变量、函数、类等在外部是不可见的，除非你把它导出</li></ul><!----><ul><li>如果想要使用一个模块里导出的变量，则需要导入</li></ul><p>foo.ts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const foo = 123;</span><br><span class="line">export &#123;&#125;;</span><br></pre></td></tr></table></figure><p>bar.ts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const bar = foo; // error</span><br></pre></td></tr></table></figure><h5 id="10-3-声明文件"><a href="#10-3-声明文件" class="headerlink" title="10.3 声明文件"></a><strong>10.3 声明文件</strong></h5><ul><li>我们可以把类型声明放在一个单独的类型声明文件中</li></ul><!----><ul><li>文件命名规范为*.d.ts</li></ul><!----><ul><li>查看类型声明文件有助于了解库的使用方式</li></ul><p>typings\jquery.d.ts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">declare const $: (selector: string) =&gt; &#123;</span><br><span class="line">  click(): void;</span><br><span class="line">  width(length: number): void;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="10-4-第三方声明文件"><a href="#10-4-第三方声明文件" class="headerlink" title="10.4 第三方声明文件"></a><strong>10.4 第三方声明文件</strong></h5><ul><li>可以安装使用第三方的声明文件</li></ul><!----><ul><li>@types 是一个约定的前缀，所有的第三方声明的类型库都会带有这样的前缀</li></ul><!----><ul><li>JavaScript 中有很多内置对象，它们可以在 TypeScript 中被当做声明好了的类型</li></ul><!----><ul><li>内置对象是指根据标准在全局作用域（Global）上存在的对象。这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准</li></ul><!----><ul><li>这些内置对象的类型声明文件，就包含在 TypeScript 核心库的类型声明文件中,具体可以查看ts 核心声明文件</li></ul><h5 id="10-5-查找声明文件"><a href="#10-5-查找声明文件" class="headerlink" title="10.5 查找声明文件"></a><strong>10.5 查找声明文件</strong></h5><ul><li>如果是手动写的声明文件，那么需要满足以下条件之一，才能被正确的识别</li></ul><!----><ul><li>给 package.json 中的 types 或 typings 字段指定一个类型声明文件地址</li></ul><!----><ul><li>在项目根目录下，编写一个 index.d.ts 文件</li></ul><!----><ul><li>针对入口文件（package.json 中的 main 字段指定的入口文件），编写一个同名不同后缀的 .d.ts 文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;myLib&quot;,</span><br><span class="line">    &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">    &quot;main&quot;: &quot;lib/index.js&quot;,</span><br><span class="line">    &quot;types&quot;: &quot;myLib.d.ts&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找过程如下：</p><p>1.先找 myLib.d.ts</p><p>2.没有就再找 index.d.ts</p><p>3.还没有再找 lib/index.d.js</p><p>4.还找不到就认为没有类型声明了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-ts-安装和编译&quot;&gt;&lt;a href=&quot;#1-ts-安装和编译&quot; class=&quot;headerlink&quot; title=&quot;1 ts 安装和编译&quot;&gt;&lt;/a&gt;&lt;strong&gt;1&lt;/strong&gt; &lt;strong&gt;ts&lt;/strong&gt; &lt;strong&gt;安装和编译&lt;/st
      
    
    </summary>
    
      <category term="前端" scheme="https://skhon.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Web" scheme="https://skhon.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>【源码解析】探索garfish源码</title>
    <link href="https://skhon.github.io/2021/12/28/fe/garfish/"/>
    <id>https://skhon.github.io/2021/12/28/fe/garfish/</id>
    <published>2021-12-28T09:21:46.644Z</published>
    <updated>2022-05-14T12:00:29.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>首先，可以在github上把代码拉到本地，地址为：<a href="https://github.com/modern-js-dev/garfish" target="_blank" rel="noopener">https://github.com/modern-js-dev/garfish</a><br>然后就需要把项目跑起来，方便调试。总共四步即可：</p><ol><li>全局安装pnpm：<blockquote><p>$ npm i -g pnpm</p></blockquote></li><li>安装依赖<blockquote><p>$ pnpm install</p></blockquote></li><li>启动build:watch<blockquote><p>$ pnpm build:watch</p></blockquote></li><li>启动dev<blockquote><p>$ pnpm dev<br>这样就跑起来了。整体框架代码讲解主要以流程为主，一些细节性逻辑就直接跳过，有兴趣的同学可以翻源码。</p></blockquote><h1 id="在主应用中引入Garfish实例："><a href="#在主应用中引入Garfish实例：" class="headerlink" title="在主应用中引入Garfish实例："></a>在主应用中引入Garfish实例：</h1>在主应用中，首先引入Garfish实例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// dev/main/src/index.ts</span><br><span class="line">import GarfishInstance from &apos;garfish&apos;;</span><br></pre></td></tr></table></figure></li></ol><p>先看一下这个实例是个啥，追溯一下源码，发现Garfish实例是一个函数返回的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// packages/garfish/src/index.ts</span><br><span class="line">function createContext(): Garfish &#123;</span><br><span class="line">  // ...</span><br><span class="line">  // Existing garfish instance, direct return</span><br><span class="line">  if (inBrowser() &amp;&amp; window[&apos;__GARFISH__&apos;] &amp;&amp; window[&apos;Garfish&apos;]) &#123;</span><br><span class="line">    return window[&apos;Garfish&apos;];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const GarfishInstance = new Garfish(&#123;</span><br><span class="line">    plugins: [GarfishRouter(), GarfishBrowserVm(), GarfishBrowserSnapshot()],</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line">  </span><br><span class="line">  return GarfishInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>createContext可以理解为创建上下文环境，从上至下捋一下，如果是浏览器环境，并且window上存在Garfish对象，则直接返回（熟悉设计模式的同学，应该知道这是一个单例模式）。接下来new了一个Garfish对象，并且默认传入了一个对象 { plugins: [GarfishRouter(), GarfishBrowserVm(), GarfishBrowserSnapshot()] }。这是初始化了三个插件，我们继续看一下这三个插件长什么样子。<br>我们先看一下GarfishRouter<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// packages/router/src/index.ts</span><br><span class="line">export function GarfishRouter(_args?: Options) &#123;</span><br><span class="line">  return function (Garfish: interfaces.Garfish): interfaces.Plugin &#123;</span><br><span class="line">    Garfish.apps = &#123;&#125;;</span><br><span class="line">    Garfish.router = router;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      name: &apos;router&apos;,</span><br><span class="line">      version: __VERSION__,</span><br><span class="line"></span><br><span class="line">      bootstrap(options: interfaces.Options) &#123;</span><br><span class="line">        // ...</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      registerApp(appInfos) &#123;</span><br><span class="line">        // ...</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到GarfishRouter()返回的是一个function，形成闭包，最后会返回一个对象。这个对象其实是一个插件的格式，有name、version，还有生命周期钩子bootstrap、registerApp，生命周期钩子我们后续会介绍到，这里大家了解就行。再看看其他两个插件是什么：<br>GarfishBorwserVm:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// packages/browser-vm/src/pluginify.ts</span><br><span class="line">export function GarfishBrowserVm() &#123;</span><br><span class="line">  return function (Garfish: interfaces.Garfish): interfaces.Plugin &#123;</span><br><span class="line">    Garfish.getGlobalObject = function () &#123;</span><br><span class="line">      return Sandbox.getNativeWindow();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Garfish.setGlobalValue = function (key, value) &#123;</span><br><span class="line">      return (this.getGlobalObject()[key] = value);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Garfish.clearEscapeEffect = function (key, value) &#123;</span><br><span class="line">      const global = this.getGlobalObject();</span><br><span class="line">      if (key in global) &#123;</span><br><span class="line">        global[key] = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return createOptions(Garfish);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createOptions(Garfish: interfaces.Garfish) &#123;</span><br><span class="line">  // ...</span><br><span class="line">  const options: interfaces.Plugin = &#123;</span><br><span class="line">    name: &apos;browser-vm&apos;,</span><br><span class="line">    version: __VERSION__,</span><br><span class="line"></span><br><span class="line">    afterLoad(appInfo, appInstance) &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    // If the app is uninstalled, the sandbox needs to clear all effects and then reset</span><br><span class="line">    afterUnmount(appInfo, appInstance, isCacheMode) &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    afterMount(appInfo, appInstance) &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  return options;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>GarfishBrowserSnapshot:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// packages/browser-snapshot/src/index.ts</span><br><span class="line">export function GarfishBrowserSnapshot(op?: BrowserConfig) &#123;</span><br><span class="line">  return function (Garfish: interfaces.Garfish): interfaces.Plugin &#123;</span><br><span class="line">    const config: BrowserConfig = op || &#123; open: true &#125;;</span><br><span class="line"></span><br><span class="line">    const options = &#123;</span><br><span class="line">      openBrowser: false,</span><br><span class="line">      version: __VERSION__,</span><br><span class="line">      name: &apos;browser-snapshot&apos;,</span><br><span class="line"></span><br><span class="line">      afterLoad(appInfo, appInstance) &#123;</span><br><span class="line">        // ...</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      beforeMount(appInfo, appInstance) &#123;</span><br><span class="line">        // ...</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      afterUnmount(appInfo, appInstance) &#123;</span><br><span class="line">        // ...</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    return options;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到都是返回一个函数，并且这个函数的返回格式有点类似，其实这就是garfish插件的形式，返回一个函数，该函数返回一个对象，这个对象包含了这个插件的一些信息，可以总结成这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name: &apos;&apos;,</span><br><span class="line">    version: &apos;&apos;,</span><br><span class="line">    lifecycle: &apos;&apos; // 这里的lifecycle是泛指生命周期的钩子函数，具体指bootstrap、beforeBootstrap等等</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>插件中生命周期的具体实现，放在后面讲述。这里暂时把代码运行链路拉通。接下来再返回Garfish类的实现，它的实例是什么样子的。<br>Garfish类的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">// packages/core/src/garfish.ts</span><br><span class="line">export class Garfish extends EventEmitter2 &#123;</span><br><span class="line">  public running = false;</span><br><span class="line">  public version = __VERSION__;</span><br><span class="line">  public flag = __GARFISH_FLAG__; // A unique identifier</span><br><span class="line">  public loader = new Loader();</span><br><span class="line">  public hooks = globalLifecycle();</span><br><span class="line">  public channel = new EventEmitter2();</span><br><span class="line">  public options = createDefaultOptions();</span><br><span class="line">  public externals: Record&lt;string, any&gt; = &#123;&#125;;</span><br><span class="line">  public activeApps: Array&lt;interfaces.App&gt; = [];</span><br><span class="line">  public plugins: interfaces.Plugins = &#123;&#125; as any;</span><br><span class="line">  public cacheApps: Record&lt;string, interfaces.App&gt; = &#123;&#125;;</span><br><span class="line">  public appInfos: Record&lt;string, interfaces.AppInfo&gt; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  private nestedSwitch = false;</span><br><span class="line">  private loading: Record&lt;string, Promise&lt;any&gt; | null&gt; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  get props(): Record&lt;string, any&gt; &#123;</span><br><span class="line">    return (this.options &amp;&amp; this.options.props) || DEFAULT_PROPS.get(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  constructor(options: interfaces.Options) &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.setOptions(options);</span><br><span class="line">    DEFAULT_PROPS.set(this, &#123;&#125;);</span><br><span class="line">    this.options.plugins?.forEach((plugin) =&gt; this.usePlugin(plugin));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private setOptions(options: Partial&lt;interfaces.Options&gt;) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  createPluginSystem&lt;T extends (api: typeof HOOKS_API) =&gt; any&gt;(callback: T) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  usePlugin(</span><br><span class="line">    plugin: (context: Garfish) =&gt; interfaces.Plugin,</span><br><span class="line">    ...args: Array&lt;any&gt;</span><br><span class="line">  ) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run(options: interfaces.Options = &#123;&#125;) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  registerApp(list: interfaces.AppInfo | Array&lt;interfaces.AppInfo&gt;) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setExternal(nameOrExtObj: string | Record&lt;string, any&gt;, value?: any) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async loadApp(</span><br><span class="line">    appName: string,</span><br><span class="line">    optionsOrUrl?: Omit&lt;interfaces.AppInfo, &apos;name&apos;&gt;,</span><br><span class="line">  ): Promise&lt;interfaces.App | null&gt; &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>先看一下钩子函数中，做了什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// packages/core/src/garfish.ts</span><br><span class="line">constructor(options: interfaces.Options) &#123;</span><br><span class="line">    super();</span><br><span class="line">    // 传入的options（其实就是默认的那三个插件） 深度merge到默认的options上。</span><br><span class="line">    this.setOptions(options);</span><br><span class="line">    DEFAULT_PROPS.set(this, &#123;&#125;);</span><br><span class="line">    // 这里分别执行默认的三个插件</span><br><span class="line">    this.options.plugins?.forEach((plugin) =&gt; this.usePlugin(plugin));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>this.setOptions(options)主要是把传入的options深度merge到默认的options中。而传入的options就是传入的那三个默认插件。我们看一下默认的options有哪些属性吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// packages/core/src/config.ts</span><br><span class="line">export const createDefaultOptions = (nested = false) =&gt; &#123;</span><br><span class="line">  const config: interfaces.Options = &#123;</span><br><span class="line">    // global config</span><br><span class="line">    appID: &apos;&apos;,</span><br><span class="line">    apps: [],</span><br><span class="line">    autoRefreshApp: true,</span><br><span class="line">    disableStatistics: false,</span><br><span class="line">    disablePreloadApp: false,</span><br><span class="line">    // app config</span><br><span class="line">    basename: &apos;/&apos;,</span><br><span class="line">    props: &#123;&#125;,</span><br><span class="line">    // Use an empty div by default</span><br><span class="line">    domGetter: () =&gt; document.createElement(&apos;div&apos;),</span><br><span class="line">    sandbox: &#123;</span><br><span class="line">      snapshot: false,</span><br><span class="line">      disableWith: false,</span><br><span class="line">      strictIsolation: false,</span><br><span class="line">    &#125;,</span><br><span class="line">    // global hooks</span><br><span class="line">    beforeLoad: () =&gt; &#123;&#125;,</span><br><span class="line">    afterLoad: () =&gt; &#123;&#125;,</span><br><span class="line">    errorLoadApp: (e) =&gt; error(e),</span><br><span class="line">    // Router</span><br><span class="line">    onNotMatchRouter: () =&gt; &#123;&#125;,</span><br><span class="line">    // app hooks</span><br><span class="line">    // Code eval hooks</span><br><span class="line">    beforeEval: () =&gt; &#123;&#125;,</span><br><span class="line">    afterEval: () =&gt; &#123;&#125;,</span><br><span class="line">    // App mount hooks</span><br><span class="line">    beforeMount: () =&gt; &#123;&#125;,</span><br><span class="line">    afterMount: () =&gt; &#123;&#125;,</span><br><span class="line">    beforeUnmount: () =&gt; &#123;&#125;,</span><br><span class="line">    afterUnmount: () =&gt; &#123;&#125;,</span><br><span class="line">    // Error hooks</span><br><span class="line">    errorMountApp: (e) =&gt; error(e),</span><br><span class="line">    errorUnmountApp: (e) =&gt; error(e),</span><br><span class="line">    customLoader: null, // deprecated</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  if (nested) &#123;</span><br><span class="line">    invalidNestedAttrs.forEach((key) =&gt; delete config[key]);</span><br><span class="line">  &#125;</span><br><span class="line">  return config;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>再回到构造函数中，接下来分别对plugins进行usePlugin操作，其实就是为了拿到插件中的一些属性，并且进行一些注册操作。我们看一下usePlugin做了些什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// packages/core/src/garfish.ts</span><br><span class="line">usePlugin(</span><br><span class="line">    plugin: (context: Garfish) =&gt; interfaces.Plugin,</span><br><span class="line">    ...args: Array&lt;any&gt;</span><br><span class="line">  ) &#123;</span><br><span class="line">   // ...</span><br><span class="line">   </span><br><span class="line">    // this指向是Garfish类</span><br><span class="line">    args.unshift(this); </span><br><span class="line">    </span><br><span class="line">    // 执行传入的plugin</span><br><span class="line">    const pluginConfig = plugin.apply(null, args) as interfaces.Plugin;</span><br><span class="line">    assert(pluginConfig.name, &apos;The plugin must have a name.&apos;);</span><br><span class="line"></span><br><span class="line">    // 如果没有注册过，则进行注册 </span><br><span class="line">    if (!this.plugins[pluginConfig.name]) &#123;</span><br><span class="line">      this.plugins[pluginConfig.name] = pluginConfig;</span><br><span class="line">      // Register hooks, Compatible with the old api</span><br><span class="line">      this.hooks.usePlugin(pluginConfig);</span><br><span class="line">    &#125; else if (__DEV__) &#123;</span><br><span class="line">      warn(&apos;Please do not register the plugin repeatedly.&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>args数组首位是Garfish自己，然后获取插件配置，前面我们提到了，插件最后的返回是一个对象，里面包含name、version、生命周期钩子等。然后plugin.apply()就是返回的这些配置，并且赋值给了pluginConfig。接下来就是注册逻辑了，如果之前没有注册过该plugin，则进行注册，就是key为plugin的name，value为具体的配置形式，放在this.plugins对象中，这个好理解，接下来是进行this.hooks.usePlugin(pluginConfig)操作，这个其实是用来注册生命周期的，看一下this.hooks是啥，再构造函数中，是这么初始化hooks的：<br>// packages/core/src/garfish.ts<br>public hooks = globalLifecycle();<br>通过函数名，也应该能猜得到，全局生命周期的hooks。接着看globalLifeCycle实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// packages/core/src/lifecycle.ts</span><br><span class="line">export function globalLifecycle() &#123;</span><br><span class="line">  return new PluginSystem(&#123;</span><br><span class="line">    beforeBootstrap: new SyncHook&lt;[interfaces.Options], void&gt;(),</span><br><span class="line">    bootstrap: new SyncHook&lt;[interfaces.Options], void&gt;(),</span><br><span class="line">    beforeRegisterApp: new SyncHook&lt;[interfaces.AppInfo | Array&lt;interfaces.AppInfo&gt;], void&gt;(),</span><br><span class="line">    registerApp: new SyncHook&lt;[Record&lt;string, interfaces.AppInfo&gt;], void&gt;(),</span><br><span class="line">    beforeLoad: new AsyncHook&lt;[interfaces.AppInfo], Promise&lt;boolean | void&gt; | void | boolean&gt;(),</span><br><span class="line">    afterLoad: new AsyncHook&lt;[interfaces.AppInfo, interfaces.App], void&gt;(),</span><br><span class="line">    errorLoadApp: new SyncHook&lt;[Error, interfaces.AppInfo], void&gt;(),</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>返回的是一个pluginSystem实例，传入一个对象，包含7个生命周期属性。先看pluginSystem类的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// packages/hooks/src/pluginSystem.ts</span><br><span class="line">export class PluginSystem&lt;T extends Record&lt;string, any&gt;&gt; &#123;</span><br><span class="line">  lifecycle: T;</span><br><span class="line">  lifecycleKeys: Array&lt;keyof T&gt;;</span><br><span class="line">  private registerPlugins: Record&lt;string, Plugin&lt;T&gt;&gt; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  constructor(lifecycle: T) &#123;</span><br><span class="line">    /*</span><br><span class="line">      lifecycle: </span><br><span class="line">      &#123;</span><br><span class="line">        beforeBootstrap: new SyncHook&lt;[interfaces.Options], void&gt;(),</span><br><span class="line">        bootstrap: new SyncHook&lt;[interfaces.Options], void&gt;(),</span><br><span class="line">        beforeRegisterApp: new SyncHook&lt;[interfaces.AppInfo | Array&lt;interfaces.AppInfo&gt;], void&gt;(),</span><br><span class="line">        registerApp: new SyncHook&lt;[Record&lt;string, interfaces.AppInfo&gt;], void&gt;(),</span><br><span class="line">        beforeLoad: new AsyncHook&lt;[interfaces.AppInfo], Promise&lt;boolean | void&gt; | void | boolean&gt;(),</span><br><span class="line">        afterLoad: new AsyncHook&lt;[interfaces.AppInfo, interfaces.App], void&gt;(),</span><br><span class="line">        errorLoadApp: new SyncHook&lt;[Error, interfaces.AppInfo], void&gt;(),</span><br><span class="line">      &#125;</span><br><span class="line">    */</span><br><span class="line">    this.lifecycle = lifecycle;</span><br><span class="line">    this.lifecycleKeys = Object.keys(lifecycle);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  usePlugin(plugin: Plugin&lt;T&gt;) &#123;</span><br><span class="line">    assert(isPlainObject(plugin), &apos;Invalid plugin configuration.&apos;);</span><br><span class="line">    // Plugin name is required and unique</span><br><span class="line">    const pluginName = plugin.name;</span><br><span class="line">    assert(pluginName, &apos;Plugin must provide a name.&apos;);</span><br><span class="line"></span><br><span class="line">    if (!this.registerPlugins[pluginName]) &#123;</span><br><span class="line">      this.registerPlugins[pluginName] = plugin;</span><br><span class="line"></span><br><span class="line">      for (const key in this.lifecycle) &#123;</span><br><span class="line">        const pluginLife = plugin[key as string];</span><br><span class="line">        if (pluginLife) &#123;</span><br><span class="line">          // Differentiate different types of hooks and adopt different registration strategies</span><br><span class="line">          this.lifecycle[key].on(pluginLife);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (__DEV__) &#123;</span><br><span class="line">      warn(`Repeat to register plugin hooks &quot;$&#123;pluginName&#125;&quot;.`);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removePlugin(pluginName: string) &#123;</span><br><span class="line">    assert(pluginName, &apos;Must provide a name.&apos;);</span><br><span class="line">    const plugin = this.registerPlugins[pluginName];</span><br><span class="line">    assert(plugin, `plugin &quot;$&#123;pluginName&#125;&quot; is not registered.`);</span><br><span class="line"></span><br><span class="line">    for (const key in plugin) &#123;</span><br><span class="line">      this.lifecycle[key].remove(plugin[key as string]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到上面提到的this.hooks.usePlugin其实是执行了pluginSystem类中的usePlugin方法，实现逻辑也是会在pluginSystem类中的registerPlugins进行注册，然后会在全局生命周期的不同钩子上，注册每个插件配置中对应的钩子函数。这个大家需要好好理解一下，这个设计我们在写自己的框架时可以学习一下。再返回到创建pluginSystem实例中，传入的几个hooks，主要包含两种，一种是同步的SyncHook，另一种是异步的AsyncHook。看一下这两类hooks的实现。<br>SyncHook：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// packages/hooks/src/syncHook.ts</span><br><span class="line">export class SyncHook&lt;T, K&gt; &#123;</span><br><span class="line">  public type: string = &apos;&apos;;</span><br><span class="line">  public listeners = new Set&lt;Callback&lt;T, K&gt;&gt;();</span><br><span class="line"></span><br><span class="line">  constructor(type?: string) &#123;</span><br><span class="line">    if (type) this.type = type;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  on(fn: Callback&lt;T, K&gt;) &#123;</span><br><span class="line">    if (typeof fn === &apos;function&apos;) &#123;</span><br><span class="line">      this.listeners.add(fn);</span><br><span class="line">    &#125; else if (__DEV__) &#123;</span><br><span class="line">      warn(&apos;Invalid parameter in &quot;Hook&quot;.&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  once(fn: Callback&lt;T, K&gt;) &#123;</span><br><span class="line">    const self = this;</span><br><span class="line">    this.on(function wrapper(...args: Array&lt;any&gt;) &#123;</span><br><span class="line">      self.remove(wrapper);</span><br><span class="line">      return fn.apply(null, args);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  emit(...data: ArgsType&lt;T&gt;) &#123;</span><br><span class="line">    if (this.listeners.size &gt; 0) &#123;</span><br><span class="line">      this.listeners.forEach((fn) =&gt; fn.apply(null, data));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  remove(fn: Callback&lt;T, K&gt;) &#123;</span><br><span class="line">    return this.listeners.delete(fn);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeAll() &#123;</span><br><span class="line">    this.listeners.clear();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>就是一个简单的发布订阅模式。<br>AsyncHook：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// packages/hooks/src/asyncHook.ts</span><br><span class="line">export class AsyncHook&lt;T, K&gt; extends SyncHook&lt;T, K&gt; &#123;</span><br><span class="line">  emit(...data: ArgsType&lt;T&gt;): Promise&lt;void | false&gt; &#123;</span><br><span class="line">    let result;</span><br><span class="line">    const ls = Array.from(this.listeners);</span><br><span class="line">    if (ls.length &gt; 0) &#123;</span><br><span class="line">      let i = 0;</span><br><span class="line">      const call = (prev?: any) =&gt; &#123;</span><br><span class="line">        if (prev === false) &#123;</span><br><span class="line">          return false; // Abort process</span><br><span class="line">        &#125; else if (i &lt; ls.length) &#123;</span><br><span class="line">          return Promise.resolve(ls[i++].apply(null, data)).then(call);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      result = call();</span><br><span class="line">    &#125;</span><br><span class="line">    return Promise.resolve(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>AsyncHook的emit实现，可以理解将一串的异步函数，进行同步处理，上一个异步函数的返回，是下一个异步函数的入参，如果看过Koa中间件的实现，就很容易明白这样逻辑的实现了。<br>到目前为止，当主应用引入Garfish后，初步的注册工作基本完成了。</p><h1 id="主应用中启动Garfish"><a href="#主应用中启动Garfish" class="headerlink" title="主应用中启动Garfish"></a>主应用中启动Garfish</h1><p>我们先假设主应用默认路由就是/，不默认展示子应用。<br>再看主应用如何进行下一步的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// main/src/index.ts</span><br><span class="line">import GarfishInstance from &apos;garfish&apos;; </span><br><span class="line">import &#123; Config &#125; from &apos;./config&apos;;</span><br><span class="line"></span><br><span class="line">GarfishInstance.run(Config);</span><br><span class="line">第一行代码，我们已经在上面介绍过了，继续往下走，看看Config是什么：</span><br><span class="line">// dev/main/src/config.ts</span><br><span class="line">let defaultConfig: interfaces.Options = &#123;</span><br><span class="line">  basename: &apos;/garfish_master&apos;,</span><br><span class="line">  domGetter: () =&gt; &#123;</span><br><span class="line">    // await asyncTime();</span><br><span class="line">    return document.querySelector(&apos;#submoduleByRouter&apos;);</span><br><span class="line">  &#125;,</span><br><span class="line">  apps: [</span><br><span class="line">    // &#123;</span><br><span class="line">    //   name: &apos;vue&apos;,</span><br><span class="line">    //   activeWhen: &apos;/vue&apos;,</span><br><span class="line">    //   cache: false,</span><br><span class="line">    //   entry: &apos;http://localhost:2666&apos;,</span><br><span class="line">    // &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name: &apos;vue2&apos;,</span><br><span class="line">      cache: false,</span><br><span class="line">      activeWhen: &apos;/vue2&apos;,</span><br><span class="line">      entry: &apos;http://localhost:2777&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name: &apos;react&apos;,</span><br><span class="line">      activeWhen: &apos;/react&apos;,</span><br><span class="line">      entry: &apos;http://localhost:2444&apos;,</span><br><span class="line">      props: &#123;</span><br><span class="line">        appName: &apos;react&apos;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  autoRefreshApp: false,</span><br><span class="line">  disablePreloadApp: true,</span><br><span class="line">  protectVariable: [&apos;MonitoringInstance&apos;, &apos;Garfish&apos;],</span><br><span class="line">  sandbox: &#123;</span><br><span class="line">    open: true,</span><br><span class="line">    // strictIsolation: true,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // beforeMount(appInfo) &#123;</span><br><span class="line">  //   console.log(&apos;beforeMount&apos;, appInfo);</span><br><span class="line">  // &#125;,</span><br><span class="line"></span><br><span class="line">  // afterLoad(info, app) &#123;</span><br><span class="line">  //   console.log(app.vmSandbox);</span><br><span class="line">  // &#125;,</span><br><span class="line"></span><br><span class="line">  customLoader() &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这个默认配置，是用户可以自定义的，通过之前的源码分析，这些配置最后会深度merge到Garfish类中的默认配置。接下来就是GarfishInstance.run(Config)，将配置传入，然后执行Garfish类中的run方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// packages/core/src/garfish.ts</span><br><span class="line">run(options: interfaces.Options = &#123;&#125;) &#123;</span><br><span class="line">    if (this.running) &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.setOptions(options);</span><br><span class="line">    // Register plugins</span><br><span class="line">    this.usePlugin(GarfishHMRPlugin());</span><br><span class="line">    this.usePlugin(GarfishPerformance());</span><br><span class="line">    if (!this.options.disablePreloadApp) &#123;</span><br><span class="line">      this.usePlugin(GarfishPreloadPlugin());</span><br><span class="line">    &#125;</span><br><span class="line">    options.plugins?.forEach((plugin) =&gt; this.usePlugin(plugin));</span><br><span class="line">    // Put the lifecycle plugin at the end, so that you can get the changes of other plugins</span><br><span class="line">    this.usePlugin(GarfishOptionsLife(this.options, &apos;global-lifecycle&apos;));</span><br><span class="line"></span><br><span class="line">    // Emit hooks and register apps</span><br><span class="line">    this.hooks.lifecycle.beforeBootstrap.emit(this.options);</span><br><span class="line">    this.registerApp(this.options.apps || []);</span><br><span class="line">    this.running = true;</span><br><span class="line">    this.hooks.lifecycle.bootstrap.emit(this.options);</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>首先还是把传入的options参数深度merge到Garfish默认的options中，接着进行一些插件注册，最后注册了一个名为global-lifecycle的插件，这个插件主要是用来兜底的，因为插件注册是有先后顺序的，先注册的插件，在实行生命钩子方法时，是先执行的，所以global-lifecycle这个插件中，传入的生命周期钩子方法是用户可以自定义传入的，那么最后执行的时候，global-lifecycle拿到的是所有插件中最后的数据，方便调试。<br>接下来就是触发生命周期中beforeBootstrap，之前所有的插件中，所有beforeBootstrap的钩子都注册到了全局beforeBootstrap中，这个时候进行emit操作。如果用户没有传入自定义plugin(已经定义了beforeBootstrap方法)的话，这里应该是没有可执行方法的，因为框架内置的一些插件中没有该方法。<br>接下来就是注册app了，我们在主应用中的options中，有个apps的属性，里面注册着所有子应用。看一下registreApp的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// packages/core/src/garfish.ts</span><br><span class="line">registerApp(list: interfaces.AppInfo | Array&lt;interfaces.AppInfo&gt;) &#123;</span><br><span class="line">    const currentAdds = &#123;&#125;;</span><br><span class="line">    this.hooks.lifecycle.beforeRegisterApp.emit(list);</span><br><span class="line">    if (!Array.isArray(list)) list = [list];</span><br><span class="line"></span><br><span class="line">    for (const appInfo of list) &#123;</span><br><span class="line">      assert(appInfo.name, &apos;Miss app.name.&apos;);</span><br><span class="line">      if (!this.appInfos[appInfo.name]) &#123;</span><br><span class="line">        assert(</span><br><span class="line">          appInfo.entry,</span><br><span class="line">          `$&#123;appInfo.name&#125; application entry is not url: $&#123;appInfo.entry&#125;`,</span><br><span class="line">        );</span><br><span class="line">        currentAdds[appInfo.name] = appInfo;</span><br><span class="line">        this.appInfos[appInfo.name] = appInfo;</span><br><span class="line">      &#125; else if (__DEV__) &#123;</span><br><span class="line">        warn(`The &quot;$&#123;appInfo.name&#125;&quot; app is already registered.`);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    this.hooks.lifecycle.registerApp.emit(currentAdds);</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>首先执行生命周期beforeRegisterApp中的方法，然后将apps注册到currentAdds和this.appInfos中，再执行registerApp中的方法。<br>再返回到run方法中，继续往下执行，就会执行生命周期bootstrap中的方法。我们主要看一下router中的bootstrap方法，看看在启动时做了什么<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">// packages/router/src/index.ts</span><br><span class="line">bootstrap(options: interfaces.Options) &#123;</span><br><span class="line">        let activeApp = null;</span><br><span class="line">        const unmounts: Record&lt;string, Function&gt; = &#123;&#125;;</span><br><span class="line">        const &#123; basename &#125; = options;</span><br><span class="line">        const &#123; autoRefreshApp = true, onNotMatchRouter = () =&gt; null &#125; =</span><br><span class="line">          Garfish.options;</span><br><span class="line"></span><br><span class="line">        async function active(appInfo: interfaces.AppInfo, rootPath: string) &#123;</span><br><span class="line">          const &#123; name, cache = true, active &#125; = appInfo;</span><br><span class="line">          if (active) return active(appInfo, rootPath);</span><br><span class="line">          appInfo.rootPath = rootPath;</span><br><span class="line"></span><br><span class="line">          const currentApp = (activeApp = createKey());</span><br><span class="line">          const app = await Garfish.loadApp(appInfo.name, &#123;</span><br><span class="line">            basename: rootPath,</span><br><span class="line">            entry: appInfo.entry,</span><br><span class="line">            cache: true,</span><br><span class="line">            domGetter: appInfo.domGetter,</span><br><span class="line">          &#125;);</span><br><span class="line">          app.appInfo.basename = rootPath;</span><br><span class="line"></span><br><span class="line">          const call = (app: interfaces.App, isRender: boolean) =&gt; &#123;</span><br><span class="line">            if (!app) return;</span><br><span class="line">            const isDes = cache &amp;&amp; app.mounted;</span><br><span class="line">            const fn = isRender</span><br><span class="line">              ? app[isDes ? &apos;show&apos; : &apos;mount&apos;]</span><br><span class="line">              : app[isDes ? &apos;hide&apos; : &apos;unmount&apos;];</span><br><span class="line">            return fn.call(app);</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">          Garfish.apps[name] = app;</span><br><span class="line">          unmounts[name] = () =&gt; call(app, false);</span><br><span class="line"></span><br><span class="line">          if (currentApp === activeApp) &#123;</span><br><span class="line">            await call(app, true);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        async function deactive(appInfo: interfaces.AppInfo, rootPath: string) &#123;</span><br><span class="line">          activeApp = null;</span><br><span class="line">          const &#123; name, deactive &#125; = appInfo;</span><br><span class="line">          if (deactive) return deactive(appInfo, rootPath);</span><br><span class="line"></span><br><span class="line">          const unmount = unmounts[name];</span><br><span class="line">          unmount &amp;&amp; unmount();</span><br><span class="line">          delete Garfish.apps[name];</span><br><span class="line"></span><br><span class="line">          // Nested scene to remove the current application of nested data</span><br><span class="line">          // To avoid the main application prior to application</span><br><span class="line">          const needToDeleteApps = router.routerConfig.apps.filter((app) =&gt; &#123;</span><br><span class="line">            if (appInfo.rootPath === app.basename) return true;</span><br><span class="line">          &#125;);</span><br><span class="line">          if (needToDeleteApps.length &gt; 0) &#123;</span><br><span class="line">            needToDeleteApps.forEach((app) =&gt; &#123;</span><br><span class="line">              delete Garfish.appInfos[app.name];</span><br><span class="line">              delete Garfish.cacheApps[app.name];</span><br><span class="line">            &#125;);</span><br><span class="line">            router.setRouterConfig(&#123;</span><br><span class="line">              apps: router.routerConfig.apps.filter((app) =&gt; &#123;</span><br><span class="line">                return !needToDeleteApps.some(</span><br><span class="line">                  (needDelete) =&gt; app.name === needDelete.name,</span><br><span class="line">                );</span><br><span class="line">              &#125;),</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        const apps = Object.values(Garfish.appInfos);</span><br><span class="line"></span><br><span class="line">        const appList = apps.filter((app) =&gt; &#123;</span><br><span class="line">          if (!app.basename) app.basename = basename;</span><br><span class="line">          return !!app.activeWhen;</span><br><span class="line">        &#125;) as Array&lt;Required&lt;interfaces.AppInfo&gt;&gt;;</span><br><span class="line"></span><br><span class="line">        const listenOptions = &#123;</span><br><span class="line">          basename,</span><br><span class="line">          active,</span><br><span class="line">          deactive,</span><br><span class="line">          autoRefreshApp,</span><br><span class="line">          notMatch: onNotMatchRouter,</span><br><span class="line">          apps: appList,</span><br><span class="line">        &#125;;</span><br><span class="line">        listenRouterAndReDirect(listenOptions);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><p>这个方法可以直接看最后，就是执行了一个listenRouterAndReDirect方法，并传入了listenOptions对象。接着找listenRouterAndReDirect方法的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// packages/router/src/context.ts</span><br><span class="line">export const listenRouterAndReDirect = (&#123;</span><br><span class="line">  apps,</span><br><span class="line">  basename,</span><br><span class="line">  autoRefreshApp,</span><br><span class="line">  active,</span><br><span class="line">  deactive,</span><br><span class="line">  notMatch,</span><br><span class="line">&#125;: Options) =&gt; &#123;</span><br><span class="line">  // 注册子应用、注册激活、销毁钩子</span><br><span class="line">  registerRouter(apps);</span><br><span class="line"></span><br><span class="line">  // 初始化信息</span><br><span class="line">  setRouterConfig(&#123;</span><br><span class="line">    basename,</span><br><span class="line">    autoRefreshApp,</span><br><span class="line">    // supportProxy: !!window.Proxy,</span><br><span class="line">    active,</span><br><span class="line">    deactive,</span><br><span class="line">    notMatch,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 开始监听路由变化触发、子应用更新。重载默认初始子应用</span><br><span class="line">  listen();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>主要就是注册子应用，初始化配置，最后进行监听。再看listen方法的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// packages/router/src/agentRouter.ts</span><br><span class="line">export const listen = () =&gt; &#123;</span><br><span class="line">  normalAgent();</span><br><span class="line">  initRedirect();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>然后执行了两个方法normalAgent和initRedirect，继续往下看实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">// packages/router/src/agentRouter.ts</span><br><span class="line">export const normalAgent = () =&gt; &#123;</span><br><span class="line">  // By identifying whether have finished listening, if finished listening, listening to the routing changes do not need to hijack the original event</span><br><span class="line">  // Support nested scene</span><br><span class="line">  const addRouterListener = function () &#123;</span><br><span class="line">    window.addEventListener(__GARFISH_BEFORE_ROUTER_EVENT__, function (env) &#123;</span><br><span class="line">      RouterConfig.routerChange &amp;&amp; RouterConfig.routerChange(location.pathname);</span><br><span class="line">      linkTo((env as any).detail);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  if (!window[__GARFISH_ROUTER_FLAG__]) &#123;</span><br><span class="line">    // Listen for pushState and replaceState, call linkTo, processing, listen back</span><br><span class="line">    // Rewrite the history API method, triggering events in the call</span><br><span class="line">    const rewrite = function (type: keyof History) &#123;</span><br><span class="line">      const hapi = history[type];</span><br><span class="line">      return function () &#123;</span><br><span class="line">        const urlBefore = window.location.pathname + window.location.hash;</span><br><span class="line">        const stateBefore = history?.state;</span><br><span class="line">        const res = hapi.apply(this as any, arguments);</span><br><span class="line">        const urlAfter = window.location.pathname + window.location.hash;</span><br><span class="line">        const stateAfter = history?.state;</span><br><span class="line"></span><br><span class="line">        const e = createEvent(type);</span><br><span class="line">        (e as any).arguments = arguments;</span><br><span class="line"></span><br><span class="line">        if (urlBefore !== urlAfter || stateBefore !== stateAfter) &#123;</span><br><span class="line">          if (history.state &amp;&amp; history.state === &apos;object&apos;)</span><br><span class="line">            delete history.state[__GARFISH_ROUTER_UPDATE_FLAG__];</span><br><span class="line">          window.dispatchEvent(</span><br><span class="line">            new CustomEvent(__GARFISH_BEFORE_ROUTER_EVENT__, &#123;</span><br><span class="line">              detail: &#123;</span><br><span class="line">                toRouterInfo: &#123;</span><br><span class="line">                  fullPath: urlAfter,</span><br><span class="line">                  query: parseQuery(location.search),</span><br><span class="line">                  path: getPath(RouterConfig.basename!, urlAfter),</span><br><span class="line">                  state: stateAfter,</span><br><span class="line">                &#125;,</span><br><span class="line">                fromRouterInfo: &#123;</span><br><span class="line">                  fullPath: urlBefore,</span><br><span class="line">                  query: parseQuery(location.search),</span><br><span class="line">                  path: getPath(RouterConfig.basename!, urlBefore),</span><br><span class="line">                  state: stateBefore,</span><br><span class="line">                &#125;,</span><br><span class="line">                eventType: type,</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;),</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">        // window.dispatchEvent(e);</span><br><span class="line">        return res;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    history.pushState = rewrite(&apos;pushState&apos;);</span><br><span class="line">    history.replaceState = rewrite(&apos;replaceState&apos;);</span><br><span class="line"></span><br><span class="line">    // Before the collection application sub routing, forward backward routing updates between child application</span><br><span class="line">    window.addEventListener(</span><br><span class="line">      &apos;popstate&apos;,</span><br><span class="line">      function (event) &#123;</span><br><span class="line">        // Stop trigger collection function, fire again match rendering</span><br><span class="line">        if (event &amp;&amp; typeof event === &apos;object&apos; &amp;&amp; (event as any).garfish)</span><br><span class="line">          return;</span><br><span class="line">        if (history.state &amp;&amp; history.state === &apos;object&apos;)</span><br><span class="line">          delete history.state[__GARFISH_ROUTER_UPDATE_FLAG__];</span><br><span class="line">        window.dispatchEvent(</span><br><span class="line">          new CustomEvent(__GARFISH_BEFORE_ROUTER_EVENT__, &#123;</span><br><span class="line">            detail: &#123;</span><br><span class="line">              toRouterInfo: &#123;</span><br><span class="line">                fullPath: location.pathname,</span><br><span class="line">                query: parseQuery(location.search),</span><br><span class="line">                path: getPath(RouterConfig.basename!),</span><br><span class="line">              &#125;,</span><br><span class="line">              fromRouterInfo: &#123;</span><br><span class="line">                fullPath: RouterConfig.current!.fullPath,</span><br><span class="line">                path: getPath(</span><br><span class="line">                  RouterConfig.basename!,</span><br><span class="line">                  RouterConfig.current!.path,</span><br><span class="line">                ),</span><br><span class="line">                query: RouterConfig.current!.query,</span><br><span class="line">              &#125;,</span><br><span class="line">              eventType: &apos;popstate&apos;,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;),</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">      false,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    window[__GARFISH_ROUTER_FLAG__] = true;</span><br><span class="line">  &#125;</span><br><span class="line">  addRouterListener();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>normalAgent方法的实现，其实就是重写了history.pushState和history.replaceState两个方法，并且会触发一个自定义事件<strong>GARFISH_BEFORE_ROUTER_EVENT</strong>，那么addRouterListener其实就是注册了<strong>GARFISH_BEFORE_ROUTER_EVENT</strong>自定义事件。而initRedirect方法就是初始默认化路由的。无论是normalAgent还是initRedirect，最后都会进入linkTo方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">// packages/router/src/linkTo.ts</span><br><span class="line">export const linkTo = async (&#123;</span><br><span class="line">  toRouterInfo,</span><br><span class="line">  fromRouterInfo,</span><br><span class="line">  eventType,</span><br><span class="line">&#125;: &#123;</span><br><span class="line">  toRouterInfo: RouterInfo;</span><br><span class="line">  fromRouterInfo: RouterInfo;</span><br><span class="line">  eventType: keyof History | &apos;popstate&apos;;</span><br><span class="line">&#125;) =&gt; &#123;</span><br><span class="line">  const &#123;</span><br><span class="line">    current,</span><br><span class="line">    apps,</span><br><span class="line">    deactive,</span><br><span class="line">    active,</span><br><span class="line">    notMatch,</span><br><span class="line">    beforeEach,</span><br><span class="line">    afterEach,</span><br><span class="line">    autoRefreshApp,</span><br><span class="line">  &#125; = RouterConfig;</span><br><span class="line">  const deactiveApps = current!.matched.filter(</span><br><span class="line">    (appInfo) =&gt;</span><br><span class="line">      !hasActive(</span><br><span class="line">        appInfo.activeWhen,</span><br><span class="line">        getPath(appInfo.basename, location.pathname),</span><br><span class="line">      ),</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  // Activate the corresponding application</span><br><span class="line">  const activeApps = apps.filter((appInfo) =&gt; &#123;</span><br><span class="line">    return hasActive(</span><br><span class="line">      appInfo.activeWhen,</span><br><span class="line">      getPath(appInfo.basename, location.pathname),</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  const needToActive = activeApps.filter((&#123; name &#125;) =&gt; &#123;</span><br><span class="line">    return !current!.matched.some((&#123; name: cName &#125;) =&gt; name === cName);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // router infos</span><br><span class="line">  const to = &#123;</span><br><span class="line">    ...toRouterInfo,</span><br><span class="line">    matched: needToActive,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  const from = &#123;</span><br><span class="line">    ...fromRouterInfo,</span><br><span class="line">    matched: deactiveApps,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  await toMiddleWare(to, from, beforeEach!);</span><br><span class="line"></span><br><span class="line">  // Pause the current application of active state</span><br><span class="line">  if (current!.matched.length &gt; 0) &#123;</span><br><span class="line">    await asyncForEach(</span><br><span class="line">      deactiveApps,</span><br><span class="line">      async (appInfo) =&gt;</span><br><span class="line">        await deactive(appInfo, getPath(appInfo.basename, location.pathname)),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setRouterConfig(&#123;</span><br><span class="line">    current: &#123;</span><br><span class="line">      path: getPath(RouterConfig.basename!),</span><br><span class="line">      fullPath: location.pathname,</span><br><span class="line">      matched: activeApps,</span><br><span class="line">      state: history.state,</span><br><span class="line">      query: parseQuery(location.search),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // Within the application routing jump, by collecting the routing function for processing.</span><br><span class="line">  // Filtering gar-router popstate hijacking of the router</span><br><span class="line">  // In the switch back and forth in the application is provided through routing push method would trigger application updates</span><br><span class="line">  // application will refresh when autoRefresh configuration to true</span><br><span class="line">  const curState = window.history.state || &#123;&#125;;</span><br><span class="line">  if (</span><br><span class="line">    eventType !== &apos;popstate&apos; &amp;&amp;</span><br><span class="line">    (curState[__GARFISH_ROUTER_UPDATE_FLAG__] || autoRefreshApp)</span><br><span class="line">  ) &#123;</span><br><span class="line">    callCapturedEventListeners(eventType);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  await asyncForEach(needToActive, async (appInfo) =&gt; &#123;</span><br><span class="line">    // Function using matches character and routing using string matching characters</span><br><span class="line">    const appRootPath = getAppRootPath(appInfo);</span><br><span class="line">    await active(appInfo, appRootPath);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  if (activeApps.length === 0 &amp;&amp; notMatch) notMatch(location.pathname);</span><br><span class="line"></span><br><span class="line">  await toMiddleWare(to, from, afterEach!);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>再归纳一下，有两个中间件可以执行，afterEach和beforeEach，就是在active之前和之后的执行时机。然后主要的就是active了，其实active这个方法，是router插件中，bootstrap钩子里的active方法。到目前为止，我们主应用就run起来了，接下来就是通过路由来show或者hide子应用了。</p><h1 id="路由trigger子应用"><a href="#路由trigger子应用" class="headerlink" title="路由trigger子应用"></a>路由trigger子应用</h1><p>接下来点击vue按钮，展示vue子应用。<br>我们前面已经介绍过了，在normalAgent实现中劫持了history.push方法，那么在进行路由变化时，就会触发自定义事件<strong>GARFISH_BEFORE_ROUTER_EVENT</strong>，然后会再次进入linkTo方法，这个时候needToActive就是true了，会执行active，而active就是router插件中bootstrap的active方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// packages/router/src/index.ts</span><br><span class="line">async function active(appInfo: interfaces.AppInfo, rootPath: string) &#123;</span><br><span class="line">          const &#123; name, cache = true, active &#125; = appInfo;</span><br><span class="line">          if (active) return active(appInfo, rootPath);</span><br><span class="line">          appInfo.rootPath = rootPath;</span><br><span class="line"></span><br><span class="line">          const currentApp = (activeApp = createKey());</span><br><span class="line">          const app = await Garfish.loadApp(appInfo.name, &#123;</span><br><span class="line">            basename: rootPath,</span><br><span class="line">            entry: appInfo.entry,</span><br><span class="line">            cache: true,</span><br><span class="line">            domGetter: appInfo.domGetter,</span><br><span class="line">          &#125;);</span><br><span class="line">          app.appInfo.basename = rootPath;</span><br><span class="line"></span><br><span class="line">          const call = (app: interfaces.App, isRender: boolean) =&gt; &#123;</span><br><span class="line">            if (!app) return;</span><br><span class="line">            const isDes = cache &amp;&amp; app.mounted;</span><br><span class="line">            const fn = isRender</span><br><span class="line">              ? app[isDes ? &apos;show&apos; : &apos;mount&apos;]</span><br><span class="line">              : app[isDes ? &apos;hide&apos; : &apos;unmount&apos;];</span><br><span class="line">            return fn.call(app);</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">          Garfish.apps[name] = app;</span><br><span class="line">          unmounts[name] = () =&gt; call(app, false);</span><br><span class="line"></span><br><span class="line">          if (currentApp === activeApp) &#123;</span><br><span class="line">            await call(app, true);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>这个方法中会有个app，这个app是Garfish类中loadApp方法返回的，那我们看一下返回的这个app是啥：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">// packages/core/src/garfish.ts</span><br><span class="line">async loadApp(</span><br><span class="line">    appName: string,</span><br><span class="line">    optionsOrUrl?: Omit&lt;interfaces.AppInfo, &apos;name&apos;&gt;,</span><br><span class="line">  ): Promise&lt;interfaces.App | null&gt; &#123;</span><br><span class="line">    assert(appName, &apos;Miss appName.&apos;);</span><br><span class="line">    const appInfo = generateAppOptions(appName, this, optionsOrUrl);</span><br><span class="line"></span><br><span class="line">    const asyncLoadProcess = async () =&gt; &#123;</span><br><span class="line">      // Return not undefined type data directly to end loading</span><br><span class="line">      const stop = await this.hooks.lifecycle.beforeLoad.emit(appInfo);</span><br><span class="line">      if (stop === false) &#123;</span><br><span class="line">        warn(`Load $&#123;appName&#125; application is terminated by beforeLoad.`);</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line">      // Existing cache caching logic</span><br><span class="line">      let appInstance: interfaces.App = null;</span><br><span class="line">      const cacheApp = this.cacheApps[appName];</span><br><span class="line">      if (appInfo.cache &amp;&amp; cacheApp) &#123;</span><br><span class="line">        appInstance = cacheApp;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          const [manager, resources, isHtmlMode] = await processAppResources(</span><br><span class="line">            this.loader,</span><br><span class="line">            appInfo,</span><br><span class="line">          );</span><br><span class="line"></span><br><span class="line">          appInstance = new App(</span><br><span class="line">            this,</span><br><span class="line">            appInfo,</span><br><span class="line">            manager,</span><br><span class="line">            resources,</span><br><span class="line">            isHtmlMode,</span><br><span class="line">            appInfo.customLoader,</span><br><span class="line">          );</span><br><span class="line"></span><br><span class="line">          // The registration hook will automatically remove the duplication</span><br><span class="line">          for (const key in this.plugins) &#123;</span><br><span class="line">            appInstance.hooks.usePlugin(this.plugins[key]);</span><br><span class="line">          &#125;</span><br><span class="line">          if (appInfo.cache) &#123;</span><br><span class="line">            this.cacheApps[appName] = appInstance;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">          __DEV__ &amp;&amp; warn(e);</span><br><span class="line">          this.hooks.lifecycle.errorLoadApp.emit(e, appInfo);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      await this.hooks.lifecycle.afterLoad.emit(appInfo, appInstance);</span><br><span class="line">      return appInstance;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    if (!this.loading[appName]) &#123;</span><br><span class="line">      this.loading[appName] = asyncLoadProcess().finally(() =&gt; &#123;</span><br><span class="line">        this.loading[appName] = null;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return this.loading[appName];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>这个函数稍微有点长，我总结一下，this.loading是为了保存当前要加载的app，通过一个asyncLoadProcess返回，这里注意一下，asyncLoadProcess是async函数，没有await，所以返回的是一个Promise对象，而resolve的是appInstance，在asyncLoadProcess中，也是执行了app生命周期中的几个钩子。我们再简单了解一下App类是什么样的，由于代码太多，我们只列个大概，并且说明用途即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">// packages/core/src/module/app.ts</span><br><span class="line">export class App &#123;</span><br><span class="line">  public appId = appId++;</span><br><span class="line">  public display = false;</span><br><span class="line">  public mounted = false;</span><br><span class="line">  public esModule = false;</span><br><span class="line">  public strictIsolation = false;</span><br><span class="line">  public name: string;</span><br><span class="line">  public isHtmlMode: boolean;</span><br><span class="line">  public global: any = window;</span><br><span class="line">  public appContainer: HTMLElement;</span><br><span class="line">  public cjsModules: Record&lt;string, any&gt;;</span><br><span class="line">  public htmlNode: HTMLElement | ShadowRoot;</span><br><span class="line">  public customExports: Record&lt;string, any&gt; = &#123;&#125;; // If you don&apos;t want to use the CJS export, can use this</span><br><span class="line">  public sourceList: Array&lt;&#123; tagName: string; url: string &#125;&gt; = [];</span><br><span class="line">  public appInfo: AppInfo;</span><br><span class="line">  public hooks: interfaces.AppHooks;</span><br><span class="line">  public provider: interfaces.Provider;</span><br><span class="line">  public entryManager: TemplateManager;</span><br><span class="line">  public appPerformance: SubAppObserver;</span><br><span class="line">  /** @deprecated */</span><br><span class="line">  public customLoader: CustomerLoader;</span><br><span class="line"></span><br><span class="line">  private active = false;</span><br><span class="line">  private mounting = false;</span><br><span class="line">  private unmounting = false;</span><br><span class="line">  private context: Garfish;</span><br><span class="line">  private resources: interfaces.ResourceModules;</span><br><span class="line">  // Environment variables injected by garfish for linkage with child applications</span><br><span class="line">  private globalEnvVariables: Record&lt;string, any&gt;;</span><br><span class="line">  // es-module save lifeCycle to appGlobalId，appGlobalId in script attr</span><br><span class="line">  private appGlobalId: string;</span><br><span class="line"></span><br><span class="line">  constructor(</span><br><span class="line">    context: Garfish,</span><br><span class="line">    appInfo: AppInfo,</span><br><span class="line">    entryManager: TemplateManager,</span><br><span class="line">    resources: interfaces.ResourceModules,</span><br><span class="line">    isHtmlMode: boolean,</span><br><span class="line">    customLoader: CustomerLoader,</span><br><span class="line">  ) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get rootElement() &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getProvider() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  execScript(</span><br><span class="line">    code: string,</span><br><span class="line">    env: Record&lt;string, any&gt;,</span><br><span class="line">    url?: string,</span><br><span class="line">    options?: &#123; async?: boolean; noEntry?: boolean &#125;,</span><br><span class="line">  ) &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // `vm sandbox` can override this method</span><br><span class="line">  runCode(</span><br><span class="line">    code: string,</span><br><span class="line">    env: Record&lt;string, any&gt;,</span><br><span class="line">    url?: string,</span><br><span class="line">    options?: &#123; async?: boolean; noEntry?: boolean &#125;,</span><br><span class="line">  ) &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async show() &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  hide() &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async mount() &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  unmount() &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getExecScriptEnv(noEntry: boolean) &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Performs js resources provided by the module, finally get the content of the export</span><br><span class="line">  async compileAndRenderContainer() &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private canMount() &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // If asynchronous task encountered in the rendering process, such as triggering the beforeEval before executing code,</span><br><span class="line">  // after the asynchronous task, you need to determine whether the application has been destroyed or in the end state.</span><br><span class="line">  // If in the end state will need to perform the side effects of removing rendering process, adding a mount point to a document,</span><br><span class="line">  // for example, execute code of the environmental effects, and rendering the state in the end.</span><br><span class="line">  private stopMountAndClearEffect() &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Calls to render do compatible with two different sandbox</span><br><span class="line">  private callRender(provider: interfaces.Provider, isMount: boolean) &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Call to destroy do compatible with two different sandbox</span><br><span class="line">  private callDestroy(provider: interfaces.Provider, isUnmount: boolean) &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Create a container node and add in the document flow</span><br><span class="line">  // domGetter Have been dealing with</span><br><span class="line">  private async addContainer() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private async renderTemplate() &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private async checkAndGetProvider() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总结起来，这个App类提供的能力如下：</p><ol><li>提供静态资源，HTML、CSS、js的结构。</li><li>可以在CJS中提取或者推导出子应用的 provider。<br>3.通过execCode传入模块的CJS规范、require、exports等环境变量实现对外共享</li><li>触发渲染：应用相关节点放置在文档流中，依次执行应用脚本，最终渲染功能，执行子应用提供完整的应用独立运行时执行。</li><li>触发销毁：执行子应用程序的销毁功能，应用子节点从文档流中移除。<br>再回到active方法中，最核心的地方是call方法，最后调用了App中的show、mount、hide、unmount方法。show和hide可以理解为之前已经加载过了，就是show和hide一下，mount是要和unmount是挂载和卸载，我们这里主要以mount为例，看一下是如何加载子应用环境并且加载子应用的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// packages/core/src/module/app.ts</span><br><span class="line">async mount() &#123;</span><br><span class="line">    if (!this.canMount()) return false;</span><br><span class="line">    this.hooks.lifecycle.beforeMount.emit(this.appInfo, this, false);</span><br><span class="line"></span><br><span class="line">    this.active = true;</span><br><span class="line">    this.mounting = true;</span><br><span class="line">    try &#123;</span><br><span class="line">      // add container and compile js with cjs</span><br><span class="line">      const asyncJsProcess = await this.compileAndRenderContainer();</span><br><span class="line"></span><br><span class="line">      // Good provider is set at compile time</span><br><span class="line">      const provider = await this.getProvider();</span><br><span class="line">      // Existing asynchronous functions need to decide whether the application has been unloaded</span><br><span class="line">      if (!this.stopMountAndClearEffect()) return false;</span><br><span class="line"></span><br><span class="line">      this.callRender(provider, true);</span><br><span class="line">      this.display = true;</span><br><span class="line">      this.mounted = true;</span><br><span class="line">      this.context.activeApps.push(this);</span><br><span class="line">      this.hooks.lifecycle.afterMount.emit(this.appInfo, this, false);</span><br><span class="line"></span><br><span class="line">      await asyncJsProcess;</span><br><span class="line">      if (!this.stopMountAndClearEffect()) return false;</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      this.entryManager.DOMApis.removeElement(this.appContainer);</span><br><span class="line">      this.hooks.lifecycle.errorMountApp.emit(e, this.appInfo);</span><br><span class="line">      return false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      this.mounting = false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol><p>大概意思就是说，添加了一个子应用容器，拿到子应用资源（主要通过fetch方式获取，继续深挖compileAndRenderContainer就知道了），然后获取子应用export出来的provider，最后执行代码，子应用就成功展示出来了。<br>再说一下子应用的代码执行，子应用中如果使用了window，那么在子应用接入主应用后，如果不做任何处理，那么两个应用的window是一个，这样就会有逻辑问题，为了解决这个问题，就有了沙箱概念。garfish中提供了两种沙箱机制：vm沙箱和snapshot沙箱。<br>我们可以看一个简单的vm沙箱原理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const varBox = &#123;&#125;;</span><br><span class="line">const fakeWindow = new Proxy(window, &#123;</span><br><span class="line">    get(target, key) &#123;</span><br><span class="line">        return varBox[key] || window[key]</span><br><span class="line">    &#125;,</span><br><span class="line">    set(target, key, value) &#123;</span><br><span class="line">        varBox[key] = value;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">const fn = new Function(&apos;window&apos;, code);</span><br><span class="line">fn(fakeWindow);</span><br></pre></td></tr></table></figure></p><p>主要是通过es6中proxy实现的，当然这只是一个原理性代码，实际中还会兼容很多case。其实在最初注册garfish插件的时候，初始化garfish实例的时候，就初始化了vm沙箱和snapshot沙箱。我们前面也说了，在每个插件中都会定义一些生命周期的钩子方法，其实在Garfish.loadApp的时候，就在App上挂载了vmSandbox属性，在后续的子应用执行代码时，环境都是在沙箱中执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h1&gt;&lt;p&gt;首先，可以在github上把代码拉到本地，地址为：&lt;a href=&quot;https://github.com/modern-js
      
    
    </summary>
    
      <category term="前端" scheme="https://skhon.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Web" scheme="https://skhon.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>【基础架构】架构师的职责</title>
    <link href="https://skhon.github.io/2021/12/20/architecture/base/"/>
    <id>https://skhon.github.io/2021/12/20/architecture/base/</id>
    <published>2021-12-20T13:07:00.774Z</published>
    <updated>2022-05-14T12:00:46.993Z</updated>
    
    <content type="html"><![CDATA[<p>经常有人问，架构师是干嘛的？那么今天谈谈，架构师的职责是什么。</p><h3 id="什么是架构"><a href="#什么是架构" class="headerlink" title="什么是架构"></a>什么是架构</h3><p>谈架构师职责之前，我们要先了解什么是架构。那么提到架构，很多人也会提到框架这个概念，多数情况下，我们都不怎么区分这两个概念，如果细分一下的话，架构偏向于结构，框架偏向于规范。比如linux中有架构，window有架构，微信有架构，淘宝也有架构…那么框架呢，比如一款mvvm框架，mvc框架，使用这个框架需要遵循一些规定好的设计。</p><p>我们这里主要说一下架构吧，以微信为例，一款app，它其实是分很多模块的，比如好友模块，朋友圈模块，消息模块等，而朋友圈模块又分为留言模块，点赞模块，发表模块等。架构就是说，这些不同的模块如何的各司其职，又能如何的互相配合，如果要增加一个摇一摇模块，如何能够扩展方便。把这些所有因素都考虑进来，最后能够组装在一起的能力，就是架构能力，整个系统的所有组成统一叫做架构。感觉还是有点绕。。。不管了，我觉得能够解决业务痛点，使得业务能够做到高性能、高可用、易扩展、成本低、安全高…，说白了就是能解决掉业务排在前面一半的痛点，就是牛逼的架构师。</p><h3 id="为什么需要架构"><a href="#为什么需要架构" class="headerlink" title="为什么需要架构"></a>为什么需要架构</h3><p>大家有没有发现，一般小公司没有架构师这个职位，只有达到一定量级才会有架构师，因为小公司不需要架构，10个人开个会碰一碰，你做这个，我做这个，撸起袖子写代码，尽快上线，比花时间搞架构有意义。你以为淘宝一开始就搞的这么牛吗？不是的，淘宝第一版是买的！当年杭州马在2003年的时候，4月7号决定要做淘宝，要求5月10号上线，要是你想着搞架构，黄花菜都凉了，基于当时公司、市场情况，只要买一个是最快的，当然要考虑买一个什么样的，买一个轻量的还是买个复杂的，各有优势，但是基于后续可能要持续发展，就买了个轻量的，方便后续二次开发。等到了后续，业务大爆发，当前项目承载不了那么高的流量，才开始搞架构。所以，好的架构都是业务逼出来的。如果架构脱离业务，那没有太大的意义。</p><p>回到主题，我们为什么需要架构，我理解的架构就是为了解决复杂业务中遇到的问题。</p><h3 id="架构要做什么"><a href="#架构要做什么" class="headerlink" title="架构要做什么"></a>架构要做什么</h3><p>我们上面也说到了，当业务发展一定程度时，由于市场需求、公司老板要求等，必须要对业务进行优化，可能因为旧结构会有一些问题，比如难扩张，加一个新需求，依赖的东西太多，人员成本大，也可以是用户量急剧上升，需要承载更高的qps等，那么架构要做的，我这里整理了几个方面：高性能、高可用、可扩展、低成本、高安全，当然还有很多，但多数的复杂业务都会遇到这几个问题。</p><h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><p>之前做过一个bff框架，支持公司内部服务，当时一台8核32G服务器，裸压hello world，记得qps最高压到了2500。记得当时公司有个活动，预计当天参与人数会到20万，qps峰值保险一点就是20w了，那么如何让这个qps只能到2500的框架支持这么多的用户量呢？最简单的办法也是最合适的，用机器的数量来提升qps的上限，一台机器可以承载2500的qps，那就操作20w/2500多台机器，当然由于目前虚拟化技术等实现，可能很多机器是虚拟机，所有，真实的服务器也可能不需要那么多。这就是一个简单的用量来提升性能的方式。</p><p>当然，高性能，也会体现在其他方面，比如一些调度算法、负载均衡等，都是提升高性能的方式，好的调度算法，也能减少一些资源都浪费。</p><h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><p>我们还以我做的那个bff框架为例，说白了，业务方用了你的框架，上线后，发现程序经常崩溃，排查原因还非常困难，日志难找。这就说明，你这个架构设计的有问题。那么如何做到高可用呢，首先作为一个架构师，妳得有一定都预测性，可能会出现什么情况，如果出了什么情况你有什么备选方案，可以让业务还能够稳定运行，不被用户察觉的情况下，业务不受影响。记得之前出现过一个案例，线上服务有时候会经常莫名重启，后来经排查发现，在一个异步操作里，抛了一个异常，但是这个异常没有被catch到，导致进程直接退出了，退出后，由于机器上有保活机制，进程又被拉起来了，这就出现了服务重启的情况。最后我做了一个兜底的方案，在进程中监听了uncaughtException事件，防止异常退出。</p><p>另外很多情况需要我们考虑，比如线上服务重启，有一段短暂的事件，请求是打不进来的，那如何解决这段时间的服务不可用对用户的影响呢，那就可以做到平滑重启，多个进程配合就可以做到，这些都是需要架构师要想的，再比如，有一些服务是链接ElasticSearch（后面简称es）的，一般es都是部署到公司特定的机器上，如果某个时刻es挂了，你的服务就会受到影响，这个也是你需要考虑的，如果es挂了，你得有降级方案，比如可以熔断，数据拿备机数据。</p><p>总之，高可用就是要尽可能的想到所有线上可能遇到的各种问题，你想，阿里双11前，都要突然断电，就是为了验证服务的高可用。</p><h3 id="可扩展"><a href="#可扩展" class="headerlink" title="可扩展"></a>可扩展</h3><p>这个大家应该也容易理解，服务的升级和迭代，有时候是需要在某一些能力做扩展的，还以bff框架为例，多数通用的中间间，我们一般都内置到框架里了，但是有些业务，需要自定义中间件，那就需要框架本身暴露出一个口子，用来用户的自定义扩展。如果一个bff框架没有可扩展功能，给你用的话，我估计你也不想用。所以可扩展也是一个用户体验到问题。再往大一点产品讲，大家都在用微信，如果微信哪天在朋友圈做一个新功能，比如要做广告，总不能把朋友圈整体都要搞一下把，这个成本也太大了。另外大家在微信的设置里，可以看到有一个发现页的设置，里面可以动态关闭展示你喜欢的功能，这就是可扩展性。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>其他还有很多因素需要架构师考虑，反正架构师的职责就是为了业务的高效、稳定、安全等考虑，脱离业务的架构师，不是好架构师。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;经常有人问，架构师是干嘛的？那么今天谈谈，架构师的职责是什么。&lt;/p&gt;
&lt;h3 id=&quot;什么是架构&quot;&gt;&lt;a href=&quot;#什么是架构&quot; class=&quot;headerlink&quot; title=&quot;什么是架构&quot;&gt;&lt;/a&gt;什么是架构&lt;/h3&gt;&lt;p&gt;谈架构师职责之前，我们要先了解什么是架
      
    
    </summary>
    
      <category term="架构" scheme="https://skhon.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="Architecture" scheme="https://skhon.github.io/tags/Architecture/"/>
    
  </entry>
  
  <entry>
    <title>【面试总结】谈谈我喜欢的候选人</title>
    <link href="https://skhon.github.io/2021/12/17/interview/mymind/"/>
    <id>https://skhon.github.io/2021/12/17/interview/mymind/</id>
    <published>2021-12-17T08:42:03.628Z</published>
    <updated>2022-05-14T12:01:05.472Z</updated>
    
    <content type="html"><![CDATA[<p>其实作为面试官有几年了，在第一家公司2016年的时候，就开始这方面工作了，这几年的面试经历中，遇到的多数候选人普普通通，当然也遇到过优秀的，但是非常少。其实作为面试官，我是非常不赞成抛开简历中的项目，直接各种八股文去考察候选人，这样的面试是片面的，还有一些面试官，也是抛开候选人简历，只问面试官自己会的。我觉得像这些面试官，他本身的技能就不是很扎实，不是合格的面试官，但是有很多时候，公司需要大量招人，就会让一些级别不高的同学也去做面试官，就会导致一些问题。那么接下来我就谈谈，我心目中优秀的候选人，是什么样的。</p><h3 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h3><p>简历很重要，我了解候选人的整体情况，第一印象都来自于候选人的简历。简历如果没有亮点，按照我的经验，多少情况最终的结果都是fail。我们先看看千篇一律的简历，如下：<br><img src="/images/interview/jianli1.png" width="50%"><br>这个候选人，工作4年，其实也不短，专业技能写的很泛泛，面比较广，这些技能都学的怎么样，通过简历还是看不出来，需要面试中沟通。另外再看项目，就是普通的前端项目，也看不到任何的难点和亮点。所以，像这种简历，第一印象都不是很好，如果学校、工作经历都不好的情况下，简历基本过不了。<br>那么什么样的简历是有亮点的呢？可以看一下这个：<br><img src="/images/interview/jianli2.png" width="50%"><br>首先个人优势比较突出，是一个开源项目的主要负责人，并且是vue-router的Contributor，另外在极客帮做过技术分享，这几点就很多人做不到的了。这就是亮点！我们为什么喜欢对开源社区有贡献的候选人呢，因为一般开源社区中比较知名的框架或者技术都是有一定难度的，都是从架构设计到实现，是值得我们很多人去学习的，所以它出名，而对于这些优秀的开源项目有共享的同学，他们对其实现肯定是了解甚至掌握的，而这就是体现出了候选人的实力。<br>一个人的亮点可以是方方面面的，比如曾经写过《xxx》书籍，在公司申请过《xxx》专利，甚至你在leetcode上涮了200道题都是你的亮点，如果你说我就是没有亮点，那我觉得就是懒，行动上和思想上都懒。那为啥优秀的那个人不可以是你呢？</p><h3 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h3><p>我一般在面试中，除了计算机基础之外，基本上都是会按照候选人的简历去聊，由浅入深，探索候选人的深度，比如候选人主要用的技术栈是react，那我会先聊一下react的一些特性，比如生命周期、一些副作用的操作在哪里写比较合适。再往深聊，就会问一些react优化的问题，hooks的使用。如果候选人答的不错，我还会往原理上聊，比如如果要实现一个xxx需求，如何写一个自定义hooks。再往深聊，就会聊到react设计、源码这部分，如果候选人能把所有问题都答的非常好，那就是牛批的候选人。这是深度。另外也会探索一下候选人的广度，比如跳出浏览器会问一些其他的技能，比如nodejs、数据库、运维相关的，如果候选人平时后端需求也写，那可以理解为是一个全栈工程师，这样的候选人有个优势就是面对一些复杂的场景需求时，可以自己搞定，进来也好带，不用特别费劲。如果技术的深度和广度都没问题的话，我可能还会问一些解决方案的思路，比如一些工程化问题，如何分析公共依赖，确定前端页面的回归范围、如何统计相似函数以提升代码质量等。总之我的面试中，可能会问很多原理性问题，如果我们聊的来，那我觉得你就是我喜欢的那种候选人。</p><h3 id="代码能力"><a href="#代码能力" class="headerlink" title="代码能力"></a>代码能力</h3><p>我的面试中，一般都会有代码题，题目不难，都是leetcode中简单题目。考代码能力的主要目的，不是为了考的你不会，而是看你的代码能力过不过关，主要看你的代码速度、代码思路、代码规范等，通过你写代码，大概能了解你的代码能力，甚至你的性格。因为个别候选人，理论知识确实不错，进来写项目需求的时候，巨慢，这种就是代码不过关导致的问题。</p><h3 id="软性技能"><a href="#软性技能" class="headerlink" title="软性技能"></a>软性技能</h3><p>软性技能的话，对于候选人来说，可能比较好答一些，但是也分好坏。这个就是主要观察一些候选人的沟通能力、性格之类的，可能更具候选人的性格，也需要安排不同的工作，比如内向一点都，可能会擅长偏技术攻关之类的工作，因为偏内向的人，一般都有一定的耐力或者耐性。对于乐观开朗一点的候选人，会适合做一些需求联动的工作，因为他擅于和各种人（测试、产品）沟通，也会促进工作更好的完成。<br>另外就是看看他的一些学习渠道，比如喜欢看凯源的一些技术或者框架，那可以看到这样的候选人对技术还是有热情的。喜欢看书、看博客，这样的候选人也是喜欢学习的，像这样的候选人，我也比较青睐。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我觉得以上几个方面做的不错的同学，我觉得就是我喜欢的那类候选人。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;其实作为面试官有几年了，在第一家公司2016年的时候，就开始这方面工作了，这几年的面试经历中，遇到的多数候选人普普通通，当然也遇到过优秀的，但是非常少。其实作为面试官，我是非常不赞成抛开简历中的项目，直接各种八股文去考察候选人，这样的面试是片面的，还有一些面试官，也是抛开候
      
    
    </summary>
    
      <category term="面试" scheme="https://skhon.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Interview" scheme="https://skhon.github.io/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>【安全防御】原型链攻击</title>
    <link href="https://skhon.github.io/2021/12/17/security/prototype/"/>
    <id>https://skhon.github.io/2021/12/17/security/prototype/</id>
    <published>2021-12-17T07:32:15.614Z</published>
    <updated>2022-05-14T12:00:16.838Z</updated>
    
    <content type="html"><![CDATA[<p>安全问题是公司非常重视的问题，但是在我面试过程中，很多候选人只知道xss、csrf这两种，因为多数面经中，只会提到这两种。可以看到，前端工程师在平时的开发中，还是很少考虑安全问题的。由于本人在公司负责工程化建设相关工作，会涉及到项目的安全漏洞检测，所以后续多写一些相关的文章。<br>今天聊的是原型链污染攻击问题，我们先以一个非常简单的程序入手，我们知道在JavaScript中，一个对象有一个<strong>proto</strong>属性，它是指向Object.prototype的，像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;;</span><br><span class="line">console.log(obj.__proto__ === Object.prototype); // true</span><br></pre></td></tr></table></figure></p><p>有了这个前置知识后，大家可以看下面的程序会输出什么。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;;</span><br><span class="line">obj.__proto__.name = &apos;obj&apos;;</span><br><span class="line">console.log(obj.name); // 这个很明显，是obj</span><br><span class="line"></span><br><span class="line">let newObj = &#123;&#125;;</span><br><span class="line">console.log(newObj.name); // ???</span><br></pre></td></tr></table></figure></p><p>执行后，你会发现，newObj.name也为obj！什么情况，我新定义的newObj对象，居然可以输出name属性？？没错，这就是原型链污染。<strong>原因就是：改obj.<strong>proto</strong>,其实就是改了Object.prototype,而newObj的<strong>proto</strong>也是指向Object.prototype，这样Object的原型对象被偷偷改了，导致后面的对象不知道，这就是原型链污染的实质</strong></p><p>这种漏洞一般会出现在类似merge操作中，而很多工具库就提供merge方法，之前lodash就存在过原型链漏洞问题，后来修复了，如果存在漏洞，有些人就会故意往原型链上merge一些具有危险的属性，给系统带来危机。我们可以看一个简单的merge函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function merge(target, source) &#123;</span><br><span class="line">  for (let key in source) &#123;</span><br><span class="line">    if (key in source &amp;&amp; key in target) &#123;</span><br><span class="line">      merge(target[key], source[key])</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      target[key] = source[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们来验证一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let o1 = &#123;&#125;</span><br><span class="line">let o2 = &#123;a: 1, &quot;__proto__&quot;: &#123;b: 2&#125;&#125;</span><br><span class="line">merge(o1, o2)</span><br><span class="line">console.log(o1.a, o1.b) // 1 2</span><br><span class="line"></span><br><span class="line">o3 = &#123;&#125;</span><br><span class="line">console.log(o3.b) // undefined</span><br></pre></td></tr></table></figure></p><p>我们可以看到这么搞，是没有污染的，原因是o2这么定义，<strong>proto</strong>会直接放在原型链上，不会当作o2的属性，可以这么理解：<br>o2.<strong>proto</strong> ==&gt; { b: 2, <strong>proto</strong>: Object.prototype}，而for in是能够遍历到原型链上的属性，所以会直接在o1中增加属性b为2。加入这么写会是啥样，看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let o1 = &#123;&#125;</span><br><span class="line">let o2 = JSON.parse(&apos;&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;b&quot;: 2&#125;&#125;&apos;)</span><br><span class="line">merge(o1, o2)</span><br><span class="line">console.log(o1.a, o1.b) // 1 2</span><br><span class="line"></span><br><span class="line">o3 = &#123;&#125;</span><br><span class="line">console.log(o3.b) // 2</span><br></pre></td></tr></table></figure></p><p>这么写就污染了，因为这么写，<strong>proto</strong>会当作o2的一个属性，就是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">o2 = &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  __proto__: &#123;</span><br><span class="line">    b: 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这么会让o1.<strong>proto</strong> = {b: 2},而o1的<strong>proto</strong>就是Object.prototype，随意就会导致Object的原型对象被悄悄的改了。</p><p>如何缓解原型链漏洞呢？这里提供了几种方式可参考：</p><blockquote><p>Object.freeze 将缓解几乎所有情况。冻结 Object 阻止添加新的 Prototype。<br>使用模式验证确保 JSON 数据包含预期属性，从而删除 JSON 中出现的 <em>proto</em>。<br>使用映射原语。它在 EcmaScript6 标准中引入，目前在 NodeJS 环境中备受支持。<br>使用 Object.create(null) 函数创建的Objects 不具有 <em>proto</em> 属性。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;安全问题是公司非常重视的问题，但是在我面试过程中，很多候选人只知道xss、csrf这两种，因为多数面经中，只会提到这两种。可以看到，前端工程师在平时的开发中，还是很少考虑安全问题的。由于本人在公司负责工程化建设相关工作，会涉及到项目的安全漏洞检测，所以后续多写一些相关的文章
      
    
    </summary>
    
      <category term="安全" scheme="https://skhon.github.io/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Security" scheme="https://skhon.github.io/tags/Security/"/>
    
  </entry>
  
  <entry>
    <title>【质量建设】代码覆盖率</title>
    <link href="https://skhon.github.io/2021/12/16/engineering/coverage/"/>
    <id>https://skhon.github.io/2021/12/16/engineering/coverage/</id>
    <published>2021-12-16T12:50:04.517Z</published>
    <updated>2022-05-14T11:58:51.949Z</updated>
    
    <content type="html"><![CDATA[<p>最近为了防止因为漏测导致线上问题，做了一些统计测试覆盖率的工作。这个过程中用到了一个检测代码覆盖率的工具，叫：istanbul。它主要能够从几个维度来分析对应的覆盖率。比如下面几个指标：</p><blockquote><ul><li>行覆盖率（line coverage）：是否每一行都执行了？</li><li>函数覆盖率（function coverage）：是否每个函数都调用了？</li><li>分支覆盖率（branch coverage）：是否每个if代码块都执行了？</li><li>语句覆盖率（statement coverage）：是否每个语句都执行了？</li></ul></blockquote><p>使用起来也比较简单：</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Istanbul 是一个 npm 模块，安装非常简单，就一行命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g istanbul</span><br></pre></td></tr></table></figure></p><h3 id="覆盖率测试"><a href="#覆盖率测试" class="headerlink" title="覆盖率测试"></a>覆盖率测试</h3><p>来看一个例子，怎么使用 Istanbul 。下面是脚本文件 simple.js 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">var b = 1;</span><br><span class="line">if ((a + b) &gt; 2) &#123;</span><br><span class="line">  console.log(&apos;more than two&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 istanbul cover 命令，就能得到覆盖率。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ istanbul cover simple.js</span><br><span class="line"></span><br><span class="line">===== Coverage summary =====</span><br><span class="line">Statements   : 75% ( 3/4 )</span><br><span class="line">Branches     : 50% ( 1/2 )</span><br><span class="line">Functions    : 100% ( 0/0 )</span><br><span class="line">Lines        : 75% ( 3/4 )</span><br><span class="line">=============================</span><br></pre></td></tr></table></figure></p><p>返回结果显示，simple.js 有4个语句（statement），执行了3个；有2个分支（branch），执行了1个；有0个函数，调用了0个；有4行代码，执行了3行。</p><p>这条命令同时还生成了一个 coverage 子目录，其中的 coverage.json 文件包含覆盖率的原始数据，coverage/lcov-report 是可以在浏览器打开的覆盖率报告，其中有详细信息，到底哪些代码没有覆盖到。</p><h3 id="覆盖率门槛"><a href="#覆盖率门槛" class="headerlink" title="覆盖率门槛"></a>覆盖率门槛</h3><p>完美的覆盖率当然是 100%，但是现实中很难达到。需要有一个门槛，衡量覆盖率是否达标。</p><p>istanbul check-coverage 命令用来设置门槛，同时检查当前代码是否达标。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ istanbul check-coverage --statement 90</span><br><span class="line"></span><br><span class="line">ERROR: Coverage for statements (75%) does not meet global threshold (90%)</span><br></pre></td></tr></table></figure><p>上面命令设置语句覆盖率的门槛是 90% ，结果就报错了，因为实际覆盖率只有75%。</p><p>除了百分比门槛，我们还可以设置绝对值门槛，比如只允许有一个语句没有被覆盖到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ istanbul check-coverage --statement -1</span><br></pre></td></tr></table></figure><p>上面命令使用负数，表示绝对值门槛。这样一来，上面的例子就通过了覆盖率测试，不会再报错了。</p><p>百分比门槛和绝对值门槛，可以结合使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ istanbul check-coverage --statement -5 --branch -3 --function 100</span><br></pre></td></tr></table></figure><p>上面命令设置了3个覆盖率门槛：5个语句、3个 if 代码块、100%的函数。注意，这三个门槛是”与”（and）的关系，只要有一个没有达标，就会报错。</p><h3 id="与测试框架的结合"><a href="#与测试框架的结合" class="headerlink" title="与测试框架的结合"></a>与测试框架的结合</h3><p>实际开发时，istanbul 总是与测试框架结合使用，下面以常用的 Mocha 框架为例。</p><p>sqrt.js 是一个计算平方根的脚本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var My = &#123;</span><br><span class="line">  sqrt: function(x) &#123;</span><br><span class="line">    if (x &lt; 0) throw new Error(&quot;负值没有平方根&quot;);</span><br><span class="line">      return Math.exp(Math.log(x)/2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = My;</span><br></pre></td></tr></table></figure><p>它的测试脚本 test.sqrt.js 放在 test 子目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var chai = require(&apos;chai&apos;);</span><br><span class="line">var expect = chai.expect;</span><br><span class="line">var My = require(&apos;../sqrt.js&apos;);</span><br><span class="line"></span><br><span class="line">describe(&quot;sqrt&quot;, function() &#123;</span><br><span class="line"></span><br><span class="line">  it(&quot;4的平方根应该等于2&quot;, function() &#123;</span><br><span class="line">    expect(My.sqrt(4)).to.equal(2);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(&quot;参数为负值时应该报错&quot;, function() &#123;</span><br><span class="line">    expect(function()&#123; My.sqrt(-1); &#125;).to.throw(&quot;负值没有平方根&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后，执行下面的命令得到代码覆盖率。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ istanbul cover _mocha</span><br><span class="line">// or</span><br><span class="line">$ istanbul cover _mocha test/test.sqrt.js</span><br><span class="line"></span><br><span class="line">  sqrt</span><br><span class="line">    ✓ 4的平方根应该等于2 </span><br><span class="line">    ✓ 参数为负值时应该报错 </span><br><span class="line"></span><br><span class="line">  2 passing (7ms)</span><br><span class="line"></span><br><span class="line">===== Coverage summary =====</span><br><span class="line">Statements   : 100% ( 5/5 )</span><br><span class="line">Branches     : 100% ( 2/2 )</span><br><span class="line">Functions    : 100% ( 1/1 )</span><br><span class="line">Lines        : 100% ( 4/4 )</span><br><span class="line">=============================</span><br></pre></td></tr></table></figure><p>上面命令中，istanbul cover 命令后面跟的是 _mocha 命令，前面的下划线是不能省略的。</p><p>因为，mocha 和 _mocha 是两个不同的命令，前者会新建一个进程执行测试，而后者是在当前进程（即 istanbul 所在的进程）执行测试，只有这样， istanbul 才会捕捉到覆盖率数据。其他测试框架也是如此，必须在同一个进程执行测试。</p><p>如果要向 mocha 传入参数，可以写成下面的样子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ istanbul cover _mocha -- tests/test.sqrt.js -R spec</span><br></pre></td></tr></table></figure></p><p>上面命令中，两根连词线后面的部分，都会被当作参数传入 Mocha 。如果不加那两根连词线，它们就会被当作 istanbul 的参数（参考链接1，2）。</p><p>如果想在浏览器运行 Istanbul ，可以参考这篇文章。</p><p>五、忽略某些代码<br>istanbul 提供注释语法，允许某些代码不计入覆盖率。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var object = parameter || /* istanbul ignore next */ &#123;&#125;;</span><br></pre></td></tr></table></figure><p>上面代码是为 object 指定默认值（一个空对象）。如果由于种种原因，没有为 object 为空对象的情况写测试，可以用注释，不将这种情况计入覆盖率。注意，注释要写在”或”运算符的后面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* istanbul ignore if  */</span><br><span class="line">if (hardToReproduceError)) &#123;</span><br><span class="line">    return callback(hardToReproduceError);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的 if 语句块，在计算覆盖率的时候会被忽略。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近为了防止因为漏测导致线上问题，做了一些统计测试覆盖率的工作。这个过程中用到了一个检测代码覆盖率的工具，叫：istanbul。它主要能够从几个维度来分析对应的覆盖率。比如下面几个指标：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;行覆盖率（line coverag
      
    
    </summary>
    
      <category term="工程化建设" scheme="https://skhon.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%BB%BA%E8%AE%BE/"/>
    
    
      <category term="Engineering" scheme="https://skhon.github.io/tags/Engineering/"/>
    
  </entry>
  
</feed>
