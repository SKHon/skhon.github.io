<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>前端架构之路</title>
  <icon>https://www.gravatar.com/avatar/bafeed710faffad62197c060e0e91fda</icon>
  <subtitle>我宁愿犯错，也不想什么都不做</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://skhon.github.io/"/>
  <updated>2022-01-07T09:35:52.880Z</updated>
  <id>https://skhon.github.io/</id>
  
  <author>
    <name>liujianghong</name>
    <email>ljhtianhong@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>搭一个小窝</title>
    <link href="https://skhon.github.io/2022/01/07/my-heart/yongzhengwangchao/"/>
    <id>https://skhon.github.io/2022/01/07/my-heart/yongzhengwangchao/</id>
    <published>2022-01-07T09:23:34.732Z</published>
    <updated>2022-01-07T09:35:52.880Z</updated>
    
    <content type="html"><![CDATA[<h1 id="读后感"><a href="#读后感" class="headerlink" title="读后感"></a>读后感</h1><p>读二月河前辈的《康熙王朝》《雍正王朝》，常常使人反思。康熙一朝凡经六十余年，整整一个甲子年。内平鳌拜掌实权，再平三藩稳定天下，接着治黄河收台湾西征葛尔丹，种种大事不胜枚举。可以说，康熙大帝在少年青年壮年之际确实是千古一帝。可是到了老年，却没有在几个儿子的管理上，最重要的是在接班人的管理和选择上却真的是种种风波，九子夺嫡，那真的是你方唱罢我登场，闹了个不亦乐乎。</p><p>今天咱们不说细节，就以《雍正王朝》这部剧来说说为何最后是四王爷胤禛一举夺嫡顺利成为接班人。</p><p>在接班人的争夺上，其实每个皇子都是有机会的。大阿哥年龄最长凭着当年跟随皇父西征的战功，是深得康熙信任的。二阿哥，多年的太子，党羽众多，只要处理好错综复杂的各种关系尤其是处好他这“二把手”和“一把手”的关系，更是稳稳的未来皇上。三阿哥，凭着自身才学一门心思编纂书籍也是得皇上信赖。四王爷“冷面王爷”反而看上去是机会最小的，毕竟在朝臣中名声最差得罪人最多，就连八王爷最初都没把他看作对手。后面的机会大的，就只有八贤王胤禩和能带兵打仗的十四爷了。老九老十老十三都因为个人性格以及作为追随者就不多说。说到这里，让我想起康熙大帝的爷爷当初是怎么从众多实力强劲的竞争对手中脱颖而出的。原因其实很简单，就像当初皇太极能上位时一样，其他的“竞争对手”都是各有各的“毛病”。大阿哥，纯粹就是一个武人心思，冲锋陷阵去打仗可以，动心思搞政治那是真的是没可能处理好那么复杂的政治局面。作为长兄，与众多兄弟关系处的那是一个真差，没有一个喜欢他这个大哥的。在权力斗争时，时时处处都自己冲在最前面，在“一把手”面前上蹿下跳，康熙那么洞若观火的人怎么会选择这么一个“没脑子”的人做太子。二阿哥，做了三十年的太子，原本看上去稳稳的接班人。可是却在一年又一年的权力的斗争中被逼的走了最不应该走的昏着“起兵逼宫”。他的二次被废，与康熙帝关系处理上是一方面，与八爷党的斗争也是一方面。根源上，还是满清的八旗制度作祟。他虽是太子，却压根没有碾压其他兄弟的综合实力，像四王爷八王爷等都是旗主王爷，各有自己的实力班底，哪怕是二阿哥这个太子登基，也不见得可以做稳他这个位子。（详见当初康熙登基多年还是废了旗主鳌拜才真正掌权的）八王爷胤禩，朝中号称“八贤王”，党羽众多，实力超强，可以说是在朝臣中一呼百应。可是他错就错在，在两个点上“大意失荆州”。第一，处处学皇上，却没搞明白接班人不是靠朝臣一呼百应推举的，而是靠“圣心独裁”。第二，八王爷从一开始就没能实打实的真正的掌握兵权，这就导致他一旦变故起，手里就没有危难时刻力挺他上位的兵马。（人家太子手里最起码还有托合齐、耿索图这样的危难时刻敢起兵的兵马）其余的最有可能上位的就是老四和老十四这一母同胞的亲哥俩了。在当时没有立太子的大情况下，被康熙大帝选拔为军权第一的“大将军王”老十四几乎就是默认的皇位继承人。相信朝臣也好，百姓也好，他接班上位都会认为“顺理成章”。这也是后面老四登基后一直被朝野揣测的老四是“非正常登基”的原因。实际，老十四没能接班原因很简单，“距离太远”。在当年那个年代，从青海陕甘那边远地区到京城，那个时候又没修高速公路，也没有高铁之类的，骑快马也要半个月一个月才能到京城，消息传递往返最起码也要一个月。这就让手握兵权的老十四消息最起码比在京的竞争对手迟滞了一个月。大变速起，一夜之间都可以天翻地覆，更何况消息竟然迟滞一个月以上了，可想而知。后面也知道，老十四接到消息回来时，老四这边该登基的登基了，该干得活都干完了。他赶回来，哪怕带着十万兵马回来，也没什么意义了。最后，说到“胜者为王”的四王爷胤禛。冷面孤王，最初依附于太子，哪怕依附也是有目的的希望太子给自己更多的机会去工作去历练。当最后发现太子不行了，果断的倒向“一把手”康熙这边，给任伯安的迷信，被康熙密诏捕获太子党羽都有老四的参与。每个参与夺嫡的皇子都有各自班底，无论太子还是老八老十四，只不过电视剧里都很隐晦。老四这边露面多的也就是一个邬思道。但只有四王爷最果断狠辣，抓住了最最关键的一点:“只有皇上认可的皇子才是铁稳的继承人。”这里不得不提一句，佟国维老狐狸“皇上臣老了不假，可是并没有眼花呀”。老四在救灾筹款，百官行述，推荐大将军王等重大事件，件件都办到了圣明烛照的康熙大帝的心坎上。再加上最迫不得已的一招，放出铁杆老十三接管了丰台大营的兵马进畅春园勤王护驾。可以说，哪怕皇上许的接班人不是老四，老十三带着兵马一到，他四王爷也会“铁血登基”，没谁拦得住他。自古以来，“权力的游戏”就是原始丛林的丛林法则。它有其铁的法则，一旦进入游戏场就要遵守游戏规则，来不得半点的感情用事。我等凡夫俗子但观剧尔，那游戏不是普通人可以玩的。最后，愿烟火人间，安得太平美满。</p><h1 id="剧中人物"><a href="#剧中人物" class="headerlink" title="剧中人物"></a>剧中人物</h1><h2 id="雍正"><a href="#雍正" class="headerlink" title="雍正"></a>雍正</h2><p>感觉做王爷的时候，智商不够用，一直对邬先生言听计从。可能是邬先生这个人，代表的是他当时府邸的幕僚。做了皇帝以后，勤俭持政，打破一切阻碍，推行新政，使国库日渐充盈。可惜操劳过度，在位仅仅13年，但是这13年的新政，对清朝历史来说是至关重要的。从反面来讲，雍正不懂得用人，大事小事事事都亲力亲为，所以身体很快就不行了。</p><h2 id="康熙"><a href="#康熙" class="headerlink" title="康熙"></a>康熙</h2><p>8岁继位，在位61年，69岁去世。他比雍正聪明多了，以宽仁治理天下，晚年疲于应付九子夺嫡，吏治腐败，导致国库空虚。不可否认是个英明的皇帝。</p><h2 id="乾隆"><a href="#乾隆" class="headerlink" title="乾隆"></a>乾隆</h2><p>应该是让所有统治者都羡慕的皇帝。早年被爷爷康熙看中，加以培养。雍正登记后，为他扫清一切障碍。不像康熙一样8岁继位，也不像雍正一样45岁继位。更不需要夺嫡。在25岁这个刚刚好的年纪，顺利的登上了皇位，在位60年，太上皇3年。89岁去世，应该是古代皇帝中，在位时间最长，活的最长的。</p><p>再说说康熙的这些儿子们吧</p><h2 id="大阿哥"><a href="#大阿哥" class="headerlink" title="大阿哥"></a>大阿哥</h2><p>不作死就不会死。虽然不受康熙待见，但是如果本分的做好自己的王爷，未尝不可善终。</p><h2 id="二阿哥"><a href="#二阿哥" class="headerlink" title="二阿哥"></a>二阿哥</h2><p>太子。是康熙最偏爱的儿子，因为他是皇后所生的嫡长子。无奈，一手好牌，被打的稀巴烂，康熙给了他无数的机会，他始终不知悔过。已经是一人之下万人之上了，未来的天下都是你的，买官卖官，还想得到仁伯安的那个《百官行述》，以要挟百官，坐稳自己太子的位置。经过废太子，复位以后，竟然在一群猪队友的怂恿下，要造反。完全枉费了他父亲和王师傅的一片苦心扶不上墙的烂泥。</p><h2 id="三阿哥"><a href="#三阿哥" class="headerlink" title="三阿哥"></a>三阿哥</h2><p>是个文人，却不是个治国人才。好歹识时务，带头承认了雍正。最好自己的老王爷，也不算惨。</p><h2 id="八爷党"><a href="#八爷党" class="headerlink" title="八爷党"></a>八爷党</h2><p>最会收买人心，人称八贤王。如果他一心一意辅政。凭借他的才干和学识，很可能成为一代贤王。跟老十三一文一武。可惜卷入了这场斗争，就无法脱身了。他必须要一条道走到黑。最后只能成为阿其那。</p><h2 id="九爷"><a href="#九爷" class="headerlink" title="九爷"></a>九爷</h2><p>八爷党的智囊。机灵鬼一个。</p><h2 id="十爷"><a href="#十爷" class="headerlink" title="十爷"></a>十爷</h2><p>无脑的纨绔子弟。</p><h2 id="十三，侠肝义胆，对父子情，兄弟情，男女情。都是真切感人的。从开始的拼命十三郎，高声呐喊，最是无情帝王家。到后来的谨小慎微。但是始终不变的是这是个性情中人，跟雍正始终是个铁杆兄弟。在古代帝王家是非常难得的。"><a href="#十三，侠肝义胆，对父子情，兄弟情，男女情。都是真切感人的。从开始的拼命十三郎，高声呐喊，最是无情帝王家。到后来的谨小慎微。但是始终不变的是这是个性情中人，跟雍正始终是个铁杆兄弟。在古代帝王家是非常难得的。" class="headerlink" title="十三，侠肝义胆，对父子情，兄弟情，男女情。都是真切感人的。从开始的拼命十三郎，高声呐喊，最是无情帝王家。到后来的谨小慎微。但是始终不变的是这是个性情中人，跟雍正始终是个铁杆兄弟。在古代帝王家是非常难得的。"></a>十三，侠肝义胆，对父子情，兄弟情，男女情。都是真切感人的。从开始的拼命十三郎，高声呐喊，最是无情帝王家。到后来的谨小慎微。但是始终不变的是这是个性情中人，跟雍正始终是个铁杆兄弟。在古代帝王家是非常难得的。</h2><h2 id="十四"><a href="#十四" class="headerlink" title="十四"></a>十四</h2><p>不错，他本来是站八爷党的。但是自己一母所生的四哥登上了皇位。如果能够在太后的斡旋下，哥两和平相处，十四做个平安王爷也是没问题的。不至于最后被圈禁。9子谈完了，再谈谈剧中的其他人物吧</p><h2 id="太子的老师王师傅"><a href="#太子的老师王师傅" class="headerlink" title="太子的老师王师傅"></a>太子的老师王师傅</h2><p>呕心沥血的教导太子，把所有的身家都押注到太子身上，无奈太子不争气。康熙还是很感激他的，废太子后让他同坐龙轿。太子也是敬他的。他也是个明事理的人，看太子实在无望后，转身支持四爷。</p><h2 id="张庭玉"><a href="#张庭玉" class="headerlink" title="张庭玉"></a>张庭玉</h2><p>做到了一个汉人能做到的最高位置。2朝宰相，配享太庙。最会揣摩圣意，做人做事永远恰到好处。有一个细节，印象深刻。八爷党想通过八王议政，来逼宫。准许4位旗主王爷带兵进京，当时张庭玉已经意识到不对了，来整顿旗务，怎么还带兵呢。提醒了雍正一句，但是雍正没有在意。张庭玉也就没有再说下去，后来逼宫的时候，他才站出来言论一番，不是诤臣，确事事都做的恰到好处。</p><h2 id="李绂"><a href="#李绂" class="headerlink" title="李绂"></a>李绂</h2><p>是个正直的人，清流代表，但是脑子一根筋，比起张庭玉差远了，最后能善终也是个不错的结局了</p><h2 id="邬先生"><a href="#邬先生" class="headerlink" title="邬先生"></a>邬先生</h2><p>是个虚构的人物。这个人懂进退，来的目的是成为帝师。任务完成了，就激流勇退，先是半隐，让雍正放心。后来对雍正彻底没有了威胁后，就全隐起来了。</p><h2 id="年秋月"><a href="#年秋月" class="headerlink" title="年秋月"></a>年秋月</h2><p>是个悲剧人物。作为棋子，嫁给了雍正。随着年羹尧的败落，她也不受待见了。后来雍正明显意识到自己杀年羹尧是被算计了，开始弥补她，但是已经没有用了。</p><h2 id="年羹尧"><a href="#年羹尧" class="headerlink" title="年羹尧"></a>年羹尧</h2><p>夺嫡的时候，他也不知道谁会登上帝位。所以摇摆不定，对各方势力都持暧昧态度，也是人之常情。也的确是他帮助雍正坐稳了位置。雍正把他捧得太高，加上他性格的原因，不知功成身退，甚至不知道要低调。雍正对他是有感情的，贬到一个看城门的，也没有杀他。他对雍正也没有谋逆之心，他自己不知收敛，政敌利用雍正中的缺点，直中要害，所以他不得不悲惨收场。</p><h2 id="隆科多"><a href="#隆科多" class="headerlink" title="隆科多"></a>隆科多</h2><p>佟国维站错队，退出历史舞台，隆科多正式登上历史舞台。雍正继位后，他已经是军机处大臣了，位高权重。为什么非要掺和八爷党，去逼宫呢。有几件事对他影响很大，第一件是诺敏案，在这简单说一下诺敏，求名不求财。想做个清官，无奈被大环境拉下水。被杀。第二件是年羹尧被赐死。还有一件就是自己渐渐失宠，雍正已经不信任他了，加上他本来就是墙头草，最后选择搏一把，走上了不归路。</p><h2 id="李卫"><a href="#李卫" class="headerlink" title="李卫"></a>李卫</h2><p>是个幸运人物。本来是个叫花子，遇到贵人雍亲王。虽然大字不识几个，也没有什么能力，但是社会底层出身，身后没有家族，但是他不结党，不营私，对雍正足够忠诚。一心一意只为雍正分忧，所以雍正对他足够放心。翠儿，也是跟对了人，得以平安稳妥的过完这一生。这2个人，虽然出身最不好，但是确是结局最好，最幸福的人。</p><h2 id="田文镜"><a href="#田文镜" class="headerlink" title="田文镜"></a>田文镜</h2><p>是雍正的一把枪，指哪打哪。性情直，又没有二心，雍正太需要这个人了。</p><h2 id="太后乌雅氏"><a href="#太后乌雅氏" class="headerlink" title="太后乌雅氏"></a>太后乌雅氏</h2><p>从宫女做到太后，自己的儿子又做了皇帝。这个女人可能读书太少，有些蠢，处处很雍正对着干，也因为这样，渐渐的害了自己疼爱的小儿子。一个母亲，明事理很重要。</p><h2 id="乔引睇"><a href="#乔引睇" class="headerlink" title="乔引睇"></a>乔引睇</h2><p>被十四爷从破庙中救起，后来被雍正压回京，做了贴身宫女。雍正故意把自己的善良和勤政给她看，最后也感化了她。从开始的跟老十四，要是只有我们2个人就好了。到后来他的心明显偏向雍正了</p><h2 id="阿兰"><a href="#阿兰" class="headerlink" title="阿兰"></a>阿兰</h2><p>跟了十三，她这辈子是极其幸运的。</p><h2 id="张五哥，因为康熙的儿子都不孝，念在张五哥是个孝子，被康熙留在了身边做了贴身侍卫。后来跟了雍正，最后去主动给十三爷守陵。这兄妹俩活成了普通人最理想的样子。"><a href="#张五哥，因为康熙的儿子都不孝，念在张五哥是个孝子，被康熙留在了身边做了贴身侍卫。后来跟了雍正，最后去主动给十三爷守陵。这兄妹俩活成了普通人最理想的样子。" class="headerlink" title="张五哥，因为康熙的儿子都不孝，念在张五哥是个孝子，被康熙留在了身边做了贴身侍卫。后来跟了雍正，最后去主动给十三爷守陵。这兄妹俩活成了普通人最理想的样子。"></a>张五哥，因为康熙的儿子都不孝，念在张五哥是个孝子，被康熙留在了身边做了贴身侍卫。后来跟了雍正，最后去主动给十三爷守陵。这兄妹俩活成了普通人最理想的样子。</h2><h2 id="高福-高勿庸"><a href="#高福-高勿庸" class="headerlink" title="高福 高勿庸"></a>高福 高勿庸</h2><p>曾经是雍正最亲密的人，也是最惨的人之一，小人物的悲剧。</p><h2 id="图里堔"><a href="#图里堔" class="headerlink" title="图里堔"></a>图里堔</h2><p>站队正确，又一心一意。大概率回平安无事。</p><h2 id="孙嘉诚，"><a href="#孙嘉诚，" class="headerlink" title="孙嘉诚，"></a>孙嘉诚，</h2><p>一心为公，最后只能作为棋子牺牲，可敬不可佩。可惜了，但是跟自身的短板也有很大干系。</p><h2 id="如月"><a href="#如月" class="headerlink" title="如月"></a>如月</h2><p>她比年秋月幸运的多。被派到邬先生身边做监视。最后跟着邬先生远离纷争。对她来说是最好的结局。</p><h2 id="弘时"><a href="#弘时" class="headerlink" title="弘时"></a>弘时</h2><p>阴狠，但是明显智商不够。被人利用，悲惨收场。</p><h2 id="弘昼"><a href="#弘昼" class="headerlink" title="弘昼"></a>弘昼</h2><p>就聪明多了，他早就知道弘历是爷爷和父亲看好的人，争不过他，也不能跟他争。所以永远都是一脸无辜的表情，人畜无害。自己做自己的平安逍遥王爷。明事理又识时务。</p><h2 id="弘历"><a href="#弘历" class="headerlink" title="弘历"></a>弘历</h2><p>自身天资聪颖，加上爷爷和父亲的用心培养。一路走来顺利的不能再顺利。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;读后感&quot;&gt;&lt;a href=&quot;#读后感&quot; class=&quot;headerlink&quot; title=&quot;读后感&quot;&gt;&lt;/a&gt;读后感&lt;/h1&gt;&lt;p&gt;读二月河前辈的《康熙王朝》《雍正王朝》，常常使人反思。康熙一朝凡经六十余年，整整一个甲子年。内平鳌拜掌实权，再平三藩稳定天下，接着治
      
    
    </summary>
    
      <category term="杂谈" scheme="https://skhon.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="Talking to oneself" scheme="https://skhon.github.io/tags/Talking-to-oneself/"/>
    
  </entry>
  
  <entry>
    <title>typescript整理</title>
    <link href="https://skhon.github.io/2021/12/28/fe/typescript/"/>
    <id>https://skhon.github.io/2021/12/28/fe/typescript/</id>
    <published>2021-12-28T10:16:41.992Z</published>
    <updated>2021-12-28T12:33:48.163Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-ts-安装和编译"><a href="#1-ts-安装和编译" class="headerlink" title="1 ts 安装和编译"></a><strong>1</strong> <strong>ts</strong> <strong>安装和编译</strong></h3><ul><li>第一步 新建一个空文件夹用来学习 ts</li></ul><!----><ul><li>第二步 全局安装 ts 和 ts-node</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cnpm i typescript -g //全局安装ts</span><br><span class="line">cnpm i -g ts-node //全局安装ts-node</span><br></pre></td></tr></table></figure><ul><li>第三步 生成 tsconfig.js 配置文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --init</span><br></pre></td></tr></table></figure><p>我们就先按照自动生成的 tsconfig 配置项去使用 里面的配置咱们可以先不去管他 后续熟练了再去配置</p><ul><li>第四步 在项目下新建一个<code>index.ts</code>直接写入</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const a: string = &quot;hello&quot;;</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure><ul><li>第五步 编译 ts 为 js 在控制台（终端）输入命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc index.ts</span><br></pre></td></tr></table></figure><p>神奇的事情发生了 项目下出现了一个同名的 index.js 文件 至此我们已经可以把 ts 文件编译成 js 文件了</p><p>不过到这里聪明的小伙伴就会发现了 我们全局安装的 「ts-node」 有什么作用呢 其实这个包是帮助我们在不需要编译成 js 的前提下就可以直接执行 ts 代码 比如 我们在控制台输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ts-node index.ts</span><br></pre></td></tr></table></figure><p>可以看到我们打印的<code>hello</code>已经输出了</p><p>那可能 还有的小伙伴会发现 我们每次改动都要手动去执行编译 这样很麻烦 其实我们可以加一个参数来实现每次文件变动 ts 帮我们「自动编译成 js」 的效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --watch index.ts</span><br></pre></td></tr></table></figure><p>好了 环境安装完毕了 接下来出发去学习 ts 核心吧</p><h3 id="2-TS-类型"><a href="#2-TS-类型" class="headerlink" title="2 TS 类型"></a><strong>2</strong> <strong>TS</strong> <strong>类型</strong></h3><h5 id="2-1-布尔类型-boolean"><a href="#2-1-布尔类型-boolean" class="headerlink" title="2.1 布尔类型(boolean)"></a><strong>2.1 布尔类型(boolean)</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const flag: boolean = true;</span><br></pre></td></tr></table></figure><h5 id="2-2-Number-类型"><a href="#2-2-Number-类型" class="headerlink" title="2.2 Number 类型"></a><strong>2.2 Number 类型</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const flag: number = 1;</span><br></pre></td></tr></table></figure><h5 id="2-3-String-类型"><a href="#2-3-String-类型" class="headerlink" title="2.3 String 类型"></a><strong>2.3 String 类型</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const flag: string = &quot;hello&quot;;</span><br></pre></td></tr></table></figure><h5 id="2-4-Enum-类型"><a href="#2-4-Enum-类型" class="headerlink" title="2.4 Enum 类型"></a><strong>2.4</strong> <strong>Enum</strong> <strong>类型</strong></h5><p>使用枚举我们可以很好的描述一些特定的业务场景，比如一年中的春、夏、秋、冬，还有每周的周一到周天，还有各种颜色，以及可以用它来描述一些状态信息，比如错误码等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> // 普通枚举 初始值默认为 0 其余的成员会会按顺序自动增长 可以理解为数组下标</span><br><span class="line">enum Color &#123;</span><br><span class="line">  RED,</span><br><span class="line">  PINK,</span><br><span class="line">  BLUE,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const pink: Color = Color.PINK;</span><br><span class="line">console.log(pink); // 1</span><br><span class="line"></span><br><span class="line">// 设置初始值</span><br><span class="line">enum Color &#123;</span><br><span class="line">  RED = 10,</span><br><span class="line">  PINK,</span><br><span class="line">  BLUE,</span><br><span class="line">&#125;</span><br><span class="line">const pink: Color = Color.PINK;</span><br><span class="line">console.log(pink); // 11</span><br><span class="line"></span><br><span class="line">// 字符串枚举 每个都需要声明</span><br><span class="line">enum Color &#123;</span><br><span class="line">  RED = &quot;红色&quot;,</span><br><span class="line">  PINK = &quot;粉色&quot;,</span><br><span class="line">  BLUE = &quot;蓝色&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const pink: Color = Color.PINK;</span><br><span class="line">console.log(pink); // 粉色</span><br><span class="line"></span><br><span class="line">// 常量枚举 它是使用 const 关键字修饰的枚举，常量枚举与普通枚举的区别是，整个枚举会在编译阶段被删除 我们可以看下编译之后的效果</span><br><span class="line"></span><br><span class="line">const enum Color &#123;</span><br><span class="line">  RED,</span><br><span class="line">  PINK,</span><br><span class="line">  BLUE,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const color: Color[] = [Color.RED, Color.PINK, Color.BLUE];</span><br><span class="line"></span><br><span class="line">//编译之后的js如下：</span><br><span class="line">var color = [0 /* RED */ , 1 /* PINK */ , 2 /* BLUE */ ];</span><br><span class="line">// 可以看到我们的枚举并没有被编译成js代码 只是把color这个数组变量编译出来了</span><br></pre></td></tr></table></figure><h5 id="2-5-数组类型-array"><a href="#2-5-数组类型-array" class="headerlink" title="2.5 数组类型(array)"></a><strong>2.5 数组类型(array)</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const flag1: number[] = [1, 2, 3];</span><br><span class="line">const flag2: Array&lt;number&gt; = [1, 2, 3];</span><br></pre></td></tr></table></figure><h5 id="2-6-元组类型-tuple"><a href="#2-6-元组类型-tuple" class="headerlink" title="2.6 元组类型(tuple)"></a><strong>2.6 元组类型(tuple)</strong></h5><p>在 TypeScript 的基础类型中，元组（ Tuple ）表示一个已知「数量」和「类型」的数组 其实可以理解为他是一种特殊的数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const flag: [string, number] = [&quot;hello&quot;, 1];</span><br></pre></td></tr></table></figure><h5 id="2-7-Symbol"><a href="#2-7-Symbol" class="headerlink" title="2.7 Symbol"></a><strong>2.7 Symbol</strong></h5><p>我们在使用 Symbol 的时候，必须添加 es6 的编译辅助库 需要在 tsconfig.json 的 <code>libs</code> 字段加上<code>ES`</code>2015`Symbol 的值是唯一不变的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const sym1 = Symbol(&quot;hello&quot;);</span><br><span class="line">const sym2 = Symbol(&quot;hello&quot;);</span><br><span class="line">console.log(Symbol(&quot;hello&quot;) === Symbol(&quot;hello&quot;));</span><br></pre></td></tr></table></figure><h5 id="2-8-任意类型-any"><a href="#2-8-任意类型-any" class="headerlink" title="2.8 任意类型(any)"></a><strong>2.8 任意类型(any)</strong></h5><p>任何类型都可以被归为 <code>any</code> 类型 这让 <code>any</code> 类型成为了类型系统的 顶级类型 (也被称作 全局超级类型) TypeScript 允许我们对 <code>any</code> 类型的值执行任何操作 而无需事先执行任何形式的检查</p><p>一般使用场景：第三方库没有提供类型文件时可以使用 <code>any</code>类型转换遇到困难或者数据结构太复杂难以定义 不过不要太依赖 <code>any</code> 否则就失去了 ts 的意义了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const flag: any = document.getElementById(&quot;root&quot;);</span><br></pre></td></tr></table></figure><h5 id="2-9-null-和-undefined"><a href="#2-9-null-和-undefined" class="headerlink" title="2.9 null 和 undefined"></a><strong>2.9 null 和 undefined</strong></h5><p><code>undefined</code> 和 <code>null</code> 两者有各自的类型分别为 <code>undefined</code> 和 <code>null</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let u: undefined = undefined;</span><br><span class="line">let n: null = null;</span><br></pre></td></tr></table></figure><h5 id="2-10-Unknown-类型"><a href="#2-10-Unknown-类型" class="headerlink" title="2.10 Unknown 类型"></a><strong>2.10 Unknown 类型</strong></h5><p><code>unknown</code> 和 <code>any</code> 的主要区别是 <code>unknown</code> 类型会更加严格 在对 <code>unknown</code> 类型的值执行大多数操作之前 我们必须进行某种形式的检查 而在对 <code>any</code> 类型的值执行操作之前 我们不必进行任何检查 所有类型都可以被归为 <code>unknown</code> 但<code>unknown</code>类型只能被赋值给 <code>any</code> 类型和 <code>unknown</code> 类型本身 而 <code>any</code> 啥都能分配和被分配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let value: unknown;</span><br><span class="line"></span><br><span class="line">value = true; // OK</span><br><span class="line">value = 42; // OK</span><br><span class="line">value = &quot;Hello World&quot;; // OK</span><br><span class="line">value = []; // OK</span><br><span class="line">value = &#123;&#125;; // OK</span><br><span class="line"></span><br><span class="line">let value1: unknown = value; // OK</span><br><span class="line">let value2: any = value; // OK</span><br><span class="line">let value3: boolean = value; // Error</span><br><span class="line">let value4: number = value; // Error</span><br><span class="line">let value5: string = value; // Error</span><br><span class="line">let value6: object = value; // Error</span><br></pre></td></tr></table></figure><h5 id="2-11-void-类型"><a href="#2-11-void-类型" class="headerlink" title="2.11 void 类型"></a><strong>2.11 void 类型</strong></h5><p><code>void</code> 表示没有任何类型 当一个函数没有返回值时 TS 会认为它的返回值是 <code>void</code> 类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function hello(name: string): void &#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="2-12-never-类型"><a href="#2-12-never-类型" class="headerlink" title="2.12 never 类型"></a><strong>2.12 never 类型</strong></h5><p><code>never</code> 一般表示用户无法达到的类型 例如<code>never</code> 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function neverReach(): never &#123;</span><br><span class="line">  throw new Error(&quot;an error&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>❝</strong></p></blockquote><blockquote><p>思考:never 和 void 的区别 void 可以被赋值为 null 和 undefined 的类型。never 则是一个不包含值的类型。拥有 void 返回值类型的函数能正常运行。拥有 never 返回值类型的函数无法正常返回，无法终止，或会抛出异常。</p></blockquote><blockquote><p>❞</p></blockquote><h5 id="2-13-BigInt-大数类型"><a href="#2-13-BigInt-大数类型" class="headerlink" title="2.13 BigInt 大数类型"></a><strong>2.13 BigInt 大数类型</strong></h5><p>使用 <code>BigInt</code> 可以安全地存储和操作大整数 我们在使用 <code>BigInt</code> 的时候 必须添加 <code>ESNext</code> 的编译辅助库 需要在 tsconfig.json 的 <code>libs</code> 字段加上<code>ESNext</code>要使用<code>1n</code>需要 <code>&quot;target&quot;: &quot;ESNext&quot;number</code> 和 <code>BigInt</code> 类型不一样 不兼容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const max1 = Number.MAX_SAFE_INTEGER; // 2**53-1</span><br><span class="line">console.log(max1 + 1 === max1 + 2); //true</span><br><span class="line"></span><br><span class="line">const max2 = BigInt(Number.MAX_SAFE_INTEGER);</span><br><span class="line">console.log(max2 + 1n === max2 + 2n); //false</span><br><span class="line"></span><br><span class="line">let foo: number;</span><br><span class="line">let bar: bigint;</span><br><span class="line">foo = bar; //error</span><br><span class="line">bar = foo; //error</span><br></pre></td></tr></table></figure><h5 id="2-14-object-Object-和-类型"><a href="#2-14-object-Object-和-类型" class="headerlink" title="2.14 object, Object 和 {} 类型"></a><strong>2.14 object, Object 和 {} 类型</strong></h5><p>「object」 类型用于表示非原始类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let objectCase: object;</span><br><span class="line">objectCase = 1; // error</span><br><span class="line">objectCase = &quot;a&quot;; // error</span><br><span class="line">objectCase = true; // error</span><br><span class="line">objectCase = null; // error</span><br><span class="line">objectCase = undefined; // error</span><br><span class="line">objectCase = &#123;&#125;; // ok</span><br></pre></td></tr></table></figure><p>「大 Object」 代表所有拥有 toString、hasOwnProperty 方法的类型 所以所有原始类型、非原始类型都可以赋给 Object(严格模式下 <code>null</code> 和 <code>undefined</code> 不可以)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let ObjectCase: Object;</span><br><span class="line">ObjectCase = 1; // ok</span><br><span class="line">ObjectCase = &quot;a&quot;; // ok</span><br><span class="line">ObjectCase = true; // ok</span><br><span class="line">ObjectCase = null; // error</span><br><span class="line">ObjectCase = undefined; // error</span><br><span class="line">ObjectCase = &#123;&#125;; // ok</span><br></pre></td></tr></table></figure><p>「{}」 空对象类型和大 Object 一样 也是表示原始类型和非原始类型的集合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let simpleCase: &#123;&#125;;</span><br><span class="line">simpleCase = 1; // ok</span><br><span class="line">simpleCase = &quot;a&quot;; // ok</span><br><span class="line">simpleCase = true; // ok</span><br><span class="line">simpleCase = null; // error</span><br><span class="line">simpleCase = undefined; // error</span><br><span class="line">simpleCase = &#123;&#125;; // ok</span><br></pre></td></tr></table></figure><h5 id="2-15-类型推论"><a href="#2-15-类型推论" class="headerlink" title="2.15 类型推论"></a><strong>2.15 类型推论</strong></h5><p>指编程语言中能够自动推导出值的类型的能力 它是一些强静态类型语言中出现的特性 定义时未赋值就会推论成 <code>any</code> 类型 如果定义的时候就赋值就能利用到类型推论</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let flag; //推断为any</span><br><span class="line">let count = 123; //为number类型</span><br><span class="line">let hello = &quot;hello&quot;; //为string类型</span><br></pre></td></tr></table></figure><h5 id="2-16-联合类型"><a href="#2-16-联合类型" class="headerlink" title="2.16 联合类型"></a><strong>2.16 联合类型</strong></h5><p>联合类型（Union Types）表示取值可以为多种类型中的一种 未赋值时联合类型上只能访问两个类型共有的属性和方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let name: string | number;</span><br><span class="line">console.log(name.toString());</span><br><span class="line">name = 1;</span><br><span class="line">console.log(name.toFixed(2));</span><br><span class="line">name = &quot;hello&quot;;</span><br><span class="line">console.log(name.length);</span><br></pre></td></tr></table></figure><h5 id="2-17-类型断言"><a href="#2-17-类型断言" class="headerlink" title="2.17 类型断言"></a><strong>2.17 类型断言</strong></h5><p>有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。其实就是你需要手动告诉 ts 就按照你断言的那个类型通过编译（这一招很关键 有时候可以帮助你解决很多编译报错）</p><p>类型断言有两种形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> // 尖括号 语法</span><br><span class="line">let someValue: any = &quot;this is a string&quot;;</span><br><span class="line">let strLength: number = (&lt;string&gt;someValue).length;</span><br><span class="line"></span><br><span class="line">// as 语法</span><br><span class="line">let someValue: any = &quot;this is a string&quot;;</span><br><span class="line">let strLength: number = (someValue as string).length;</span><br></pre></td></tr></table></figure><blockquote><p><strong>❝</strong></p></blockquote><blockquote><p>以上两种方式虽然没有任何区别，但是尖括号格式会与 react 中 JSX 产生语法冲突，因此我们更推荐使用 as 语法。</p></blockquote><blockquote><p>❞</p></blockquote><p>「非空断言」在上下文中当类型检查器无法断定类型时 一个新的后缀表达式操作符 ! 可以用于断言操作对象是非 <code>null</code> 和非 <code>undefined</code> 类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let flag: null | undefined | string;</span><br><span class="line">flag!.toString(); // ok</span><br><span class="line">flag.toString(); // error</span><br></pre></td></tr></table></figure><h5 id="2-18-字面量类型"><a href="#2-18-字面量类型" class="headerlink" title="2.18 字面量类型"></a><strong>2.18 字面量类型</strong></h5><p>在 TypeScript 中，字面量不仅可以表示值，还可以表示类型，即所谓的字面量类型。目前，TypeScript 支持 3 种字面量类型：字符串字面量类型、数字字面量类型、布尔字面量类型，对应的字符串字面量、数字字面量、布尔字面量分别拥有与其值一样的字面量类型，具体示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let flag1: &quot;hello&quot; = &quot;hello&quot;;</span><br><span class="line">let flag2: 1 = 1;</span><br><span class="line">let flag3: true = true;</span><br></pre></td></tr></table></figure><h5 id="2-19-类型别名"><a href="#2-19-类型别名" class="headerlink" title="2.19 类型别名"></a><strong>2.19 类型别名</strong></h5><p>类型别名用来给一个类型起个新名字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type flag = string | number;</span><br><span class="line"></span><br><span class="line">function hello(value: flag) &#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="2-20-交叉类型"><a href="#2-20-交叉类型" class="headerlink" title="2.20 交叉类型"></a><strong>2.20 交叉类型</strong></h5><p>交叉类型是将多个类型合并为一个类型。通过 &amp; 运算符可以将现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type Flag1 = &#123; x: number &#125;;</span><br><span class="line">type Flag2 = Flag1 &amp; &#123; y: string &#125;;</span><br><span class="line"></span><br><span class="line">let flag3: Flag2 = &#123;</span><br><span class="line">  x: 1,</span><br><span class="line">  y: &quot;hello&quot;,</span><br><span class="line">  henb,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="2-21-类型保护"><a href="#2-21-类型保护" class="headerlink" title="2.21 类型保护"></a><strong>2.21 类型保护</strong></h5><p>类型保护就是一些表达式，他们在编译的时候就能通过类型信息确保某个作用域内变量的类型 其主要思想是尝试检测属性、方法或原型，以确定如何处理值</p><p>「typeof 类型保护」</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function double(input: string | number | boolean) &#123;</span><br><span class="line">  if (typeof input === &quot;string&quot;) &#123;</span><br><span class="line">    return input + input;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    if (typeof input === &quot;number&quot;) &#123;</span><br><span class="line">      return input * 2;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return !input;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>「in 关键字」</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface Bird &#123;</span><br><span class="line">  fly: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Dog &#123;</span><br><span class="line">  leg: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getNumber(value: Bird | Dog) &#123;</span><br><span class="line">  if (&quot;fly&quot; in value) &#123;</span><br><span class="line">    return value.fly;</span><br><span class="line">  &#125;</span><br><span class="line">  return value.leg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>「instanceof 类型保护」</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  name!: string;</span><br><span class="line">&#125;</span><br><span class="line">class Bird extends Animal &#123;</span><br><span class="line">  fly!: number;</span><br><span class="line">&#125;</span><br><span class="line">function getName(animal: Animal) &#123;</span><br><span class="line">  if (animal instanceof Bird) &#123;</span><br><span class="line">    console.log(animal.fly);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(animal.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>「自定义类型保护」</p><p>通过 <code>type is xxx</code>这样的类型谓词来进行类型保护</p><p>例如下面的例子 <code>value is object</code>就会认为如果函数返回 true 那么定义的 value 就是 object 类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function isObject(value: unknown): value is object &#123;</span><br><span class="line">  return typeof value === &quot;object&quot; &amp;&amp; value !== null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn(x: string | object) &#123;</span><br><span class="line">  if (isObject(x)) &#123;</span><br><span class="line">    // ....</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // .....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-函数"><a href="#3-函数" class="headerlink" title="3 函数"></a><strong>3 函数</strong></h3><h5 id="3-1-函数的定义"><a href="#3-1-函数的定义" class="headerlink" title="3.1 函数的定义"></a><strong>3.1 函数的定义</strong></h5><p>可以指定参数的类型和返回值的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function hello(name: string): void &#123;</span><br><span class="line">  console.log(&quot;hello&quot;, name);</span><br><span class="line">&#125;</span><br><span class="line">hello(&quot;hahaha&quot;);</span><br></pre></td></tr></table></figure><h5 id="3-2-函数表达式"><a href="#3-2-函数表达式" class="headerlink" title="3.2 函数表达式"></a><strong>3.2 函数表达式</strong></h5><p>定义函数类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type SumFunc = (x: number, y: number) =&gt; number;</span><br><span class="line"></span><br><span class="line">let countNumber: SumFunc = function (a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="3-3-可选参数"><a href="#3-3-可选参数" class="headerlink" title="3.3 可选参数"></a><strong>3.3 可选参数</strong></h5><p>在 TS 中函数的形参和实参必须一样，不一样就要配置可选参数,而且必须是「最后一个参数」</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function print(name: string, age?: number): void &#123;</span><br><span class="line">  console.log(name, age);</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;hahaha&quot;);</span><br></pre></td></tr></table></figure><h5 id="3-4-默认参数"><a href="#3-4-默认参数" class="headerlink" title="3.4 默认参数"></a><strong>3.4 默认参数</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function ajax(url: string, method: string = &quot;GET&quot;) &#123;</span><br><span class="line">  console.log(url, method);</span><br><span class="line">&#125;</span><br><span class="line">ajax(&quot;/users&quot;);</span><br></pre></td></tr></table></figure><h5 id="3-5-剩余参数"><a href="#3-5-剩余参数" class="headerlink" title="3.5 剩余参数"></a><strong>3.5 剩余参数</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function sum(...numbers: number[]) &#123;</span><br><span class="line">  return numbers.reduce((val, item) =&gt; (val += item), 0);</span><br><span class="line">&#125;</span><br><span class="line">console.log(sum(1, 2, 3));</span><br></pre></td></tr></table></figure><h5 id="3-6-函数重载"><a href="#3-6-函数重载" class="headerlink" title="3.6 函数重载"></a><strong>3.6 函数重载</strong></h5><p>函数重载或方法重载是使用相同名称和不同参数数量或类型创建多个方法的一种能力。在 TypeScript 中，表现为给同一个函数提供多个函数类型定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let obj: any = &#123;&#125;;</span><br><span class="line">function attr(val: string): void;</span><br><span class="line">function attr(val: number): void;</span><br><span class="line">function attr(val: any): void &#123;</span><br><span class="line">  if (typeof val === &quot;string&quot;) &#123;</span><br><span class="line">    obj.name = val;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    obj.age = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">attr(&quot;hahaha&quot;);</span><br><span class="line">attr(9);</span><br><span class="line">attr(true);</span><br><span class="line">console.log(obj);</span><br></pre></td></tr></table></figure><blockquote><p><strong>❝</strong></p></blockquote><blockquote><p>注意：函数重载真正执行的是同名函数最后定义的函数体 在最后一个函数体定义之前全都属于函数类型定义 不能写具体的函数实现方法 只能定义类型</p></blockquote><blockquote><p>❞</p></blockquote><h3 id="4-类"><a href="#4-类" class="headerlink" title="4 类"></a><strong>4 类</strong></h3><h5 id="4-1-类的定义"><a href="#4-1-类的定义" class="headerlink" title="4.1 类的定义"></a><strong>4.1 类的定义</strong></h5><p>在 TypeScript 中，我们可以通过 <code>Class</code> 关键字来定义一个类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  name!: string; //如果初始属性没赋值就需要加上!</span><br><span class="line">  constructor(_name: string) &#123;</span><br><span class="line">    this.name = _name;</span><br><span class="line">  &#125;</span><br><span class="line">  getName(): void &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p1 = new Person(&quot;hello&quot;);</span><br><span class="line">p1.getName();</span><br></pre></td></tr></table></figure><p>当然 如果我们图省事 我们也可以把属性定义直接写到构造函数的参数里面去(不过一般不建议这样写 因为会让代码增加阅读难度)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  constructor(public name: string) &#123;&#125;</span><br><span class="line">  getName(): void &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p1 = new Person(&quot;hello&quot;);</span><br><span class="line">p1.getName();</span><br></pre></td></tr></table></figure><blockquote><p><strong>❝</strong></p></blockquote><blockquote><p>注意：当我们定义一个类的时候,会得到 「2 个类型」一个是构造函数类型的函数类型(当做普通构造函数的类型) 另一个是类的实例类型（代表实例）</p></blockquote><blockquote><p>❞</p></blockquote><p>具体看例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Component &#123;</span><br><span class="line">  static myName: string = &quot;静态名称属性&quot;;</span><br><span class="line">  myName: string = &quot;实例名称属性&quot;;</span><br><span class="line">&#125;</span><br><span class="line">//ts 一个类型 一个叫值</span><br><span class="line">//放在=后面的是值</span><br><span class="line">let com = Component; //这里是代表构造函数</span><br><span class="line">//冒号后面的是类型</span><br><span class="line">let c: Component = new Component(); //这里是代表实例类型</span><br><span class="line">let f: typeof Component = com;</span><br></pre></td></tr></table></figure><h5 id="4-2-存取器"><a href="#4-2-存取器" class="headerlink" title="4.2 存取器"></a><strong>4.2 存取器</strong></h5><p>在 TypeScript 中，我们可以通过存取器来改变一个类中属性的读取和赋值行为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">  myname: string;</span><br><span class="line">  constructor(myname: string) &#123;</span><br><span class="line">    this.myname = myname;</span><br><span class="line">  &#125;</span><br><span class="line">  get name() &#123;</span><br><span class="line">    return this.myname;</span><br><span class="line">  &#125;</span><br><span class="line">  set name(value) &#123;</span><br><span class="line">    this.myname = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let user = new User(&quot;hello&quot;);</span><br><span class="line">user.name = &quot;world&quot;;</span><br><span class="line">console.log(user.name);</span><br></pre></td></tr></table></figure><p>其实我们可以看看翻译成 es5 的代码 原理很简单 就是使用了 Object.defineProperty 在类的原型上面拦截了属性对应的 get 和 set 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var User = /** @class */ (function () &#123;</span><br><span class="line">  function User(myname) &#123;</span><br><span class="line">    this.myname = myname;</span><br><span class="line">  &#125;</span><br><span class="line">  Object.defineProperty(User.prototype, &quot;name&quot;, &#123;</span><br><span class="line">    get: function () &#123;</span><br><span class="line">      return this.myname;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function (value) &#123;</span><br><span class="line">      this.myname = value;</span><br><span class="line">    &#125;,</span><br><span class="line">    enumerable: false,</span><br><span class="line">    configurable: true,</span><br><span class="line">  &#125;);</span><br><span class="line">  return User;</span><br><span class="line">&#125;)();</span><br><span class="line">var user = new User(&quot;hello&quot;);</span><br><span class="line">user.name = &quot;world&quot;;</span><br><span class="line">console.log(user.name);</span><br></pre></td></tr></table></figure><h5 id="4-3-readonly-只读属性"><a href="#4-3-readonly-只读属性" class="headerlink" title="4.3 readonly 只读属性"></a><strong>4.3 readonly 只读属性</strong></h5><p>readonly 修饰的变量只能在「构造函数」中初始化 TypeScript 的类型系统同样也允许将 interface、type、 class 上的属性标识为 readonly readonly 实际上只是在编译阶段进行代码检查。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  public readonly name: string;</span><br><span class="line">  constructor(name: string) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  changeName(name: string) &#123;</span><br><span class="line">    this.name = name; //这个ts是报错的</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = new Animal(&quot;hello&quot;);</span><br></pre></td></tr></table></figure><h5 id="4-4-继承"><a href="#4-4-继承" class="headerlink" title="4.4 继承"></a><strong>4.4 继承</strong></h5><p>子类继承父类后子类的实例就拥有了父类中的属性和方法，可以增强代码的可复用性</p><p>将子类公用的方法抽象出来放在父类中，自己的特殊逻辑放在子类中重写父类的逻辑</p><p>super 可以调用父类上的方法和属性</p><p>在 TypeScript 中，我们可以通过 extends 关键字来实现继承</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  name: string; //定义实例的属性，默认省略public修饰符</span><br><span class="line">  age: number;</span><br><span class="line">  constructor(name: string, age: number) &#123;</span><br><span class="line">    //构造函数</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  getName(): string &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">  setName(name: string): void &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Student extends Person &#123;</span><br><span class="line">  no: number;</span><br><span class="line">  constructor(name: string, age: number, no: number) &#123;</span><br><span class="line">    super(name, age);</span><br><span class="line">    this.no = no;</span><br><span class="line">  &#125;</span><br><span class="line">  getNo(): number &#123;</span><br><span class="line">    return this.no;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let s1 = new Student(&quot;hello&quot;, 10, 1);</span><br><span class="line">console.log(s1);</span><br></pre></td></tr></table></figure><h5 id="4-5-类里面的修饰符"><a href="#4-5-类里面的修饰符" class="headerlink" title="4.5 类里面的修饰符"></a><strong>4.5 类里面的修饰符</strong></h5><p>「public」 类里面 子类 其它任何地方外边都可以访问「protected」 类里面 子类 都可以访问,其它任何地方不能访问「private」 类里面可以访问，子类和其它任何地方都不可以访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123;</span><br><span class="line">  public name: string;</span><br><span class="line">  protected age: number;</span><br><span class="line">  private car: number;</span><br><span class="line">  constructor(name: string, age: number, car: number) &#123;</span><br><span class="line">    //构造函数</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.car = car;</span><br><span class="line">  &#125;</span><br><span class="line">  getName(): string &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">  setName(name: string): void &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">  constructor(name: string, age: number, car: number) &#123;</span><br><span class="line">    super(name, age, car);</span><br><span class="line">  &#125;</span><br><span class="line">  desc() &#123;</span><br><span class="line">    console.log(`$&#123;this.name&#125; $&#123;this.age&#125; $&#123;this.car&#125;`); //car访问不到 会报错</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let child = new Child(&quot;hello&quot;, 10, 1000);</span><br><span class="line">console.log(child.name);</span><br><span class="line">console.log(child.age); //age访问不到 会报错</span><br><span class="line">console.log(child.car); //car访问不到 会报错</span><br></pre></td></tr></table></figure><h5 id="4-6-静态属性-静态方法"><a href="#4-6-静态属性-静态方法" class="headerlink" title="4.6 静态属性 静态方法"></a><strong>4.6 静态属性 静态方法</strong></h5><p>类的静态属性和方法是直接定义在类本身上面的 所以也只能通过直接调用类的方法和属性来访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123;</span><br><span class="line">  static mainName = &quot;Parent&quot;;</span><br><span class="line">  static getmainName() &#123;</span><br><span class="line">    console.log(this); //注意静态方法里面的this指向的是类本身 而不是类的实例对象 所以静态方法里面只能访问类的静态属性和方法</span><br><span class="line">    return this.mainName;</span><br><span class="line">  &#125;</span><br><span class="line">  public name: string;</span><br><span class="line">  constructor(name: string) &#123;</span><br><span class="line">    //构造函数</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(Parent.mainName);</span><br><span class="line">console.log(Parent.getmainName());</span><br></pre></td></tr></table></figure><h5 id="4-7-抽象类和抽象方法"><a href="#4-7-抽象类和抽象方法" class="headerlink" title="4.7 抽象类和抽象方法"></a><strong>4.7 抽象类和抽象方法</strong></h5><p>抽象类，无法被实例化，只能被继承并且无法创建抽象类的实例 子类可以对抽象类进行不同的实现</p><p>抽象方法只能出现在抽象类中并且抽象方法不能在抽象类中被具体实现，只能在抽象类的子类中实现（必须要实现）</p><p>使用场景：我们一般用抽象类和抽象方法抽离出事物的共性 以后所有继承的子类必须按照规范去实现自己的具体逻辑 这样可以增加代码的可维护性和复用性</p><p>使用 <code>abstract</code> 关键字来定义抽象类和抽象方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">abstract class Animal &#123;</span><br><span class="line">  name!: string;</span><br><span class="line">  abstract speak(): void;</span><br><span class="line">&#125;</span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">  speak() &#123;</span><br><span class="line">    console.log(&quot;喵喵喵&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let animal = new Animal(); //直接报错 无法创建抽象类的实例</span><br><span class="line">let cat = new Cat();</span><br><span class="line">cat.speak();</span><br></pre></td></tr></table></figure><blockquote><p><strong>❝</strong></p></blockquote><blockquote><p>思考 1:重写(override)和重载(overload)的区别</p></blockquote><blockquote><p>❞</p></blockquote><p>「重写」是指子类重写继承自父类中的方法「重载」是指为同一个函数提供多个类型定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  speak(word: string): string &#123;</span><br><span class="line">    return &quot;动物:&quot; + word;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">  speak(word: string): string &#123;</span><br><span class="line">    return &quot;猫:&quot; + word;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let cat = new Cat();</span><br><span class="line">console.log(cat.speak(&quot;hello&quot;));</span><br><span class="line">// 上面是重写</span><br><span class="line">//--------------------------------------------</span><br><span class="line">// 下面是重载</span><br><span class="line">function double(val: number): number;</span><br><span class="line">function double(val: string): string;</span><br><span class="line">function double(val: any): any &#123;</span><br><span class="line">  if (typeof val == &quot;number&quot;) &#123;</span><br><span class="line">    return val * 2;</span><br><span class="line">  &#125;</span><br><span class="line">  return val + val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let r = double(1);</span><br><span class="line">console.log(r);</span><br></pre></td></tr></table></figure><blockquote><p><strong>❝</strong></p></blockquote><blockquote><p>思考 2:什么是「多态」</p></blockquote><blockquote><p>❞</p></blockquote><p>在父类中定义一个方法，在子类中有多个实现，在程序运行的时候，根据不同的对象执行不同的操作，实现运行时的绑定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">abstract class Animal &#123;</span><br><span class="line">  // 声明抽象的方法，让子类去实现</span><br><span class="line">  abstract sleep(): void;</span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">  sleep() &#123;</span><br><span class="line">    console.log(&quot;dog sleep&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let dog = new Dog();</span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">  sleep() &#123;</span><br><span class="line">    console.log(&quot;cat sleep&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let cat = new Cat();</span><br><span class="line">let animals: Animal[] = [dog, cat];</span><br><span class="line">animals.forEach((i) =&gt; &#123;</span><br><span class="line">  i.sleep();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="5-接口"><a href="#5-接口" class="headerlink" title="5 接口"></a><strong>5 接口</strong></h3><p>接口既可以在面向对象编程中表示为行为的抽象，也可以用来描述对象的形状</p><p>我们用 <code>interface</code> 关键字来定义接口 在接口中可以用分号或者逗号分割每一项，也可以什么都不加</p><h5 id="5-1-对象的形状"><a href="#5-1-对象的形状" class="headerlink" title="5.1 对象的形状"></a><strong>5.1 对象的形状</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> //接口可以用来描述`对象的形状`</span><br><span class="line">//接口可以用来描述`对象的形状`</span><br><span class="line">interface Speakable &#123;</span><br><span class="line">  speak(): void;</span><br><span class="line">  readonly lng: string; //readonly表示只读属性 后续不可以更改</span><br><span class="line">  name?: string; //？表示可选属性</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let speakman: Speakable = &#123;</span><br><span class="line">  //   speak() &#123;&#125;, //少属性会报错</span><br><span class="line">  name: &quot;hello&quot;,</span><br><span class="line">  lng: &quot;en&quot;,</span><br><span class="line">  age: 111, //多属性也会报错</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="5-2-行为的抽象"><a href="#5-2-行为的抽象" class="headerlink" title="5.2 行为的抽象"></a><strong>5.2 行为的抽象</strong></h5><p>接口可以把一些类中共有的属性和方法抽象出来,可以用来约束实现此接口的类</p><p>一个类可以实现多个接口，一个接口也可以被多个类实现</p><p>我们用 <code>implements</code>关键字来代表 实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> //接口可以在面向对象编程中表示为行为的抽象</span><br><span class="line">interface Speakable &#123;</span><br><span class="line">  speak(): void;</span><br><span class="line">&#125;</span><br><span class="line">interface Eatable &#123;</span><br><span class="line">  eat(): void;</span><br><span class="line">&#125;</span><br><span class="line">//一个类可以实现多个接口</span><br><span class="line">class Person implements Speakable, Eatable &#123;</span><br><span class="line">  speak() &#123;</span><br><span class="line">    console.log(&quot;Person说话&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  //   eat() &#123;&#125; //需要实现的接口包含eat方法 不实现会报错</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-3-定义任意属性"><a href="#5-3-定义任意属性" class="headerlink" title="5.3 定义任意属性"></a><strong>5.3 定义任意属性</strong></h5><p>如果我们在定义接口的时候无法预先知道有哪些属性的时候,可以使用 <code>[propName:string]:any</code>,propName 名字是任意的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  id: number;</span><br><span class="line">  name: string;</span><br><span class="line">  [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p1 = &#123;</span><br><span class="line">  id: 1,</span><br><span class="line">  name: &quot;hello&quot;,</span><br><span class="line">  age: 10,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个接口表示 必须要有 id 和 name 这两个字段 然后还可以新加其余的未知字段</p><h5 id="5-4-接口的继承"><a href="#5-4-接口的继承" class="headerlink" title="5.4 接口的继承"></a><strong>5.4 接口的继承</strong></h5><p>我们除了类可以继承 接口也可以继承 同样的使用 <code>extends</code>关键字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface Speakable &#123;</span><br><span class="line">  speak(): void;</span><br><span class="line">&#125;</span><br><span class="line">interface SpeakChinese extends Speakable &#123;</span><br><span class="line">  speakChinese(): void;</span><br><span class="line">&#125;</span><br><span class="line">class Person implements SpeakChinese &#123;</span><br><span class="line">  speak() &#123;</span><br><span class="line">    console.log(&quot;Person&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  speakChinese() &#123;</span><br><span class="line">    console.log(&quot;speakChinese&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-5-函数类型接口"><a href="#5-5-函数类型接口" class="headerlink" title="5.5 函数类型接口"></a><strong>5.5 函数类型接口</strong></h5><p>可以用接口来定义函数类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface discount &#123;</span><br><span class="line">  (price: number): number;</span><br><span class="line">&#125;</span><br><span class="line">let cost: discount = function (price: number): number &#123;</span><br><span class="line">  return price * 0.8;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="5-6-构造函数的类型接口"><a href="#5-6-构造函数的类型接口" class="headerlink" title="5.6 构造函数的类型接口"></a><strong>5.6 构造函数的类型接口</strong></h5><p>使用特殊的 new()关键字来描述类的构造函数类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  constructor(public name: string) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">//不加new是修饰函数的,加new是修饰类的</span><br><span class="line">interface WithNameClass &#123;</span><br><span class="line">  new (name: string): Animal;</span><br><span class="line">&#125;</span><br><span class="line">function createAnimal(clazz: WithNameClass, name: string) &#123;</span><br><span class="line">  return new clazz(name);</span><br><span class="line">&#125;</span><br><span class="line">let a = createAnimal(Animal, &quot;hello&quot;);</span><br><span class="line">console.log(a.name);</span><br></pre></td></tr></table></figure><p>其实这样的用法一般出现在 当我们需要把一个类作为参数的时候 我们需要对传入的类的构造函数类型进行约束 所以需要使用 new 关键字代表是类的构造函数类型 用以和普通函数进行区分</p><hr><blockquote><p><strong>❝</strong></p></blockquote><blockquote><p>思考：接口和类型别名的区别 这个题目是经典的 「ts 面试题」</p></blockquote><blockquote><p>❞</p></blockquote><p>实际上，在大多数的情况下使用接口类型和类型别名的效果等价，但是在某些特定的场景下这两者还是存在很大区别。</p><p>1.基础数据类型 与接口不同，类型别名还可以用于其他类型，如基本类型（原始值）、联合类型、元组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> // primitive</span><br><span class="line">type Name = string;</span><br><span class="line"></span><br><span class="line">// union</span><br><span class="line">type PartialPoint = PartialPointX | PartialPointY;</span><br><span class="line"></span><br><span class="line">// tuple</span><br><span class="line">type Data = [number, string];</span><br><span class="line"></span><br><span class="line">// dom</span><br><span class="line">let div = document.createElement(&quot;div&quot;);</span><br><span class="line">type B = typeof div;</span><br></pre></td></tr></table></figure><p>2.重复定义</p><p>接口可以定义多次 会被自动合并为单个接口 类型别名不可以重复定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Point &#123;</span><br><span class="line">  x: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Point &#123;</span><br><span class="line">  y: number;</span><br><span class="line">&#125;</span><br><span class="line">const point: Point = &#123; x: 1, y: 2 &#125;;</span><br></pre></td></tr></table></figure><p>3.扩展 接口可以扩展类型别名，同理，类型别名也可以扩展接口。但是两者实现扩展的方式不同</p><p>接口的扩展就是继承，通过 extends 来实现。类型别名的扩展就是交叉类型，通过 &amp; 来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> // 接口扩展接口</span><br><span class="line">interface PointX &#123;</span><br><span class="line">  x: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Point extends PointX &#123;</span><br><span class="line">  y: number;</span><br><span class="line">&#125;</span><br><span class="line">// ----</span><br><span class="line">// 类型别名扩展类型别名</span><br><span class="line">type PointX = &#123;</span><br><span class="line">  x: number;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type Point = PointX &amp; &#123;</span><br><span class="line">  y: number;</span><br><span class="line">&#125;;</span><br><span class="line">// ----</span><br><span class="line">// 接口扩展类型别名</span><br><span class="line">type PointX = &#123;</span><br><span class="line">  x: number;</span><br><span class="line">&#125;;</span><br><span class="line">interface Point extends PointX &#123;</span><br><span class="line">  y: number;</span><br><span class="line">&#125;</span><br><span class="line">// ----</span><br><span class="line">// 类型别名扩展接口</span><br><span class="line">interface PointX &#123;</span><br><span class="line">  x: number;</span><br><span class="line">&#125;</span><br><span class="line">type Point = PointX &amp; &#123;</span><br><span class="line">  y: number;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>4.实现 这里有一个特殊情况 类无法实现定义了联合类型的类型别名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type PartialPoint = &#123; x: number &#125; | &#123; y: number &#125;;</span><br><span class="line"></span><br><span class="line">// A class can only implement an object type or</span><br><span class="line">// intersection of object types with statically known members.</span><br><span class="line">class SomePartialPoint implements PartialPoint &#123;</span><br><span class="line">  // Error</span><br><span class="line">  x = 1;</span><br><span class="line">  y = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-泛型"><a href="#6-泛型" class="headerlink" title="6 泛型"></a><strong>6 泛型</strong></h3><p>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性</p><p>为了更好的了解泛型的作用 我们可以看下面的一个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createArray(length: number, value: any): any[] &#123;</span><br><span class="line">  let result = [];</span><br><span class="line">  for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">    result[i] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray(3, &quot;x&quot;); // [&apos;x&apos;, &apos;x&apos;, &apos;x&apos;]</span><br></pre></td></tr></table></figure><p>上述这段代码用来生成一个长度为 length 值为 value 的数组 但是我们其实可以发现一个问题 不管我们传入什么类型的 value 返回值的数组永远是 any 类型 如果我们想要的效果是 我们预先不知道会传入什么类型 但是我们希望不管我们传入什么类型 我们的返回的数组的指里面的类型应该和参数保持一致 那么这时候 泛型就登场了</p><p>使用「泛型」改造</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;</span><br><span class="line">  let result: T[] = [];</span><br><span class="line">  for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">    result[i] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray&lt;string&gt;(3, &quot;x&quot;); // [&apos;x&apos;, &apos;x&apos;, &apos;x&apos;]</span><br></pre></td></tr></table></figure><p>我们可以使用&lt;&gt;的写法 然后再面传入一个变量 T 用来表示后续函数需要用到的类型 当我们真正去调用函数的时候再传入 T 的类型就可以解决很多预先无法确定类型相关的问题</p><h5 id="6-1-多个类型参数"><a href="#6-1-多个类型参数" class="headerlink" title="6.1 多个类型参数"></a><strong>6.1 多个类型参数</strong></h5><p>如果我们需要有多个未知的类型占位 那么我们可以定义任何的字母来表示不同的类型参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] &#123;</span><br><span class="line">  return [tuple[1], tuple[0]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">swap([7, &quot;seven&quot;]); // [&apos;seven&apos;, 7]</span><br></pre></td></tr></table></figure><h5 id="6-2-泛型约束"><a href="#6-2-泛型约束" class="headerlink" title="6.2 泛型约束"></a><strong>6.2 泛型约束</strong></h5><p>在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function loggingIdentity&lt;T&gt;(arg: T): T &#123;</span><br><span class="line">  console.log(arg.length);</span><br><span class="line">  return arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// index.ts(2,19): error TS2339: Property &apos;length&apos; does not exist on type &apos;T&apos;.</span><br></pre></td></tr></table></figure><p>上例中，泛型 T 不一定包含属性 length，所以编译的时候报错了。</p><p>这时，我们可以对泛型进行约束，只允许这个函数传入那些包含 length 属性的变量。这就是「泛型约束」</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Lengthwise &#123;</span><br><span class="line">  length: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123;</span><br><span class="line">  console.log(arg.length);</span><br><span class="line">  return arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>❝</strong></p></blockquote><blockquote><p>注意：我们在泛型里面使用<code>extends</code>关键字代表的是泛型约束 需要和类的继承区分开</p></blockquote><blockquote><p>❞</p></blockquote><h5 id="6-3-泛型接口"><a href="#6-3-泛型接口" class="headerlink" title="6.3 泛型接口"></a><strong>6.3 泛型接口</strong></h5><p>定义接口的时候也可以指定泛型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Cart&lt;T&gt; &#123;</span><br><span class="line">  list: T[];</span><br><span class="line">&#125;</span><br><span class="line">let cart: Cart&lt;&#123; name: string; price: number &#125;&gt; = &#123;</span><br><span class="line">  list: [&#123; name: &quot;hello&quot;, price: 10 &#125;],</span><br><span class="line">&#125;;</span><br><span class="line">console.log(cart.list[0].name, cart.list[0].price);</span><br></pre></td></tr></table></figure><p>我们定义了接口传入的类型 T 之后返回的对象数组里面 T 就是当时传入的参数类型</p><h5 id="6-4-泛型类"><a href="#6-4-泛型类" class="headerlink" title="6.4 泛型类"></a><strong>6.4 泛型类</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class MyArray&lt;T&gt; &#123;</span><br><span class="line">  private list: T[] = [];</span><br><span class="line">  add(value: T) &#123;</span><br><span class="line">    this.list.push(value);</span><br><span class="line">  &#125;</span><br><span class="line">  getMax(): T &#123;</span><br><span class="line">    let result = this.list[0];</span><br><span class="line">    for (let i = 0; i &lt; this.list.length; i++) &#123;</span><br><span class="line">      if (this.list[i] &gt; result) &#123;</span><br><span class="line">        result = this.list[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let arr = new MyArray();</span><br><span class="line">arr.add(1);</span><br><span class="line">arr.add(2);</span><br><span class="line">arr.add(3);</span><br><span class="line">let ret = arr.getMax();</span><br><span class="line">console.log(ret);</span><br></pre></td></tr></table></figure><p>上诉例子我们实现了一个在数组里面添加数字并且获取最大值的泛型类</p><h5 id="6-5-泛型类型别名"><a href="#6-5-泛型类型别名" class="headerlink" title="6.5 泛型类型别名"></a><strong>6.5 泛型类型别名</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Cart&lt;T&gt; = &#123; list: T[] &#125; | T[];</span><br><span class="line">let c1: Cart&lt;string&gt; = &#123; list: [&quot;1&quot;] &#125;;</span><br><span class="line">let c2: Cart&lt;number&gt; = [1];</span><br></pre></td></tr></table></figure><h5 id="6-6-泛型参数的默认类型"><a href="#6-6-泛型参数的默认类型" class="headerlink" title="6.6 泛型参数的默认类型"></a><strong>6.6 泛型参数的默认类型</strong></h5><p>我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function createArray&lt;T = string&gt;(length: number, value: T): Array&lt;T&gt; &#123;</span><br><span class="line">  let result: T[] = [];</span><br><span class="line">  for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">    result[i] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-实用技巧"><a href="#7-实用技巧" class="headerlink" title="7 实用技巧"></a><strong>7 实用技巧</strong></h3><h5 id="7-1-typeof-关键词"><a href="#7-1-typeof-关键词" class="headerlink" title="7.1 typeof 关键词"></a><strong>7.1 typeof 关键词</strong></h5><p><code>typeof</code> 关键词除了做类型保护 还可以从实现推出类型，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> //先定义变量，再定义类型</span><br><span class="line">let p1 = &#123;</span><br><span class="line">  name: &quot;hello&quot;,</span><br><span class="line">  age: 10,</span><br><span class="line">  gender: &quot;male&quot;,</span><br><span class="line">&#125;;</span><br><span class="line">type People = typeof p1;</span><br><span class="line">function getName(p: People): string &#123;</span><br><span class="line">  return p.name;</span><br><span class="line">&#125;</span><br><span class="line">getName(p1);</span><br></pre></td></tr></table></figure><p>上面的例子就是使用 typeof 获取一个变量的类型</p><h5 id="7-2-keyof-关键词"><a href="#7-2-keyof-关键词" class="headerlink" title="7.2 keyof 关键词"></a><strong>7.2 keyof 关键词</strong></h5><p><code>keyof</code> 可以用来取得一个对象接口的所有 key 值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">  gender: &quot;male&quot; | &quot;female&quot;;</span><br><span class="line">&#125;</span><br><span class="line">//type PersonKey = &apos;name&apos;|&apos;age&apos;|&apos;gender&apos;;</span><br><span class="line">type PersonKey = keyof Person;</span><br><span class="line"></span><br><span class="line">function getValueByKey(p: Person, key: PersonKey) &#123;</span><br><span class="line">  return p[key];</span><br><span class="line">&#125;</span><br><span class="line">let val = getValueByKey(&#123; name: &quot;hello&quot;, age: 10, gender: &quot;male&quot; &#125;, &quot;name&quot;);</span><br><span class="line">console.log(val);</span><br></pre></td></tr></table></figure><h5 id="7-3-索引访问操作符"><a href="#7-3-索引访问操作符" class="headerlink" title="7.3 索引访问操作符"></a><strong>7.3 索引访问操作符</strong></h5><p>使用 [] 操作符可以进行索引访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type x = Person[&quot;name&quot;]; // x is string</span><br></pre></td></tr></table></figure><h5 id="7-4-映射类型-in"><a href="#7-4-映射类型-in" class="headerlink" title="7.4 映射类型 in"></a><strong>7.4 映射类型 in</strong></h5><p>在定义的时候用 in 操作符去批量定义类型中的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">  gender: &quot;male&quot; | &quot;female&quot;;</span><br><span class="line">&#125;</span><br><span class="line">//批量把一个接口中的属性都变成可选的</span><br><span class="line">type PartPerson = &#123;</span><br><span class="line">  [Key in keyof Person]?: Person[Key];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let p1: PartPerson = &#123;&#125;;</span><br></pre></td></tr></table></figure><h5 id="7-5-infer-关键字"><a href="#7-5-infer-关键字" class="headerlink" title="7.5 infer 关键字"></a><strong>7.5 infer 关键字</strong></h5><p>在条件类型语句中，可以用 infer 声明一个类型变量并且对它进行使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type ReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; infer R ? R : any;</span><br></pre></td></tr></table></figure><p>以上代码中 infer R 就是声明一个变量来承载传入函数签名的返回值类型，简单说就是用它取到函数返回值的类型方便之后使用。</p><h5 id="7-6-内置工具类型"><a href="#7-6-内置工具类型" class="headerlink" title="7.6 内置工具类型"></a><strong>7.6 内置工具类型</strong></h5><ol><li>Exclude&lt;T,U&gt; 从 T 可分配给的类型中排除 U</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Exclude&lt;T, U&gt; = T extends U ? never : T;</span><br><span class="line"></span><br><span class="line">type E = Exclude&lt;string | number, string&gt;;</span><br><span class="line">let e: E = 10;</span><br></pre></td></tr></table></figure><ol start="2"><li>Extract&lt;T,U&gt; 从 T 可分配给的类型中提取 U</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Extract&lt;T, U&gt; = T extends U ? T : never;</span><br><span class="line"></span><br><span class="line">type E = Extract&lt;string | number, string&gt;;</span><br><span class="line">let e: E = &quot;1&quot;;</span><br></pre></td></tr></table></figure><ol start="3"><li>NonNullable从 T 中排除 <code>null</code> 和 <code>undefined</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type NonNullable&lt;T&gt; = T extends null | undefined ? never : T;</span><br><span class="line"></span><br><span class="line">type E = NonNullable&lt;string | number | null | undefined&gt;;</span><br><span class="line">let e: E = null;</span><br></pre></td></tr></table></figure><ol start="4"><li>ReturnType<code>infer</code> 最早出现在此 PR 中，表示在 <code>extends</code> 条件语句中待推断的类型变量</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type ReturnType&lt;T extends (...args: any[]) =&gt; any&gt; = T extends (</span><br><span class="line">  ...args: any[]</span><br><span class="line">) =&gt; infer R</span><br><span class="line">  ? R</span><br><span class="line">  : any;</span><br><span class="line">function getUserInfo() &#123;</span><br><span class="line">  return &#123; name: &quot;hello&quot;, age: 10 &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通过 ReturnType 将 getUserInfo 的返回值类型赋给了 UserInfo</span><br><span class="line">type UserInfo = ReturnType&lt;typeof getUserInfo&gt;;</span><br><span class="line"></span><br><span class="line">const userA: UserInfo = &#123;</span><br><span class="line">  name: &quot;hello&quot;,</span><br><span class="line">  age: 10,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可见 该工具类型主要是获取函数类型的返回类型</p><ol start="5"><li>Parameters该工具类型主要是获取函数类型的参数类型</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Parameters&lt;T&gt; = T extends (...args: infer R) =&gt; any ? R : any;</span><br><span class="line"></span><br><span class="line">type T0 = Parameters&lt;() =&gt; string&gt;; // []</span><br><span class="line">type T1 = Parameters&lt;(s: string) =&gt; void&gt;; // [string]</span><br><span class="line">type T2 = Parameters&lt;&lt;T&gt;(arg: T) =&gt; T&gt;; // [unknown]</span><br></pre></td></tr></table></figure><ol start="6"><li>PartialPartial 可以将传入的属性由非可选变为可选</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type Partial&lt;T&gt; = &#123; [P in keyof T]?: T[P] &#125;;</span><br><span class="line">interface A &#123;</span><br><span class="line">  a1: string;</span><br><span class="line">  a2: number;</span><br><span class="line">  a3: boolean;</span><br><span class="line">&#125;</span><br><span class="line">type aPartial = Partial&lt;A&gt;;</span><br><span class="line">const a: aPartial = &#123;&#125;; // 不会报错</span><br></pre></td></tr></table></figure><ol start="7"><li>RequiredRequired 可以将传入的属性中的可选项变为必选项，这里用了 -? 修饰符来实现。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">  gender?: &quot;male&quot; | &quot;female&quot;;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">* type Required&lt;T&gt; = &#123; [P in keyof T]-?: T[P] &#125;;</span><br><span class="line">*/</span><br><span class="line">let p: Required&lt;Person&gt; = &#123;</span><br><span class="line">  name: &quot;hello&quot;,</span><br><span class="line">  age: 10,</span><br><span class="line">  gender: &quot;male&quot;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="8"><li>ReadonlyReadonly 通过为传入的属性每一项都加上 readonly 修饰符来实现。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">  gender?: &quot;male&quot; | &quot;female&quot;;</span><br><span class="line">&#125;</span><br><span class="line">//type Readonly&lt;T&gt; = &#123; readonly [P in keyof T]: T[P] &#125;;</span><br><span class="line">let p: Readonly&lt;Person&gt; = &#123;</span><br><span class="line">  name: &quot;hello&quot;,</span><br><span class="line">  age: 10,</span><br><span class="line">  gender: &quot;male&quot;,</span><br><span class="line">&#125;;</span><br><span class="line">p.age = 11; //error</span><br></pre></td></tr></table></figure><ol start="9"><li>Pick&lt;T,K&gt; Pick 能够帮助我们从传入的属性中摘取某些返回</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface Todo &#123;</span><br><span class="line">  title: string;</span><br><span class="line">  description: string;</span><br><span class="line">  done: boolean;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">* From T pick a set of properties K</span><br><span class="line">* type Pick&lt;T, K extends keyof T&gt; = &#123; [P in K]: T[P] &#125;;</span><br><span class="line">*/</span><br><span class="line">type TodoBase = Pick&lt;Todo, &quot;title&quot; | &quot;done&quot;&gt;;</span><br><span class="line"></span><br><span class="line">// =</span><br><span class="line">type TodoBase = &#123;</span><br><span class="line">  title: string;</span><br><span class="line">  done: boolean;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="10"><li>Record&lt;K,T&gt; 构造一个类型，该类型具有一组属性 K，每个属性的类型为 T。可用于将一个类型的属性映射为另一个类型。Record 后面的泛型就是对象键和值的类型。</li></ol><p>简单理解：K 对应对应的 key，T 对应对象的 value，返回的就是一个声明好的对象 但是 K 对应的泛型约束是<code>keyof any</code> 也就意味着只能传入 <code>string|number|symbol</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> // type Record&lt;K extends keyof any, T&gt; = &#123;</span><br><span class="line">// [P in K]: T;</span><br><span class="line">// &#125;;</span><br><span class="line">type Point = &quot;x&quot; | &quot;y&quot;;</span><br><span class="line">type PointList = Record&lt;Point, &#123; value: number &#125;&gt;;</span><br><span class="line">const cars: PointList = &#123;</span><br><span class="line">  x: &#123; value: 10 &#125;,</span><br><span class="line">  y: &#123; value: 20 &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="11"><li>Omit&lt;K,T&gt; 基于已经声明的类型进行属性剔除获得新类型</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> // type Omit=Pick&lt;T,Exclude&lt;keyof T,K&gt;&gt;</span><br><span class="line">type User = &#123;</span><br><span class="line">id: string;</span><br><span class="line">name: string;</span><br><span class="line">email: string;</span><br><span class="line">&#125;;</span><br><span class="line">type UserWithoutEmail = Omit&lt;User, &quot;email&quot;&gt;; // UserWithoutEmail =&#123;id: string;name: string;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="8-TypeScript-装饰器"><a href="#8-TypeScript-装饰器" class="headerlink" title="8 TypeScript 装饰器"></a><strong>8</strong> <strong>TypeScript</strong> <strong>装饰器</strong></h3><p>装饰器是一种特殊类型的声明，它能够被附加到类声明、方法、属性或参数上，可以修改类的行为</p><p>常见的装饰器有类装饰器、属性装饰器、方法装饰器和参数装饰器</p><p>装饰器的写法分为普通装饰器和装饰器工厂</p><p>使用@装饰器的写法需要把 tsconfig.json 的 <code>experimentalDecorators</code> 字段设置为 true</p><h5 id="8-1-类装饰器"><a href="#8-1-类装饰器" class="headerlink" title="8.1 类装饰器"></a><strong>8.1 类装饰器</strong></h5><p>类装饰器在类声明之前声明，用来监视、修改或替换类定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">namespace a &#123;</span><br><span class="line">  //当装饰器作为修饰类的时候，会把构造器传递进去</span><br><span class="line">  function addNameEat(constructor: Function) &#123;</span><br><span class="line">    constructor.prototype.name = &quot;hello&quot;;</span><br><span class="line">    constructor.prototype.eat = function () &#123;</span><br><span class="line">      console.log(&quot;eat&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  @addNameEat</span><br><span class="line">  class Person &#123;</span><br><span class="line">    name!: string;</span><br><span class="line">    eat!: Function;</span><br><span class="line">    constructor() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  let p: Person = new Person();</span><br><span class="line">  console.log(p.name);</span><br><span class="line">  p.eat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace b &#123;</span><br><span class="line">  //还可以使用装饰器工厂 这样可以传递额外参数</span><br><span class="line">  function addNameEatFactory(name: string) &#123;</span><br><span class="line">    return function (constructor: Function) &#123;</span><br><span class="line">      constructor.prototype.name = name;</span><br><span class="line">      constructor.prototype.eat = function () &#123;</span><br><span class="line">        console.log(&quot;eat&quot;);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  @addNameEatFactory(&quot;hello&quot;)</span><br><span class="line">  class Person &#123;</span><br><span class="line">    name!: string;</span><br><span class="line">    eat!: Function;</span><br><span class="line">    constructor() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  let p: Person = new Person();</span><br><span class="line">  console.log(p.name);</span><br><span class="line">  p.eat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namespace c &#123;</span><br><span class="line">  //还可以替换类,不过替换的类要与原类结构相同</span><br><span class="line">  function enhancer(constructor: Function) &#123;</span><br><span class="line">    return class &#123;</span><br><span class="line">      name: string = &quot;jiagou&quot;;</span><br><span class="line">      eat() &#123;</span><br><span class="line">        console.log(&quot;吃饭饭&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  @enhancer</span><br><span class="line">  class Person &#123;</span><br><span class="line">    name!: string;</span><br><span class="line">    eat!: Function;</span><br><span class="line">    constructor() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  let p: Person = new Person();</span><br><span class="line">  console.log(p.name);</span><br><span class="line">  p.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="8-2-属性装饰器"><a href="#8-2-属性装饰器" class="headerlink" title="8.2 属性装饰器"></a><strong>8.2 属性装饰器</strong></h5><p>属性装饰器表达式会在运行时当作函数被调用，传入 2 个参数 第一个参数对于静态成员来说是类的构造函数，对于实例成员是类的原型对象 第二个参数是属性的名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> //修饰实例属性</span><br><span class="line">function upperCase(target: any, propertyKey: string) &#123;</span><br><span class="line">  let value = target[propertyKey];</span><br><span class="line">  const getter = function () &#123;</span><br><span class="line">    return value;</span><br><span class="line">  &#125;;</span><br><span class="line">  // 用来替换的setter</span><br><span class="line">  const setter = function (newVal: string) &#123;</span><br><span class="line">    value = newVal.toUpperCase();</span><br><span class="line">  &#125;;</span><br><span class="line">  // 替换属性，先删除原先的属性，再重新定义属性</span><br><span class="line">  if (delete target[propertyKey]) &#123;</span><br><span class="line">    Object.defineProperty(target, propertyKey, &#123;</span><br><span class="line">      get: getter,</span><br><span class="line">      set: setter,</span><br><span class="line">      enumerable: true,</span><br><span class="line">      configurable: true,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">  @upperCase</span><br><span class="line">  name!: string;</span><br><span class="line">&#125;</span><br><span class="line">let p: Person = new Person();</span><br><span class="line">p.name = &quot;world&quot;;</span><br><span class="line">console.log(p.name);</span><br></pre></td></tr></table></figure><h5 id="8-3-方法装饰器"><a href="#8-3-方法装饰器" class="headerlink" title="8.3 方法装饰器"></a><strong>8.3 方法装饰器</strong></h5><p>方法装饰器顾名思义，用来装饰类的方法。它接收三个参数：target: Object - 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象 propertyKey: string | symbol - 方法名 descriptor: TypePropertyDescript - 属性描述符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> //修饰实例方法</span><br><span class="line">function noEnumerable(</span><br><span class="line">  target: any,</span><br><span class="line">  property: string,</span><br><span class="line">  descriptor: PropertyDescriptor</span><br><span class="line">) &#123;</span><br><span class="line">  console.log(&quot;target.getName&quot;, target.getName);</span><br><span class="line">  console.log(&quot;target.getAge&quot;, target.getAge);</span><br><span class="line">  descriptor.enumerable = false;</span><br><span class="line">&#125;</span><br><span class="line">//重写方法</span><br><span class="line">function toNumber(</span><br><span class="line">  target: any,</span><br><span class="line">  methodName: string,</span><br><span class="line">  descriptor: PropertyDescriptor</span><br><span class="line">) &#123;</span><br><span class="line">  let oldMethod = descriptor.value;</span><br><span class="line">  descriptor.value = function (...args: any[]) &#123;</span><br><span class="line">    args = args.map((item) =&gt; parseFloat(item));</span><br><span class="line">    return oldMethod.apply(this, args);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">class Person &#123;</span><br><span class="line">  name: string = &quot;hello&quot;;</span><br><span class="line">  public static age: number = 10;</span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line">  @noEnumerable</span><br><span class="line">  getName() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">  @toNumber</span><br><span class="line">  sum(...args: any[]) &#123;</span><br><span class="line">    return args.reduce((accu: number, item: number) =&gt; accu + item, 0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p: Person = new Person();</span><br><span class="line">for (let attr in p) &#123;</span><br><span class="line">  console.log(&quot;attr=&quot;, attr);</span><br><span class="line">&#125;</span><br><span class="line">p.getName();</span><br><span class="line">console.log(p.sum(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;));</span><br></pre></td></tr></table></figure><h5 id="8-4-参数装饰器"><a href="#8-4-参数装饰器" class="headerlink" title="8.4 参数装饰器"></a><strong>8.4 参数装饰器</strong></h5><p>参数装饰器顾名思义，是用来装饰函数参数，它接收三个参数：</p><p>target: Object - 被装饰的类 propertyKey: string | symbol - 方法名 parameterIndex: number - 方法中参数的索引值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Log(target: Function, key: string, parameterIndex: number) &#123;</span><br><span class="line">  let functionLogged = key || target.prototype.constructor.name;</span><br><span class="line">  console.log(`The parameter in position $&#123;parameterIndex&#125; at $&#123;functionLogged&#125; has</span><br><span class="line"> been decorated`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Greeter &#123;</span><br><span class="line">  greeting: string;</span><br><span class="line">  constructor(@Log phrase: string) &#123;</span><br><span class="line">    this.greeting = phrase;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码成功运行后，控制台会输出以下结果：<code>&quot;The parameter in position 0 at Greeter has been decorated&quot;</code></p><h5 id="8-5-装饰器执行顺序"><a href="#8-5-装饰器执行顺序" class="headerlink" title="8.5 装饰器执行顺序"></a><strong>8.5 装饰器执行顺序</strong></h5><p>有多个参数装饰器时：从最后一个参数依次向前执行</p><p>方法和方法参数中参数装饰器先执行。方法和属性装饰器，谁在前面谁先执行。因为参数属于方法一部分，所以参数会一直紧紧挨着方法执行</p><p>类装饰器总是最后执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">function Class1Decorator() &#123;</span><br><span class="line">  return function (target: any) &#123;</span><br><span class="line">    console.log(&quot;类1装饰器&quot;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">function Class2Decorator() &#123;</span><br><span class="line">  return function (target: any) &#123;</span><br><span class="line">    console.log(&quot;类2装饰器&quot;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">function MethodDecorator() &#123;</span><br><span class="line">  return function (</span><br><span class="line">    target: any,</span><br><span class="line">    methodName: string,</span><br><span class="line">    descriptor: PropertyDescriptor</span><br><span class="line">  ) &#123;</span><br><span class="line">    console.log(&quot;方法装饰器&quot;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">function Param1Decorator() &#123;</span><br><span class="line">  return function (target: any, methodName: string, paramIndex: number) &#123;</span><br><span class="line">    console.log(&quot;参数1装饰器&quot;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">function Param2Decorator() &#123;</span><br><span class="line">  return function (target: any, methodName: string, paramIndex: number) &#123;</span><br><span class="line">    console.log(&quot;参数2装饰器&quot;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">function PropertyDecorator(name: string) &#123;</span><br><span class="line">  return function (target: any, propertyName: string) &#123;</span><br><span class="line">    console.log(name + &quot;属性装饰器&quot;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Class1Decorator()</span><br><span class="line">@Class2Decorator()</span><br><span class="line">class Person &#123;</span><br><span class="line">  @PropertyDecorator(&quot;name&quot;)</span><br><span class="line">  name: string = &quot;hello&quot;;</span><br><span class="line">  @PropertyDecorator(&quot;age&quot;)</span><br><span class="line">  age: number = 10;</span><br><span class="line">  @MethodDecorator()</span><br><span class="line">  greet(@Param1Decorator() p1: string, @Param2Decorator() p2: string) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">name属性装饰器</span><br><span class="line">age属性装饰器</span><br><span class="line">参数2装饰器</span><br><span class="line">参数1装饰器</span><br><span class="line">方法装饰器</span><br><span class="line">类2装饰器</span><br><span class="line">类1装饰器</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h3 id="9-编译"><a href="#9-编译" class="headerlink" title="9 编译"></a><strong>9 编译</strong></h3><h5 id="9-1-tsconfig-json-的作用"><a href="#9-1-tsconfig-json-的作用" class="headerlink" title="9.1 tsconfig.json 的作用"></a><strong>9.1 tsconfig.json 的作用</strong></h5><ul><li>用于标识 TypeScript 项目的根路径；</li></ul><!----><ul><li>用于配置 TypeScript 编译器；</li></ul><!----><ul><li>用于指定编译的文件。</li></ul><h5 id="9-2-tsconfig-json-重要字段"><a href="#9-2-tsconfig-json-重要字段" class="headerlink" title="9.2 tsconfig.json 重要字段"></a><strong>9.2 tsconfig.json 重要字段</strong></h5><ul><li>files - 设置要编译的文件的名称；</li></ul><!----><ul><li>include - 设置需要进行编译的文件，支持路径模式匹配；</li></ul><!----><ul><li>exclude - 设置无需进行编译的文件，支持路径模式匹配；</li></ul><!----><ul><li>compilerOptions - 设置与编译流程相关的选项。</li></ul><h5 id="9-3-compilerOptions-选项"><a href="#9-3-compilerOptions-选项" class="headerlink" title="9.3 compilerOptions 选项"></a><strong>9.3 compilerOptions 选项</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line"></span><br><span class="line">    /* 基本选项 */</span><br><span class="line">    &quot;target&quot;: &quot;es5&quot;,                       // 指定 ECMAScript 目标版本: &apos;ES3&apos; (default), &apos;ES5&apos;, &apos;ES6&apos;/&apos;ES2015&apos;, &apos;ES2016&apos;, &apos;ES2017&apos;, or &apos;ESNEXT&apos;</span><br><span class="line">    &quot;module&quot;: &quot;commonjs&quot;,                  // 指定使用模块: &apos;commonjs&apos;, &apos;amd&apos;, &apos;system&apos;, &apos;umd&apos; or &apos;es2015&apos;</span><br><span class="line">    &quot;lib&quot;: [],                             // 指定要包含在编译中的库文件</span><br><span class="line">    &quot;allowJs&quot;: true,                       // 允许编译 javascript 文件</span><br><span class="line">    &quot;checkJs&quot;: true,                       // 报告 javascript 文件中的错误</span><br><span class="line">    &quot;jsx&quot;: &quot;preserve&quot;,                     // 指定 jsx 代码的生成: &apos;preserve&apos;, &apos;react-native&apos;, or &apos;react&apos;</span><br><span class="line">    &quot;declaration&quot;: true,                   // 生成相应的 &apos;.d.ts&apos; 文件</span><br><span class="line">    &quot;sourceMap&quot;: true,                     // 生成相应的 &apos;.map&apos; 文件</span><br><span class="line">    &quot;outFile&quot;: &quot;./&quot;,                       // 将输出文件合并为一个文件</span><br><span class="line">    &quot;outDir&quot;: &quot;./&quot;,                        // 指定输出目录</span><br><span class="line">    &quot;rootDir&quot;: &quot;./&quot;,                       // 用来控制输出目录结构 --outDir.</span><br><span class="line">    &quot;removeComments&quot;: true,                // 删除编译后的所有的注释</span><br><span class="line">    &quot;noEmit&quot;: true,                        // 不生成输出文件</span><br><span class="line">    &quot;importHelpers&quot;: true,                 // 从 tslib 导入辅助工具函数</span><br><span class="line">    &quot;isolatedModules&quot;: true,               // 将每个文件做为单独的模块 （与 &apos;ts.transpileModule&apos; 类似）.</span><br><span class="line"></span><br><span class="line">    /* 严格的类型检查选项 */</span><br><span class="line">    &quot;strict&quot;: true,                        // 启用所有严格类型检查选项</span><br><span class="line">    &quot;noImplicitAny&quot;: true,                 // 在表达式和声明上有隐含的 any类型时报错</span><br><span class="line">    &quot;strictNullChecks&quot;: true,              // 启用严格的 null 检查</span><br><span class="line">    &quot;noImplicitThis&quot;: true,                // 当 this 表达式值为 any 类型的时候，生成一个错误</span><br><span class="line">    &quot;alwaysStrict&quot;: true,                  // 以严格模式检查每个模块，并在每个文件里加入 &apos;use strict&apos;</span><br><span class="line"></span><br><span class="line">    /* 额外的检查 */</span><br><span class="line">    &quot;noUnusedLocals&quot;: true,                // 有未使用的变量时，抛出错误</span><br><span class="line">    &quot;noUnusedParameters&quot;: true,            // 有未使用的参数时，抛出错误</span><br><span class="line">    &quot;noImplicitReturns&quot;: true,             // 并不是所有函数里的代码都有返回值时，抛出错误</span><br><span class="line">    &quot;noFallthroughCasesInSwitch&quot;: true,    // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）</span><br><span class="line"></span><br><span class="line">    /* 模块解析选项 */</span><br><span class="line">    &quot;moduleResolution&quot;: &quot;node&quot;,            // 选择模块解析策略： &apos;node&apos; (Node.js) or &apos;classic&apos; (TypeScript pre-1.6)</span><br><span class="line">    &quot;baseUrl&quot;: &quot;./&quot;,                       // 用于解析非相对模块名称的基目录</span><br><span class="line">    &quot;paths&quot;: &#123;&#125;,                           // 模块名到基于 baseUrl 的路径映射的列表</span><br><span class="line">    &quot;rootDirs&quot;: [],                        // 根文件夹列表，其组合内容表示项目运行时的结构内容</span><br><span class="line">    &quot;typeRoots&quot;: [],                       // 包含类型声明的文件列表</span><br><span class="line">    &quot;types&quot;: [],                           // 需要包含的类型声明文件名列表</span><br><span class="line">    &quot;allowSyntheticDefaultImports&quot;: true,  // 允许从没有设置默认导出的模块中默认导入。</span><br><span class="line"></span><br><span class="line">    /* Source Map Options */</span><br><span class="line">    &quot;sourceRoot&quot;: &quot;./&quot;,                    // 指定调试器应该找到 TypeScript 文件而不是源文件的位置</span><br><span class="line">    &quot;mapRoot&quot;: &quot;./&quot;,                       // 指定调试器应该找到映射文件而不是生成文件的位置</span><br><span class="line">    &quot;inlineSourceMap&quot;: true,               // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件</span><br><span class="line">    &quot;inlineSources&quot;: true,                 // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性</span><br><span class="line"></span><br><span class="line">    /* 其他选项 */</span><br><span class="line">    &quot;experimentalDecorators&quot;: true,        // 启用装饰器</span><br><span class="line">    &quot;emitDecoratorMetadata&quot;: true          // 为装饰器提供元数据的支持</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-模块和声明文件"><a href="#10-模块和声明文件" class="headerlink" title="10 模块和声明文件"></a><strong>10 模块和声明文件</strong></h3><h5 id="10-1-全局模块"><a href="#10-1-全局模块" class="headerlink" title="10.1 全局模块"></a><strong>10.1 全局模块</strong></h5><p>在默认情况下，当你开始在一个新的 TypeScript 文件中写下代码时，它处于全局命名空间中</p><p>使用全局变量空间是危险的，因为它会与文件内的代码命名冲突。我们推荐使用下文中将要提到的文件模块</p><p>foo.ts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const foo = 123;</span><br></pre></td></tr></table></figure><p>bar.ts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const bar = foo; // allowed</span><br></pre></td></tr></table></figure><h5 id="10-2-文件模块"><a href="#10-2-文件模块" class="headerlink" title="10.2 文件模块"></a><strong>10.2 文件模块</strong></h5><ul><li>文件模块也被称为外部模块。如果在你的 TypeScript 文件的根级别位置含有 import 或者 export，那么它会在这个文件中创建一个本地的作用域</li></ul><!----><ul><li>模块是 TS 中外部模块的简称，侧重于代码和复用</li></ul><!----><ul><li>模块在其自身的作用域里执行，而不是在全局作用域里</li></ul><!----><ul><li>一个模块里的变量、函数、类等在外部是不可见的，除非你把它导出</li></ul><!----><ul><li>如果想要使用一个模块里导出的变量，则需要导入</li></ul><p>foo.ts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const foo = 123;</span><br><span class="line">export &#123;&#125;;</span><br></pre></td></tr></table></figure><p>bar.ts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const bar = foo; // error</span><br></pre></td></tr></table></figure><h5 id="10-3-声明文件"><a href="#10-3-声明文件" class="headerlink" title="10.3 声明文件"></a><strong>10.3 声明文件</strong></h5><ul><li>我们可以把类型声明放在一个单独的类型声明文件中</li></ul><!----><ul><li>文件命名规范为*.d.ts</li></ul><!----><ul><li>查看类型声明文件有助于了解库的使用方式</li></ul><p>typings\jquery.d.ts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">declare const $: (selector: string) =&gt; &#123;</span><br><span class="line">  click(): void;</span><br><span class="line">  width(length: number): void;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="10-4-第三方声明文件"><a href="#10-4-第三方声明文件" class="headerlink" title="10.4 第三方声明文件"></a><strong>10.4 第三方声明文件</strong></h5><ul><li>可以安装使用第三方的声明文件</li></ul><!----><ul><li>@types 是一个约定的前缀，所有的第三方声明的类型库都会带有这样的前缀</li></ul><!----><ul><li>JavaScript 中有很多内置对象，它们可以在 TypeScript 中被当做声明好了的类型</li></ul><!----><ul><li>内置对象是指根据标准在全局作用域（Global）上存在的对象。这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准</li></ul><!----><ul><li>这些内置对象的类型声明文件，就包含在 TypeScript 核心库的类型声明文件中,具体可以查看ts 核心声明文件</li></ul><h5 id="10-5-查找声明文件"><a href="#10-5-查找声明文件" class="headerlink" title="10.5 查找声明文件"></a><strong>10.5 查找声明文件</strong></h5><ul><li>如果是手动写的声明文件，那么需要满足以下条件之一，才能被正确的识别</li></ul><!----><ul><li>给 package.json 中的 types 或 typings 字段指定一个类型声明文件地址</li></ul><!----><ul><li>在项目根目录下，编写一个 index.d.ts 文件</li></ul><!----><ul><li>针对入口文件（package.json 中的 main 字段指定的入口文件），编写一个同名不同后缀的 .d.ts 文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;myLib&quot;,</span><br><span class="line">    &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">    &quot;main&quot;: &quot;lib/index.js&quot;,</span><br><span class="line">    &quot;types&quot;: &quot;myLib.d.ts&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找过程如下：</p><p>1.先找 myLib.d.ts</p><p>2.没有就再找 index.d.ts</p><p>3.还没有再找 lib/index.d.js</p><p>4.还找不到就认为没有类型声明了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-ts-安装和编译&quot;&gt;&lt;a href=&quot;#1-ts-安装和编译&quot; class=&quot;headerlink&quot; title=&quot;1 ts 安装和编译&quot;&gt;&lt;/a&gt;&lt;strong&gt;1&lt;/strong&gt; &lt;strong&gt;ts&lt;/strong&gt; &lt;strong&gt;安装和编译&lt;/st
      
    
    </summary>
    
      <category term="前端" scheme="https://skhon.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Web" scheme="https://skhon.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>探索garfish源码</title>
    <link href="https://skhon.github.io/2021/12/28/fe/garfish/"/>
    <id>https://skhon.github.io/2021/12/28/fe/garfish/</id>
    <published>2021-12-28T09:21:46.644Z</published>
    <updated>2021-12-28T12:40:40.133Z</updated>
    
    <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>首先，可以在github上把代码拉到本地，地址为：<a href="https://github.com/modern-js-dev/garfish" target="_blank" rel="noopener">https://github.com/modern-js-dev/garfish</a><br>然后就需要把项目跑起来，方便调试。总共四步即可：</p><ol><li>全局安装pnpm：<blockquote><p>$ npm i -g pnpm</p></blockquote></li><li>安装依赖<blockquote><p>$ pnpm install</p></blockquote></li><li>启动build:watch<blockquote><p>$ pnpm build:watch</p></blockquote></li><li>启动dev<blockquote><p>$ pnpm dev<br>这样就跑起来了。整体框架代码讲解主要以流程为主，一些细节性逻辑就直接跳过，有兴趣的同学可以翻源码。</p></blockquote><h1 id="在主应用中引入Garfish实例："><a href="#在主应用中引入Garfish实例：" class="headerlink" title="在主应用中引入Garfish实例："></a>在主应用中引入Garfish实例：</h1>在主应用中，首先引入Garfish实例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// dev/main/src/index.ts</span><br><span class="line">import GarfishInstance from &apos;garfish&apos;;</span><br></pre></td></tr></table></figure></li></ol><p>先看一下这个实例是个啥，追溯一下源码，发现Garfish实例是一个函数返回的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// packages/garfish/src/index.ts</span><br><span class="line">function createContext(): Garfish &#123;</span><br><span class="line">  // ...</span><br><span class="line">  // Existing garfish instance, direct return</span><br><span class="line">  if (inBrowser() &amp;&amp; window[&apos;__GARFISH__&apos;] &amp;&amp; window[&apos;Garfish&apos;]) &#123;</span><br><span class="line">    return window[&apos;Garfish&apos;];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const GarfishInstance = new Garfish(&#123;</span><br><span class="line">    plugins: [GarfishRouter(), GarfishBrowserVm(), GarfishBrowserSnapshot()],</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line">  </span><br><span class="line">  return GarfishInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>createContext可以理解为创建上下文环境，从上至下捋一下，如果是浏览器环境，并且window上存在Garfish对象，则直接返回（熟悉设计模式的同学，应该知道这是一个单例模式）。接下来new了一个Garfish对象，并且默认传入了一个对象 { plugins: [GarfishRouter(), GarfishBrowserVm(), GarfishBrowserSnapshot()] }。这是初始化了三个插件，我们继续看一下这三个插件长什么样子。<br>我们先看一下GarfishRouter<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// packages/router/src/index.ts</span><br><span class="line">export function GarfishRouter(_args?: Options) &#123;</span><br><span class="line">  return function (Garfish: interfaces.Garfish): interfaces.Plugin &#123;</span><br><span class="line">    Garfish.apps = &#123;&#125;;</span><br><span class="line">    Garfish.router = router;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      name: &apos;router&apos;,</span><br><span class="line">      version: __VERSION__,</span><br><span class="line"></span><br><span class="line">      bootstrap(options: interfaces.Options) &#123;</span><br><span class="line">        // ...</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      registerApp(appInfos) &#123;</span><br><span class="line">        // ...</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到GarfishRouter()返回的是一个function，形成闭包，最后会返回一个对象。这个对象其实是一个插件的格式，有name、version，还有生命周期钩子bootstrap、registerApp，生命周期钩子我们后续会介绍到，这里大家了解就行。再看看其他两个插件是什么：<br>GarfishBorwserVm:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// packages/browser-vm/src/pluginify.ts</span><br><span class="line">export function GarfishBrowserVm() &#123;</span><br><span class="line">  return function (Garfish: interfaces.Garfish): interfaces.Plugin &#123;</span><br><span class="line">    Garfish.getGlobalObject = function () &#123;</span><br><span class="line">      return Sandbox.getNativeWindow();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Garfish.setGlobalValue = function (key, value) &#123;</span><br><span class="line">      return (this.getGlobalObject()[key] = value);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Garfish.clearEscapeEffect = function (key, value) &#123;</span><br><span class="line">      const global = this.getGlobalObject();</span><br><span class="line">      if (key in global) &#123;</span><br><span class="line">        global[key] = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return createOptions(Garfish);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createOptions(Garfish: interfaces.Garfish) &#123;</span><br><span class="line">  // ...</span><br><span class="line">  const options: interfaces.Plugin = &#123;</span><br><span class="line">    name: &apos;browser-vm&apos;,</span><br><span class="line">    version: __VERSION__,</span><br><span class="line"></span><br><span class="line">    afterLoad(appInfo, appInstance) &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    // If the app is uninstalled, the sandbox needs to clear all effects and then reset</span><br><span class="line">    afterUnmount(appInfo, appInstance, isCacheMode) &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    afterMount(appInfo, appInstance) &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  return options;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>GarfishBrowserSnapshot:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// packages/browser-snapshot/src/index.ts</span><br><span class="line">export function GarfishBrowserSnapshot(op?: BrowserConfig) &#123;</span><br><span class="line">  return function (Garfish: interfaces.Garfish): interfaces.Plugin &#123;</span><br><span class="line">    const config: BrowserConfig = op || &#123; open: true &#125;;</span><br><span class="line"></span><br><span class="line">    const options = &#123;</span><br><span class="line">      openBrowser: false,</span><br><span class="line">      version: __VERSION__,</span><br><span class="line">      name: &apos;browser-snapshot&apos;,</span><br><span class="line"></span><br><span class="line">      afterLoad(appInfo, appInstance) &#123;</span><br><span class="line">        // ...</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      beforeMount(appInfo, appInstance) &#123;</span><br><span class="line">        // ...</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      afterUnmount(appInfo, appInstance) &#123;</span><br><span class="line">        // ...</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    return options;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到都是返回一个函数，并且这个函数的返回格式有点类似，其实这就是garfish插件的形式，返回一个函数，该函数返回一个对象，这个对象包含了这个插件的一些信息，可以总结成这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name: &apos;&apos;,</span><br><span class="line">    version: &apos;&apos;,</span><br><span class="line">    lifecycle: &apos;&apos; // 这里的lifecycle是泛指生命周期的钩子函数，具体指bootstrap、beforeBootstrap等等</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>插件中生命周期的具体实现，放在后面讲述。这里暂时把代码运行链路拉通。接下来再返回Garfish类的实现，它的实例是什么样子的。<br>Garfish类的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">// packages/core/src/garfish.ts</span><br><span class="line">export class Garfish extends EventEmitter2 &#123;</span><br><span class="line">  public running = false;</span><br><span class="line">  public version = __VERSION__;</span><br><span class="line">  public flag = __GARFISH_FLAG__; // A unique identifier</span><br><span class="line">  public loader = new Loader();</span><br><span class="line">  public hooks = globalLifecycle();</span><br><span class="line">  public channel = new EventEmitter2();</span><br><span class="line">  public options = createDefaultOptions();</span><br><span class="line">  public externals: Record&lt;string, any&gt; = &#123;&#125;;</span><br><span class="line">  public activeApps: Array&lt;interfaces.App&gt; = [];</span><br><span class="line">  public plugins: interfaces.Plugins = &#123;&#125; as any;</span><br><span class="line">  public cacheApps: Record&lt;string, interfaces.App&gt; = &#123;&#125;;</span><br><span class="line">  public appInfos: Record&lt;string, interfaces.AppInfo&gt; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  private nestedSwitch = false;</span><br><span class="line">  private loading: Record&lt;string, Promise&lt;any&gt; | null&gt; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  get props(): Record&lt;string, any&gt; &#123;</span><br><span class="line">    return (this.options &amp;&amp; this.options.props) || DEFAULT_PROPS.get(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  constructor(options: interfaces.Options) &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.setOptions(options);</span><br><span class="line">    DEFAULT_PROPS.set(this, &#123;&#125;);</span><br><span class="line">    this.options.plugins?.forEach((plugin) =&gt; this.usePlugin(plugin));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private setOptions(options: Partial&lt;interfaces.Options&gt;) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  createPluginSystem&lt;T extends (api: typeof HOOKS_API) =&gt; any&gt;(callback: T) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  usePlugin(</span><br><span class="line">    plugin: (context: Garfish) =&gt; interfaces.Plugin,</span><br><span class="line">    ...args: Array&lt;any&gt;</span><br><span class="line">  ) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run(options: interfaces.Options = &#123;&#125;) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  registerApp(list: interfaces.AppInfo | Array&lt;interfaces.AppInfo&gt;) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setExternal(nameOrExtObj: string | Record&lt;string, any&gt;, value?: any) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async loadApp(</span><br><span class="line">    appName: string,</span><br><span class="line">    optionsOrUrl?: Omit&lt;interfaces.AppInfo, &apos;name&apos;&gt;,</span><br><span class="line">  ): Promise&lt;interfaces.App | null&gt; &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>先看一下钩子函数中，做了什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// packages/core/src/garfish.ts</span><br><span class="line">constructor(options: interfaces.Options) &#123;</span><br><span class="line">    super();</span><br><span class="line">    // 传入的options（其实就是默认的那三个插件） 深度merge到默认的options上。</span><br><span class="line">    this.setOptions(options);</span><br><span class="line">    DEFAULT_PROPS.set(this, &#123;&#125;);</span><br><span class="line">    // 这里分别执行默认的三个插件</span><br><span class="line">    this.options.plugins?.forEach((plugin) =&gt; this.usePlugin(plugin));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>this.setOptions(options)主要是把传入的options深度merge到默认的options中。而传入的options就是传入的那三个默认插件。我们看一下默认的options有哪些属性吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// packages/core/src/config.ts</span><br><span class="line">export const createDefaultOptions = (nested = false) =&gt; &#123;</span><br><span class="line">  const config: interfaces.Options = &#123;</span><br><span class="line">    // global config</span><br><span class="line">    appID: &apos;&apos;,</span><br><span class="line">    apps: [],</span><br><span class="line">    autoRefreshApp: true,</span><br><span class="line">    disableStatistics: false,</span><br><span class="line">    disablePreloadApp: false,</span><br><span class="line">    // app config</span><br><span class="line">    basename: &apos;/&apos;,</span><br><span class="line">    props: &#123;&#125;,</span><br><span class="line">    // Use an empty div by default</span><br><span class="line">    domGetter: () =&gt; document.createElement(&apos;div&apos;),</span><br><span class="line">    sandbox: &#123;</span><br><span class="line">      snapshot: false,</span><br><span class="line">      disableWith: false,</span><br><span class="line">      strictIsolation: false,</span><br><span class="line">    &#125;,</span><br><span class="line">    // global hooks</span><br><span class="line">    beforeLoad: () =&gt; &#123;&#125;,</span><br><span class="line">    afterLoad: () =&gt; &#123;&#125;,</span><br><span class="line">    errorLoadApp: (e) =&gt; error(e),</span><br><span class="line">    // Router</span><br><span class="line">    onNotMatchRouter: () =&gt; &#123;&#125;,</span><br><span class="line">    // app hooks</span><br><span class="line">    // Code eval hooks</span><br><span class="line">    beforeEval: () =&gt; &#123;&#125;,</span><br><span class="line">    afterEval: () =&gt; &#123;&#125;,</span><br><span class="line">    // App mount hooks</span><br><span class="line">    beforeMount: () =&gt; &#123;&#125;,</span><br><span class="line">    afterMount: () =&gt; &#123;&#125;,</span><br><span class="line">    beforeUnmount: () =&gt; &#123;&#125;,</span><br><span class="line">    afterUnmount: () =&gt; &#123;&#125;,</span><br><span class="line">    // Error hooks</span><br><span class="line">    errorMountApp: (e) =&gt; error(e),</span><br><span class="line">    errorUnmountApp: (e) =&gt; error(e),</span><br><span class="line">    customLoader: null, // deprecated</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  if (nested) &#123;</span><br><span class="line">    invalidNestedAttrs.forEach((key) =&gt; delete config[key]);</span><br><span class="line">  &#125;</span><br><span class="line">  return config;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>再回到构造函数中，接下来分别对plugins进行usePlugin操作，其实就是为了拿到插件中的一些属性，并且进行一些注册操作。我们看一下usePlugin做了些什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// packages/core/src/garfish.ts</span><br><span class="line">usePlugin(</span><br><span class="line">    plugin: (context: Garfish) =&gt; interfaces.Plugin,</span><br><span class="line">    ...args: Array&lt;any&gt;</span><br><span class="line">  ) &#123;</span><br><span class="line">   // ...</span><br><span class="line">   </span><br><span class="line">    // this指向是Garfish类</span><br><span class="line">    args.unshift(this); </span><br><span class="line">    </span><br><span class="line">    // 执行传入的plugin</span><br><span class="line">    const pluginConfig = plugin.apply(null, args) as interfaces.Plugin;</span><br><span class="line">    assert(pluginConfig.name, &apos;The plugin must have a name.&apos;);</span><br><span class="line"></span><br><span class="line">    // 如果没有注册过，则进行注册 </span><br><span class="line">    if (!this.plugins[pluginConfig.name]) &#123;</span><br><span class="line">      this.plugins[pluginConfig.name] = pluginConfig;</span><br><span class="line">      // Register hooks, Compatible with the old api</span><br><span class="line">      this.hooks.usePlugin(pluginConfig);</span><br><span class="line">    &#125; else if (__DEV__) &#123;</span><br><span class="line">      warn(&apos;Please do not register the plugin repeatedly.&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>args数组首位是Garfish自己，然后获取插件配置，前面我们提到了，插件最后的返回是一个对象，里面包含name、version、生命周期钩子等。然后plugin.apply()就是返回的这些配置，并且赋值给了pluginConfig。接下来就是注册逻辑了，如果之前没有注册过该plugin，则进行注册，就是key为plugin的name，value为具体的配置形式，放在this.plugins对象中，这个好理解，接下来是进行this.hooks.usePlugin(pluginConfig)操作，这个其实是用来注册生命周期的，看一下this.hooks是啥，再构造函数中，是这么初始化hooks的：<br>// packages/core/src/garfish.ts<br>public hooks = globalLifecycle();<br>通过函数名，也应该能猜得到，全局生命周期的hooks。接着看globalLifeCycle实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// packages/core/src/lifecycle.ts</span><br><span class="line">export function globalLifecycle() &#123;</span><br><span class="line">  return new PluginSystem(&#123;</span><br><span class="line">    beforeBootstrap: new SyncHook&lt;[interfaces.Options], void&gt;(),</span><br><span class="line">    bootstrap: new SyncHook&lt;[interfaces.Options], void&gt;(),</span><br><span class="line">    beforeRegisterApp: new SyncHook&lt;[interfaces.AppInfo | Array&lt;interfaces.AppInfo&gt;], void&gt;(),</span><br><span class="line">    registerApp: new SyncHook&lt;[Record&lt;string, interfaces.AppInfo&gt;], void&gt;(),</span><br><span class="line">    beforeLoad: new AsyncHook&lt;[interfaces.AppInfo], Promise&lt;boolean | void&gt; | void | boolean&gt;(),</span><br><span class="line">    afterLoad: new AsyncHook&lt;[interfaces.AppInfo, interfaces.App], void&gt;(),</span><br><span class="line">    errorLoadApp: new SyncHook&lt;[Error, interfaces.AppInfo], void&gt;(),</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>返回的是一个pluginSystem实例，传入一个对象，包含7个生命周期属性。先看pluginSystem类的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// packages/hooks/src/pluginSystem.ts</span><br><span class="line">export class PluginSystem&lt;T extends Record&lt;string, any&gt;&gt; &#123;</span><br><span class="line">  lifecycle: T;</span><br><span class="line">  lifecycleKeys: Array&lt;keyof T&gt;;</span><br><span class="line">  private registerPlugins: Record&lt;string, Plugin&lt;T&gt;&gt; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  constructor(lifecycle: T) &#123;</span><br><span class="line">    /*</span><br><span class="line">      lifecycle: </span><br><span class="line">      &#123;</span><br><span class="line">        beforeBootstrap: new SyncHook&lt;[interfaces.Options], void&gt;(),</span><br><span class="line">        bootstrap: new SyncHook&lt;[interfaces.Options], void&gt;(),</span><br><span class="line">        beforeRegisterApp: new SyncHook&lt;[interfaces.AppInfo | Array&lt;interfaces.AppInfo&gt;], void&gt;(),</span><br><span class="line">        registerApp: new SyncHook&lt;[Record&lt;string, interfaces.AppInfo&gt;], void&gt;(),</span><br><span class="line">        beforeLoad: new AsyncHook&lt;[interfaces.AppInfo], Promise&lt;boolean | void&gt; | void | boolean&gt;(),</span><br><span class="line">        afterLoad: new AsyncHook&lt;[interfaces.AppInfo, interfaces.App], void&gt;(),</span><br><span class="line">        errorLoadApp: new SyncHook&lt;[Error, interfaces.AppInfo], void&gt;(),</span><br><span class="line">      &#125;</span><br><span class="line">    */</span><br><span class="line">    this.lifecycle = lifecycle;</span><br><span class="line">    this.lifecycleKeys = Object.keys(lifecycle);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  usePlugin(plugin: Plugin&lt;T&gt;) &#123;</span><br><span class="line">    assert(isPlainObject(plugin), &apos;Invalid plugin configuration.&apos;);</span><br><span class="line">    // Plugin name is required and unique</span><br><span class="line">    const pluginName = plugin.name;</span><br><span class="line">    assert(pluginName, &apos;Plugin must provide a name.&apos;);</span><br><span class="line"></span><br><span class="line">    if (!this.registerPlugins[pluginName]) &#123;</span><br><span class="line">      this.registerPlugins[pluginName] = plugin;</span><br><span class="line"></span><br><span class="line">      for (const key in this.lifecycle) &#123;</span><br><span class="line">        const pluginLife = plugin[key as string];</span><br><span class="line">        if (pluginLife) &#123;</span><br><span class="line">          // Differentiate different types of hooks and adopt different registration strategies</span><br><span class="line">          this.lifecycle[key].on(pluginLife);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (__DEV__) &#123;</span><br><span class="line">      warn(`Repeat to register plugin hooks &quot;$&#123;pluginName&#125;&quot;.`);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removePlugin(pluginName: string) &#123;</span><br><span class="line">    assert(pluginName, &apos;Must provide a name.&apos;);</span><br><span class="line">    const plugin = this.registerPlugins[pluginName];</span><br><span class="line">    assert(plugin, `plugin &quot;$&#123;pluginName&#125;&quot; is not registered.`);</span><br><span class="line"></span><br><span class="line">    for (const key in plugin) &#123;</span><br><span class="line">      this.lifecycle[key].remove(plugin[key as string]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到上面提到的this.hooks.usePlugin其实是执行了pluginSystem类中的usePlugin方法，实现逻辑也是会在pluginSystem类中的registerPlugins进行注册，然后会在全局生命周期的不同钩子上，注册每个插件配置中对应的钩子函数。这个大家需要好好理解一下，这个设计我们在写自己的框架时可以学习一下。再返回到创建pluginSystem实例中，传入的几个hooks，主要包含两种，一种是同步的SyncHook，另一种是异步的AsyncHook。看一下这两类hooks的实现。<br>SyncHook：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// packages/hooks/src/syncHook.ts</span><br><span class="line">export class SyncHook&lt;T, K&gt; &#123;</span><br><span class="line">  public type: string = &apos;&apos;;</span><br><span class="line">  public listeners = new Set&lt;Callback&lt;T, K&gt;&gt;();</span><br><span class="line"></span><br><span class="line">  constructor(type?: string) &#123;</span><br><span class="line">    if (type) this.type = type;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  on(fn: Callback&lt;T, K&gt;) &#123;</span><br><span class="line">    if (typeof fn === &apos;function&apos;) &#123;</span><br><span class="line">      this.listeners.add(fn);</span><br><span class="line">    &#125; else if (__DEV__) &#123;</span><br><span class="line">      warn(&apos;Invalid parameter in &quot;Hook&quot;.&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  once(fn: Callback&lt;T, K&gt;) &#123;</span><br><span class="line">    const self = this;</span><br><span class="line">    this.on(function wrapper(...args: Array&lt;any&gt;) &#123;</span><br><span class="line">      self.remove(wrapper);</span><br><span class="line">      return fn.apply(null, args);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  emit(...data: ArgsType&lt;T&gt;) &#123;</span><br><span class="line">    if (this.listeners.size &gt; 0) &#123;</span><br><span class="line">      this.listeners.forEach((fn) =&gt; fn.apply(null, data));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  remove(fn: Callback&lt;T, K&gt;) &#123;</span><br><span class="line">    return this.listeners.delete(fn);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeAll() &#123;</span><br><span class="line">    this.listeners.clear();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>就是一个简单的发布订阅模式。<br>AsyncHook：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// packages/hooks/src/asyncHook.ts</span><br><span class="line">export class AsyncHook&lt;T, K&gt; extends SyncHook&lt;T, K&gt; &#123;</span><br><span class="line">  emit(...data: ArgsType&lt;T&gt;): Promise&lt;void | false&gt; &#123;</span><br><span class="line">    let result;</span><br><span class="line">    const ls = Array.from(this.listeners);</span><br><span class="line">    if (ls.length &gt; 0) &#123;</span><br><span class="line">      let i = 0;</span><br><span class="line">      const call = (prev?: any) =&gt; &#123;</span><br><span class="line">        if (prev === false) &#123;</span><br><span class="line">          return false; // Abort process</span><br><span class="line">        &#125; else if (i &lt; ls.length) &#123;</span><br><span class="line">          return Promise.resolve(ls[i++].apply(null, data)).then(call);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      result = call();</span><br><span class="line">    &#125;</span><br><span class="line">    return Promise.resolve(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>AsyncHook的emit实现，可以理解将一串的异步函数，进行同步处理，上一个异步函数的返回，是下一个异步函数的入参，如果看过Koa中间件的实现，就很容易明白这样逻辑的实现了。<br>到目前为止，当主应用引入Garfish后，初步的注册工作基本完成了。</p><h1 id="主应用中启动Garfish"><a href="#主应用中启动Garfish" class="headerlink" title="主应用中启动Garfish"></a>主应用中启动Garfish</h1><p>我们先假设主应用默认路由就是/，不默认展示子应用。<br>再看主应用如何进行下一步的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// main/src/index.ts</span><br><span class="line">import GarfishInstance from &apos;garfish&apos;; </span><br><span class="line">import &#123; Config &#125; from &apos;./config&apos;;</span><br><span class="line"></span><br><span class="line">GarfishInstance.run(Config);</span><br><span class="line">第一行代码，我们已经在上面介绍过了，继续往下走，看看Config是什么：</span><br><span class="line">// dev/main/src/config.ts</span><br><span class="line">let defaultConfig: interfaces.Options = &#123;</span><br><span class="line">  basename: &apos;/garfish_master&apos;,</span><br><span class="line">  domGetter: () =&gt; &#123;</span><br><span class="line">    // await asyncTime();</span><br><span class="line">    return document.querySelector(&apos;#submoduleByRouter&apos;);</span><br><span class="line">  &#125;,</span><br><span class="line">  apps: [</span><br><span class="line">    // &#123;</span><br><span class="line">    //   name: &apos;vue&apos;,</span><br><span class="line">    //   activeWhen: &apos;/vue&apos;,</span><br><span class="line">    //   cache: false,</span><br><span class="line">    //   entry: &apos;http://localhost:2666&apos;,</span><br><span class="line">    // &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name: &apos;vue2&apos;,</span><br><span class="line">      cache: false,</span><br><span class="line">      activeWhen: &apos;/vue2&apos;,</span><br><span class="line">      entry: &apos;http://localhost:2777&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name: &apos;react&apos;,</span><br><span class="line">      activeWhen: &apos;/react&apos;,</span><br><span class="line">      entry: &apos;http://localhost:2444&apos;,</span><br><span class="line">      props: &#123;</span><br><span class="line">        appName: &apos;react&apos;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  autoRefreshApp: false,</span><br><span class="line">  disablePreloadApp: true,</span><br><span class="line">  protectVariable: [&apos;MonitoringInstance&apos;, &apos;Garfish&apos;],</span><br><span class="line">  sandbox: &#123;</span><br><span class="line">    open: true,</span><br><span class="line">    // strictIsolation: true,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // beforeMount(appInfo) &#123;</span><br><span class="line">  //   console.log(&apos;beforeMount&apos;, appInfo);</span><br><span class="line">  // &#125;,</span><br><span class="line"></span><br><span class="line">  // afterLoad(info, app) &#123;</span><br><span class="line">  //   console.log(app.vmSandbox);</span><br><span class="line">  // &#125;,</span><br><span class="line"></span><br><span class="line">  customLoader() &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这个默认配置，是用户可以自定义的，通过之前的源码分析，这些配置最后会深度merge到Garfish类中的默认配置。接下来就是GarfishInstance.run(Config)，将配置传入，然后执行Garfish类中的run方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// packages/core/src/garfish.ts</span><br><span class="line">run(options: interfaces.Options = &#123;&#125;) &#123;</span><br><span class="line">    if (this.running) &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.setOptions(options);</span><br><span class="line">    // Register plugins</span><br><span class="line">    this.usePlugin(GarfishHMRPlugin());</span><br><span class="line">    this.usePlugin(GarfishPerformance());</span><br><span class="line">    if (!this.options.disablePreloadApp) &#123;</span><br><span class="line">      this.usePlugin(GarfishPreloadPlugin());</span><br><span class="line">    &#125;</span><br><span class="line">    options.plugins?.forEach((plugin) =&gt; this.usePlugin(plugin));</span><br><span class="line">    // Put the lifecycle plugin at the end, so that you can get the changes of other plugins</span><br><span class="line">    this.usePlugin(GarfishOptionsLife(this.options, &apos;global-lifecycle&apos;));</span><br><span class="line"></span><br><span class="line">    // Emit hooks and register apps</span><br><span class="line">    this.hooks.lifecycle.beforeBootstrap.emit(this.options);</span><br><span class="line">    this.registerApp(this.options.apps || []);</span><br><span class="line">    this.running = true;</span><br><span class="line">    this.hooks.lifecycle.bootstrap.emit(this.options);</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>首先还是把传入的options参数深度merge到Garfish默认的options中，接着进行一些插件注册，最后注册了一个名为global-lifecycle的插件，这个插件主要是用来兜底的，因为插件注册是有先后顺序的，先注册的插件，在实行生命钩子方法时，是先执行的，所以global-lifecycle这个插件中，传入的生命周期钩子方法是用户可以自定义传入的，那么最后执行的时候，global-lifecycle拿到的是所有插件中最后的数据，方便调试。<br>接下来就是触发生命周期中beforeBootstrap，之前所有的插件中，所有beforeBootstrap的钩子都注册到了全局beforeBootstrap中，这个时候进行emit操作。如果用户没有传入自定义plugin(已经定义了beforeBootstrap方法)的话，这里应该是没有可执行方法的，因为框架内置的一些插件中没有该方法。<br>接下来就是注册app了，我们在主应用中的options中，有个apps的属性，里面注册着所有子应用。看一下registreApp的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// packages/core/src/garfish.ts</span><br><span class="line">registerApp(list: interfaces.AppInfo | Array&lt;interfaces.AppInfo&gt;) &#123;</span><br><span class="line">    const currentAdds = &#123;&#125;;</span><br><span class="line">    this.hooks.lifecycle.beforeRegisterApp.emit(list);</span><br><span class="line">    if (!Array.isArray(list)) list = [list];</span><br><span class="line"></span><br><span class="line">    for (const appInfo of list) &#123;</span><br><span class="line">      assert(appInfo.name, &apos;Miss app.name.&apos;);</span><br><span class="line">      if (!this.appInfos[appInfo.name]) &#123;</span><br><span class="line">        assert(</span><br><span class="line">          appInfo.entry,</span><br><span class="line">          `$&#123;appInfo.name&#125; application entry is not url: $&#123;appInfo.entry&#125;`,</span><br><span class="line">        );</span><br><span class="line">        currentAdds[appInfo.name] = appInfo;</span><br><span class="line">        this.appInfos[appInfo.name] = appInfo;</span><br><span class="line">      &#125; else if (__DEV__) &#123;</span><br><span class="line">        warn(`The &quot;$&#123;appInfo.name&#125;&quot; app is already registered.`);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    this.hooks.lifecycle.registerApp.emit(currentAdds);</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>首先执行生命周期beforeRegisterApp中的方法，然后将apps注册到currentAdds和this.appInfos中，再执行registerApp中的方法。<br>再返回到run方法中，继续往下执行，就会执行生命周期bootstrap中的方法。我们主要看一下router中的bootstrap方法，看看在启动时做了什么<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">// packages/router/src/index.ts</span><br><span class="line">bootstrap(options: interfaces.Options) &#123;</span><br><span class="line">        let activeApp = null;</span><br><span class="line">        const unmounts: Record&lt;string, Function&gt; = &#123;&#125;;</span><br><span class="line">        const &#123; basename &#125; = options;</span><br><span class="line">        const &#123; autoRefreshApp = true, onNotMatchRouter = () =&gt; null &#125; =</span><br><span class="line">          Garfish.options;</span><br><span class="line"></span><br><span class="line">        async function active(appInfo: interfaces.AppInfo, rootPath: string) &#123;</span><br><span class="line">          const &#123; name, cache = true, active &#125; = appInfo;</span><br><span class="line">          if (active) return active(appInfo, rootPath);</span><br><span class="line">          appInfo.rootPath = rootPath;</span><br><span class="line"></span><br><span class="line">          const currentApp = (activeApp = createKey());</span><br><span class="line">          const app = await Garfish.loadApp(appInfo.name, &#123;</span><br><span class="line">            basename: rootPath,</span><br><span class="line">            entry: appInfo.entry,</span><br><span class="line">            cache: true,</span><br><span class="line">            domGetter: appInfo.domGetter,</span><br><span class="line">          &#125;);</span><br><span class="line">          app.appInfo.basename = rootPath;</span><br><span class="line"></span><br><span class="line">          const call = (app: interfaces.App, isRender: boolean) =&gt; &#123;</span><br><span class="line">            if (!app) return;</span><br><span class="line">            const isDes = cache &amp;&amp; app.mounted;</span><br><span class="line">            const fn = isRender</span><br><span class="line">              ? app[isDes ? &apos;show&apos; : &apos;mount&apos;]</span><br><span class="line">              : app[isDes ? &apos;hide&apos; : &apos;unmount&apos;];</span><br><span class="line">            return fn.call(app);</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">          Garfish.apps[name] = app;</span><br><span class="line">          unmounts[name] = () =&gt; call(app, false);</span><br><span class="line"></span><br><span class="line">          if (currentApp === activeApp) &#123;</span><br><span class="line">            await call(app, true);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        async function deactive(appInfo: interfaces.AppInfo, rootPath: string) &#123;</span><br><span class="line">          activeApp = null;</span><br><span class="line">          const &#123; name, deactive &#125; = appInfo;</span><br><span class="line">          if (deactive) return deactive(appInfo, rootPath);</span><br><span class="line"></span><br><span class="line">          const unmount = unmounts[name];</span><br><span class="line">          unmount &amp;&amp; unmount();</span><br><span class="line">          delete Garfish.apps[name];</span><br><span class="line"></span><br><span class="line">          // Nested scene to remove the current application of nested data</span><br><span class="line">          // To avoid the main application prior to application</span><br><span class="line">          const needToDeleteApps = router.routerConfig.apps.filter((app) =&gt; &#123;</span><br><span class="line">            if (appInfo.rootPath === app.basename) return true;</span><br><span class="line">          &#125;);</span><br><span class="line">          if (needToDeleteApps.length &gt; 0) &#123;</span><br><span class="line">            needToDeleteApps.forEach((app) =&gt; &#123;</span><br><span class="line">              delete Garfish.appInfos[app.name];</span><br><span class="line">              delete Garfish.cacheApps[app.name];</span><br><span class="line">            &#125;);</span><br><span class="line">            router.setRouterConfig(&#123;</span><br><span class="line">              apps: router.routerConfig.apps.filter((app) =&gt; &#123;</span><br><span class="line">                return !needToDeleteApps.some(</span><br><span class="line">                  (needDelete) =&gt; app.name === needDelete.name,</span><br><span class="line">                );</span><br><span class="line">              &#125;),</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        const apps = Object.values(Garfish.appInfos);</span><br><span class="line"></span><br><span class="line">        const appList = apps.filter((app) =&gt; &#123;</span><br><span class="line">          if (!app.basename) app.basename = basename;</span><br><span class="line">          return !!app.activeWhen;</span><br><span class="line">        &#125;) as Array&lt;Required&lt;interfaces.AppInfo&gt;&gt;;</span><br><span class="line"></span><br><span class="line">        const listenOptions = &#123;</span><br><span class="line">          basename,</span><br><span class="line">          active,</span><br><span class="line">          deactive,</span><br><span class="line">          autoRefreshApp,</span><br><span class="line">          notMatch: onNotMatchRouter,</span><br><span class="line">          apps: appList,</span><br><span class="line">        &#125;;</span><br><span class="line">        listenRouterAndReDirect(listenOptions);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><p>这个方法可以直接看最后，就是执行了一个listenRouterAndReDirect方法，并传入了listenOptions对象。接着找listenRouterAndReDirect方法的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// packages/router/src/context.ts</span><br><span class="line">export const listenRouterAndReDirect = (&#123;</span><br><span class="line">  apps,</span><br><span class="line">  basename,</span><br><span class="line">  autoRefreshApp,</span><br><span class="line">  active,</span><br><span class="line">  deactive,</span><br><span class="line">  notMatch,</span><br><span class="line">&#125;: Options) =&gt; &#123;</span><br><span class="line">  // 注册子应用、注册激活、销毁钩子</span><br><span class="line">  registerRouter(apps);</span><br><span class="line"></span><br><span class="line">  // 初始化信息</span><br><span class="line">  setRouterConfig(&#123;</span><br><span class="line">    basename,</span><br><span class="line">    autoRefreshApp,</span><br><span class="line">    // supportProxy: !!window.Proxy,</span><br><span class="line">    active,</span><br><span class="line">    deactive,</span><br><span class="line">    notMatch,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 开始监听路由变化触发、子应用更新。重载默认初始子应用</span><br><span class="line">  listen();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>主要就是注册子应用，初始化配置，最后进行监听。再看listen方法的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// packages/router/src/agentRouter.ts</span><br><span class="line">export const listen = () =&gt; &#123;</span><br><span class="line">  normalAgent();</span><br><span class="line">  initRedirect();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>然后执行了两个方法normalAgent和initRedirect，继续往下看实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">// packages/router/src/agentRouter.ts</span><br><span class="line">export const normalAgent = () =&gt; &#123;</span><br><span class="line">  // By identifying whether have finished listening, if finished listening, listening to the routing changes do not need to hijack the original event</span><br><span class="line">  // Support nested scene</span><br><span class="line">  const addRouterListener = function () &#123;</span><br><span class="line">    window.addEventListener(__GARFISH_BEFORE_ROUTER_EVENT__, function (env) &#123;</span><br><span class="line">      RouterConfig.routerChange &amp;&amp; RouterConfig.routerChange(location.pathname);</span><br><span class="line">      linkTo((env as any).detail);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  if (!window[__GARFISH_ROUTER_FLAG__]) &#123;</span><br><span class="line">    // Listen for pushState and replaceState, call linkTo, processing, listen back</span><br><span class="line">    // Rewrite the history API method, triggering events in the call</span><br><span class="line">    const rewrite = function (type: keyof History) &#123;</span><br><span class="line">      const hapi = history[type];</span><br><span class="line">      return function () &#123;</span><br><span class="line">        const urlBefore = window.location.pathname + window.location.hash;</span><br><span class="line">        const stateBefore = history?.state;</span><br><span class="line">        const res = hapi.apply(this as any, arguments);</span><br><span class="line">        const urlAfter = window.location.pathname + window.location.hash;</span><br><span class="line">        const stateAfter = history?.state;</span><br><span class="line"></span><br><span class="line">        const e = createEvent(type);</span><br><span class="line">        (e as any).arguments = arguments;</span><br><span class="line"></span><br><span class="line">        if (urlBefore !== urlAfter || stateBefore !== stateAfter) &#123;</span><br><span class="line">          if (history.state &amp;&amp; history.state === &apos;object&apos;)</span><br><span class="line">            delete history.state[__GARFISH_ROUTER_UPDATE_FLAG__];</span><br><span class="line">          window.dispatchEvent(</span><br><span class="line">            new CustomEvent(__GARFISH_BEFORE_ROUTER_EVENT__, &#123;</span><br><span class="line">              detail: &#123;</span><br><span class="line">                toRouterInfo: &#123;</span><br><span class="line">                  fullPath: urlAfter,</span><br><span class="line">                  query: parseQuery(location.search),</span><br><span class="line">                  path: getPath(RouterConfig.basename!, urlAfter),</span><br><span class="line">                  state: stateAfter,</span><br><span class="line">                &#125;,</span><br><span class="line">                fromRouterInfo: &#123;</span><br><span class="line">                  fullPath: urlBefore,</span><br><span class="line">                  query: parseQuery(location.search),</span><br><span class="line">                  path: getPath(RouterConfig.basename!, urlBefore),</span><br><span class="line">                  state: stateBefore,</span><br><span class="line">                &#125;,</span><br><span class="line">                eventType: type,</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;),</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">        // window.dispatchEvent(e);</span><br><span class="line">        return res;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    history.pushState = rewrite(&apos;pushState&apos;);</span><br><span class="line">    history.replaceState = rewrite(&apos;replaceState&apos;);</span><br><span class="line"></span><br><span class="line">    // Before the collection application sub routing, forward backward routing updates between child application</span><br><span class="line">    window.addEventListener(</span><br><span class="line">      &apos;popstate&apos;,</span><br><span class="line">      function (event) &#123;</span><br><span class="line">        // Stop trigger collection function, fire again match rendering</span><br><span class="line">        if (event &amp;&amp; typeof event === &apos;object&apos; &amp;&amp; (event as any).garfish)</span><br><span class="line">          return;</span><br><span class="line">        if (history.state &amp;&amp; history.state === &apos;object&apos;)</span><br><span class="line">          delete history.state[__GARFISH_ROUTER_UPDATE_FLAG__];</span><br><span class="line">        window.dispatchEvent(</span><br><span class="line">          new CustomEvent(__GARFISH_BEFORE_ROUTER_EVENT__, &#123;</span><br><span class="line">            detail: &#123;</span><br><span class="line">              toRouterInfo: &#123;</span><br><span class="line">                fullPath: location.pathname,</span><br><span class="line">                query: parseQuery(location.search),</span><br><span class="line">                path: getPath(RouterConfig.basename!),</span><br><span class="line">              &#125;,</span><br><span class="line">              fromRouterInfo: &#123;</span><br><span class="line">                fullPath: RouterConfig.current!.fullPath,</span><br><span class="line">                path: getPath(</span><br><span class="line">                  RouterConfig.basename!,</span><br><span class="line">                  RouterConfig.current!.path,</span><br><span class="line">                ),</span><br><span class="line">                query: RouterConfig.current!.query,</span><br><span class="line">              &#125;,</span><br><span class="line">              eventType: &apos;popstate&apos;,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;),</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">      false,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    window[__GARFISH_ROUTER_FLAG__] = true;</span><br><span class="line">  &#125;</span><br><span class="line">  addRouterListener();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>normalAgent方法的实现，其实就是重写了history.pushState和history.replaceState两个方法，并且会触发一个自定义事件<strong>GARFISH_BEFORE_ROUTER_EVENT</strong>，那么addRouterListener其实就是注册了<strong>GARFISH_BEFORE_ROUTER_EVENT</strong>自定义事件。而initRedirect方法就是初始默认化路由的。无论是normalAgent还是initRedirect，最后都会进入linkTo方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">// packages/router/src/linkTo.ts</span><br><span class="line">export const linkTo = async (&#123;</span><br><span class="line">  toRouterInfo,</span><br><span class="line">  fromRouterInfo,</span><br><span class="line">  eventType,</span><br><span class="line">&#125;: &#123;</span><br><span class="line">  toRouterInfo: RouterInfo;</span><br><span class="line">  fromRouterInfo: RouterInfo;</span><br><span class="line">  eventType: keyof History | &apos;popstate&apos;;</span><br><span class="line">&#125;) =&gt; &#123;</span><br><span class="line">  const &#123;</span><br><span class="line">    current,</span><br><span class="line">    apps,</span><br><span class="line">    deactive,</span><br><span class="line">    active,</span><br><span class="line">    notMatch,</span><br><span class="line">    beforeEach,</span><br><span class="line">    afterEach,</span><br><span class="line">    autoRefreshApp,</span><br><span class="line">  &#125; = RouterConfig;</span><br><span class="line">  const deactiveApps = current!.matched.filter(</span><br><span class="line">    (appInfo) =&gt;</span><br><span class="line">      !hasActive(</span><br><span class="line">        appInfo.activeWhen,</span><br><span class="line">        getPath(appInfo.basename, location.pathname),</span><br><span class="line">      ),</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  // Activate the corresponding application</span><br><span class="line">  const activeApps = apps.filter((appInfo) =&gt; &#123;</span><br><span class="line">    return hasActive(</span><br><span class="line">      appInfo.activeWhen,</span><br><span class="line">      getPath(appInfo.basename, location.pathname),</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  const needToActive = activeApps.filter((&#123; name &#125;) =&gt; &#123;</span><br><span class="line">    return !current!.matched.some((&#123; name: cName &#125;) =&gt; name === cName);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // router infos</span><br><span class="line">  const to = &#123;</span><br><span class="line">    ...toRouterInfo,</span><br><span class="line">    matched: needToActive,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  const from = &#123;</span><br><span class="line">    ...fromRouterInfo,</span><br><span class="line">    matched: deactiveApps,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  await toMiddleWare(to, from, beforeEach!);</span><br><span class="line"></span><br><span class="line">  // Pause the current application of active state</span><br><span class="line">  if (current!.matched.length &gt; 0) &#123;</span><br><span class="line">    await asyncForEach(</span><br><span class="line">      deactiveApps,</span><br><span class="line">      async (appInfo) =&gt;</span><br><span class="line">        await deactive(appInfo, getPath(appInfo.basename, location.pathname)),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setRouterConfig(&#123;</span><br><span class="line">    current: &#123;</span><br><span class="line">      path: getPath(RouterConfig.basename!),</span><br><span class="line">      fullPath: location.pathname,</span><br><span class="line">      matched: activeApps,</span><br><span class="line">      state: history.state,</span><br><span class="line">      query: parseQuery(location.search),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // Within the application routing jump, by collecting the routing function for processing.</span><br><span class="line">  // Filtering gar-router popstate hijacking of the router</span><br><span class="line">  // In the switch back and forth in the application is provided through routing push method would trigger application updates</span><br><span class="line">  // application will refresh when autoRefresh configuration to true</span><br><span class="line">  const curState = window.history.state || &#123;&#125;;</span><br><span class="line">  if (</span><br><span class="line">    eventType !== &apos;popstate&apos; &amp;&amp;</span><br><span class="line">    (curState[__GARFISH_ROUTER_UPDATE_FLAG__] || autoRefreshApp)</span><br><span class="line">  ) &#123;</span><br><span class="line">    callCapturedEventListeners(eventType);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  await asyncForEach(needToActive, async (appInfo) =&gt; &#123;</span><br><span class="line">    // Function using matches character and routing using string matching characters</span><br><span class="line">    const appRootPath = getAppRootPath(appInfo);</span><br><span class="line">    await active(appInfo, appRootPath);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  if (activeApps.length === 0 &amp;&amp; notMatch) notMatch(location.pathname);</span><br><span class="line"></span><br><span class="line">  await toMiddleWare(to, from, afterEach!);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>再归纳一下，有两个中间件可以执行，afterEach和beforeEach，就是在active之前和之后的执行时机。然后主要的就是active了，其实active这个方法，是router插件中，bootstrap钩子里的active方法。到目前为止，我们主应用就run起来了，接下来就是通过路由来show或者hide子应用了。</p><h1 id="路由trigger子应用"><a href="#路由trigger子应用" class="headerlink" title="路由trigger子应用"></a>路由trigger子应用</h1><p>接下来点击vue按钮，展示vue子应用。<br>我们前面已经介绍过了，在normalAgent实现中劫持了history.push方法，那么在进行路由变化时，就会触发自定义事件<strong>GARFISH_BEFORE_ROUTER_EVENT</strong>，然后会再次进入linkTo方法，这个时候needToActive就是true了，会执行active，而active就是router插件中bootstrap的active方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// packages/router/src/index.ts</span><br><span class="line">async function active(appInfo: interfaces.AppInfo, rootPath: string) &#123;</span><br><span class="line">          const &#123; name, cache = true, active &#125; = appInfo;</span><br><span class="line">          if (active) return active(appInfo, rootPath);</span><br><span class="line">          appInfo.rootPath = rootPath;</span><br><span class="line"></span><br><span class="line">          const currentApp = (activeApp = createKey());</span><br><span class="line">          const app = await Garfish.loadApp(appInfo.name, &#123;</span><br><span class="line">            basename: rootPath,</span><br><span class="line">            entry: appInfo.entry,</span><br><span class="line">            cache: true,</span><br><span class="line">            domGetter: appInfo.domGetter,</span><br><span class="line">          &#125;);</span><br><span class="line">          app.appInfo.basename = rootPath;</span><br><span class="line"></span><br><span class="line">          const call = (app: interfaces.App, isRender: boolean) =&gt; &#123;</span><br><span class="line">            if (!app) return;</span><br><span class="line">            const isDes = cache &amp;&amp; app.mounted;</span><br><span class="line">            const fn = isRender</span><br><span class="line">              ? app[isDes ? &apos;show&apos; : &apos;mount&apos;]</span><br><span class="line">              : app[isDes ? &apos;hide&apos; : &apos;unmount&apos;];</span><br><span class="line">            return fn.call(app);</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">          Garfish.apps[name] = app;</span><br><span class="line">          unmounts[name] = () =&gt; call(app, false);</span><br><span class="line"></span><br><span class="line">          if (currentApp === activeApp) &#123;</span><br><span class="line">            await call(app, true);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>这个方法中会有个app，这个app是Garfish类中loadApp方法返回的，那我们看一下返回的这个app是啥：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">// packages/core/src/garfish.ts</span><br><span class="line">async loadApp(</span><br><span class="line">    appName: string,</span><br><span class="line">    optionsOrUrl?: Omit&lt;interfaces.AppInfo, &apos;name&apos;&gt;,</span><br><span class="line">  ): Promise&lt;interfaces.App | null&gt; &#123;</span><br><span class="line">    assert(appName, &apos;Miss appName.&apos;);</span><br><span class="line">    const appInfo = generateAppOptions(appName, this, optionsOrUrl);</span><br><span class="line"></span><br><span class="line">    const asyncLoadProcess = async () =&gt; &#123;</span><br><span class="line">      // Return not undefined type data directly to end loading</span><br><span class="line">      const stop = await this.hooks.lifecycle.beforeLoad.emit(appInfo);</span><br><span class="line">      if (stop === false) &#123;</span><br><span class="line">        warn(`Load $&#123;appName&#125; application is terminated by beforeLoad.`);</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line">      // Existing cache caching logic</span><br><span class="line">      let appInstance: interfaces.App = null;</span><br><span class="line">      const cacheApp = this.cacheApps[appName];</span><br><span class="line">      if (appInfo.cache &amp;&amp; cacheApp) &#123;</span><br><span class="line">        appInstance = cacheApp;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          const [manager, resources, isHtmlMode] = await processAppResources(</span><br><span class="line">            this.loader,</span><br><span class="line">            appInfo,</span><br><span class="line">          );</span><br><span class="line"></span><br><span class="line">          appInstance = new App(</span><br><span class="line">            this,</span><br><span class="line">            appInfo,</span><br><span class="line">            manager,</span><br><span class="line">            resources,</span><br><span class="line">            isHtmlMode,</span><br><span class="line">            appInfo.customLoader,</span><br><span class="line">          );</span><br><span class="line"></span><br><span class="line">          // The registration hook will automatically remove the duplication</span><br><span class="line">          for (const key in this.plugins) &#123;</span><br><span class="line">            appInstance.hooks.usePlugin(this.plugins[key]);</span><br><span class="line">          &#125;</span><br><span class="line">          if (appInfo.cache) &#123;</span><br><span class="line">            this.cacheApps[appName] = appInstance;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">          __DEV__ &amp;&amp; warn(e);</span><br><span class="line">          this.hooks.lifecycle.errorLoadApp.emit(e, appInfo);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      await this.hooks.lifecycle.afterLoad.emit(appInfo, appInstance);</span><br><span class="line">      return appInstance;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    if (!this.loading[appName]) &#123;</span><br><span class="line">      this.loading[appName] = asyncLoadProcess().finally(() =&gt; &#123;</span><br><span class="line">        this.loading[appName] = null;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return this.loading[appName];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>这个函数稍微有点长，我总结一下，this.loading是为了保存当前要加载的app，通过一个asyncLoadProcess返回，这里注意一下，asyncLoadProcess是async函数，没有await，所以返回的是一个Promise对象，而resolve的是appInstance，在asyncLoadProcess中，也是执行了app生命周期中的几个钩子。我们再简单了解一下App类是什么样的，由于代码太多，我们只列个大概，并且说明用途即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">// packages/core/src/module/app.ts</span><br><span class="line">export class App &#123;</span><br><span class="line">  public appId = appId++;</span><br><span class="line">  public display = false;</span><br><span class="line">  public mounted = false;</span><br><span class="line">  public esModule = false;</span><br><span class="line">  public strictIsolation = false;</span><br><span class="line">  public name: string;</span><br><span class="line">  public isHtmlMode: boolean;</span><br><span class="line">  public global: any = window;</span><br><span class="line">  public appContainer: HTMLElement;</span><br><span class="line">  public cjsModules: Record&lt;string, any&gt;;</span><br><span class="line">  public htmlNode: HTMLElement | ShadowRoot;</span><br><span class="line">  public customExports: Record&lt;string, any&gt; = &#123;&#125;; // If you don&apos;t want to use the CJS export, can use this</span><br><span class="line">  public sourceList: Array&lt;&#123; tagName: string; url: string &#125;&gt; = [];</span><br><span class="line">  public appInfo: AppInfo;</span><br><span class="line">  public hooks: interfaces.AppHooks;</span><br><span class="line">  public provider: interfaces.Provider;</span><br><span class="line">  public entryManager: TemplateManager;</span><br><span class="line">  public appPerformance: SubAppObserver;</span><br><span class="line">  /** @deprecated */</span><br><span class="line">  public customLoader: CustomerLoader;</span><br><span class="line"></span><br><span class="line">  private active = false;</span><br><span class="line">  private mounting = false;</span><br><span class="line">  private unmounting = false;</span><br><span class="line">  private context: Garfish;</span><br><span class="line">  private resources: interfaces.ResourceModules;</span><br><span class="line">  // Environment variables injected by garfish for linkage with child applications</span><br><span class="line">  private globalEnvVariables: Record&lt;string, any&gt;;</span><br><span class="line">  // es-module save lifeCycle to appGlobalId，appGlobalId in script attr</span><br><span class="line">  private appGlobalId: string;</span><br><span class="line"></span><br><span class="line">  constructor(</span><br><span class="line">    context: Garfish,</span><br><span class="line">    appInfo: AppInfo,</span><br><span class="line">    entryManager: TemplateManager,</span><br><span class="line">    resources: interfaces.ResourceModules,</span><br><span class="line">    isHtmlMode: boolean,</span><br><span class="line">    customLoader: CustomerLoader,</span><br><span class="line">  ) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get rootElement() &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getProvider() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  execScript(</span><br><span class="line">    code: string,</span><br><span class="line">    env: Record&lt;string, any&gt;,</span><br><span class="line">    url?: string,</span><br><span class="line">    options?: &#123; async?: boolean; noEntry?: boolean &#125;,</span><br><span class="line">  ) &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // `vm sandbox` can override this method</span><br><span class="line">  runCode(</span><br><span class="line">    code: string,</span><br><span class="line">    env: Record&lt;string, any&gt;,</span><br><span class="line">    url?: string,</span><br><span class="line">    options?: &#123; async?: boolean; noEntry?: boolean &#125;,</span><br><span class="line">  ) &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async show() &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  hide() &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async mount() &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  unmount() &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getExecScriptEnv(noEntry: boolean) &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Performs js resources provided by the module, finally get the content of the export</span><br><span class="line">  async compileAndRenderContainer() &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private canMount() &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // If asynchronous task encountered in the rendering process, such as triggering the beforeEval before executing code,</span><br><span class="line">  // after the asynchronous task, you need to determine whether the application has been destroyed or in the end state.</span><br><span class="line">  // If in the end state will need to perform the side effects of removing rendering process, adding a mount point to a document,</span><br><span class="line">  // for example, execute code of the environmental effects, and rendering the state in the end.</span><br><span class="line">  private stopMountAndClearEffect() &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Calls to render do compatible with two different sandbox</span><br><span class="line">  private callRender(provider: interfaces.Provider, isMount: boolean) &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Call to destroy do compatible with two different sandbox</span><br><span class="line">  private callDestroy(provider: interfaces.Provider, isUnmount: boolean) &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Create a container node and add in the document flow</span><br><span class="line">  // domGetter Have been dealing with</span><br><span class="line">  private async addContainer() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private async renderTemplate() &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private async checkAndGetProvider() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总结起来，这个App类提供的能力如下：</p><ol><li>提供静态资源，HTML、CSS、js的结构。</li><li>可以在CJS中提取或者推导出子应用的 provider。<br>3.通过execCode传入模块的CJS规范、require、exports等环境变量实现对外共享</li><li>触发渲染：应用相关节点放置在文档流中，依次执行应用脚本，最终渲染功能，执行子应用提供完整的应用独立运行时执行。</li><li>触发销毁：执行子应用程序的销毁功能，应用子节点从文档流中移除。<br>再回到active方法中，最核心的地方是call方法，最后调用了App中的show、mount、hide、unmount方法。show和hide可以理解为之前已经加载过了，就是show和hide一下，mount是要和unmount是挂载和卸载，我们这里主要以mount为例，看一下是如何加载子应用环境并且加载子应用的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// packages/core/src/module/app.ts</span><br><span class="line">async mount() &#123;</span><br><span class="line">    if (!this.canMount()) return false;</span><br><span class="line">    this.hooks.lifecycle.beforeMount.emit(this.appInfo, this, false);</span><br><span class="line"></span><br><span class="line">    this.active = true;</span><br><span class="line">    this.mounting = true;</span><br><span class="line">    try &#123;</span><br><span class="line">      // add container and compile js with cjs</span><br><span class="line">      const asyncJsProcess = await this.compileAndRenderContainer();</span><br><span class="line"></span><br><span class="line">      // Good provider is set at compile time</span><br><span class="line">      const provider = await this.getProvider();</span><br><span class="line">      // Existing asynchronous functions need to decide whether the application has been unloaded</span><br><span class="line">      if (!this.stopMountAndClearEffect()) return false;</span><br><span class="line"></span><br><span class="line">      this.callRender(provider, true);</span><br><span class="line">      this.display = true;</span><br><span class="line">      this.mounted = true;</span><br><span class="line">      this.context.activeApps.push(this);</span><br><span class="line">      this.hooks.lifecycle.afterMount.emit(this.appInfo, this, false);</span><br><span class="line"></span><br><span class="line">      await asyncJsProcess;</span><br><span class="line">      if (!this.stopMountAndClearEffect()) return false;</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      this.entryManager.DOMApis.removeElement(this.appContainer);</span><br><span class="line">      this.hooks.lifecycle.errorMountApp.emit(e, this.appInfo);</span><br><span class="line">      return false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      this.mounting = false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol><p>大概意思就是说，添加了一个子应用容器，拿到子应用资源（主要通过fetch方式获取，继续深挖compileAndRenderContainer就知道了），然后获取子应用export出来的provider，最后执行代码，子应用就成功展示出来了。<br>再说一下子应用的代码执行，子应用中如果使用了window，那么在子应用接入主应用后，如果不做任何处理，那么两个应用的window是一个，这样就会有逻辑问题，为了解决这个问题，就有了沙箱概念。garfish中提供了两种沙箱机制：vm沙箱和snapshot沙箱。<br>我们可以看一个简单的vm沙箱原理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const varBox = &#123;&#125;;</span><br><span class="line">const fakeWindow = new Proxy(window, &#123;</span><br><span class="line">    get(target, key) &#123;</span><br><span class="line">        return varBox[key] || window[key]</span><br><span class="line">    &#125;,</span><br><span class="line">    set(target, key, value) &#123;</span><br><span class="line">        varBox[key] = value;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">const fn = new Function(&apos;window&apos;, code);</span><br><span class="line">fn(fakeWindow);</span><br></pre></td></tr></table></figure></p><p>主要是通过es6中proxy实现的，当然这只是一个原理性代码，实际中还会兼容很多case。其实在最初注册garfish插件的时候，初始化garfish实例的时候，就初始化了vm沙箱和snapshot沙箱。我们前面也说了，在每个插件中都会定义一些生命周期的钩子方法，其实在Garfish.loadApp的时候，就在App上挂载了vmSandbox属性，在后续的子应用执行代码时，环境都是在沙箱中执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h1&gt;&lt;p&gt;首先，可以在github上把代码拉到本地，地址为：&lt;a href=&quot;https://github.com/modern-js
      
    
    </summary>
    
      <category term="前端" scheme="https://skhon.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Web" scheme="https://skhon.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>架构师的职责</title>
    <link href="https://skhon.github.io/2021/12/20/architecture/base/"/>
    <id>https://skhon.github.io/2021/12/20/architecture/base/</id>
    <published>2021-12-20T13:07:00.774Z</published>
    <updated>2021-12-29T02:21:01.247Z</updated>
    
    <content type="html"><![CDATA[<p>经常有人问，架构师是干嘛的？那么今天谈谈，架构师的职责是什么。</p><h3 id="什么是架构"><a href="#什么是架构" class="headerlink" title="什么是架构"></a>什么是架构</h3><p>谈架构师职责之前，我们要先了解什么是架构。那么提到架构，很多人也会提到框架这个概念，多数情况下，我们都不怎么区分这两个概念，如果细分一下的话，架构偏向于结构，框架偏向于规范。比如linux中有架构，window有架构，微信有架构，淘宝也有架构…那么框架呢，比如一款mvvm框架，mvc框架，使用这个框架需要遵循一些规定好的设计。</p><p>我们这里主要说一下架构吧，以微信为例，一款app，它其实是分很多模块的，比如好友模块，朋友圈模块，消息模块等，而朋友圈模块又分为留言模块，点赞模块，发表模块等。架构就是说，这些不同的模块如何的各司其职，又能如何的互相配合，如果要增加一个摇一摇模块，如何能够扩展方便。把这些所有因素都考虑进来，最后能够组装在一起的能力，就是架构能力，整个系统的所有组成统一叫做架构。感觉还是有点绕。。。不管了，我觉得能够解决业务痛点，使得业务能够做到高性能、高可用、易扩展、成本低、安全高…，说白了就是能解决掉业务排在前面一半的痛点，就是牛逼的架构师。</p><h3 id="为什么需要架构"><a href="#为什么需要架构" class="headerlink" title="为什么需要架构"></a>为什么需要架构</h3><p>大家有没有发现，一般小公司没有架构师这个职位，只有达到一定量级才会有架构师，因为小公司不需要架构，10个人开个会碰一碰，你做这个，我做这个，撸起袖子写代码，尽快上线，比花时间搞架构有意义。你以为淘宝一开始就搞的这么牛吗？不是的，淘宝第一版是买的！当年杭州马在2003年的时候，4月7号决定要做淘宝，要求5月10号上线，要是你想着搞架构，黄花菜都凉了，基于当时公司、市场情况，只要买一个是最快的，当然要考虑买一个什么样的，买一个轻量的还是买个复杂的，各有优势，但是基于后续可能要持续发展，就买了个轻量的，方便后续二次开发。等到了后续，业务大爆发，当前项目承载不了那么高的流量，才开始搞架构。所以，好的架构都是业务逼出来的。如果架构脱离业务，那没有太大的意义。</p><p>回到主题，我们为什么需要架构，我理解的架构就是为了解决复杂业务中遇到的问题。</p><h3 id="架构要做什么"><a href="#架构要做什么" class="headerlink" title="架构要做什么"></a>架构要做什么</h3><p>我们上面也说到了，当业务发展一定程度时，由于市场需求、公司老板要求等，必须要对业务进行优化，可能因为旧结构会有一些问题，比如难扩张，加一个新需求，依赖的东西太多，人员成本大，也可以是用户量急剧上升，需要承载更高的qps等，那么架构要做的，我这里整理了几个方面：高性能、高可用、可扩展、低成本、高安全，当然还有很多，但多数的复杂业务都会遇到这几个问题。</p><h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><p>之前做过一个bff框架，支持公司内部服务，当时一台8核32G服务器，裸压hello world，记得qps最高压到了2500。记得当时公司有个活动，预计当天参与人数会到20万，qps峰值保险一点就是20w了，那么如何让这个qps只能到2500的框架支持这么多的用户量呢？最简单的办法也是最合适的，用机器的数量来提升qps的上限，一台机器可以承载2500的qps，那就操作20w/2500多台机器，当然由于目前虚拟化技术等实现，可能很多机器是虚拟机，所有，真实的服务器也可能不需要那么多。这就是一个简单的用量来提升性能的方式。</p><p>当然，高性能，也会体现在其他方面，比如一些调度算法、负载均衡等，都是提升高性能的方式，好的调度算法，也能减少一些资源都浪费。</p><h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><p>我们还以我做的那个bff框架为例，说白了，业务方用了你的框架，上线后，发现程序经常崩溃，排查原因还非常困难，日志难找。这就说明，你这个架构设计的有问题。那么如何做到高可用呢，首先作为一个架构师，妳得有一定都预测性，可能会出现什么情况，如果出了什么情况你有什么备选方案，可以让业务还能够稳定运行，不被用户察觉的情况下，业务不受影响。记得之前出现过一个案例，线上服务有时候会经常莫名重启，后来经排查发现，在一个异步操作里，抛了一个异常，但是这个异常没有被catch到，导致进程直接退出了，退出后，由于机器上有保活机制，进程又被拉起来了，这就出现了服务重启的情况。最后我做了一个兜底的方案，在进程中监听了uncaughtException事件，防止异常退出。</p><p>另外很多情况需要我们考虑，比如线上服务重启，有一段短暂的事件，请求是打不进来的，那如何解决这段时间的服务不可用对用户的影响呢，那就可以做到平滑重启，多个进程配合就可以做到，这些都是需要架构师要想的，再比如，有一些服务是链接ElasticSearch（后面简称es）的，一般es都是部署到公司特定的机器上，如果某个时刻es挂了，你的服务就会受到影响，这个也是你需要考虑的，如果es挂了，你得有降级方案，比如可以熔断，数据拿备机数据。</p><p>总之，高可用就是要尽可能的想到所有线上可能遇到的各种问题，你想，阿里双11前，都要突然断电，就是为了验证服务的高可用。</p><h3 id="可扩展"><a href="#可扩展" class="headerlink" title="可扩展"></a>可扩展</h3><p>这个大家应该也容易理解，服务的升级和迭代，有时候是需要在某一些能力做扩展的，还以bff框架为例，多数通用的中间间，我们一般都内置到框架里了，但是有些业务，需要自定义中间件，那就需要框架本身暴露出一个口子，用来用户的自定义扩展。如果一个bff框架没有可扩展功能，给你用的话，我估计你也不想用。所以可扩展也是一个用户体验到问题。再往大一点产品讲，大家都在用微信，如果微信哪天在朋友圈做一个新功能，比如要做广告，总不能把朋友圈整体都要搞一下把，这个成本也太大了。另外大家在微信的设置里，可以看到有一个发现页的设置，里面可以动态关闭展示你喜欢的功能，这就是可扩展性。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>其他还有很多因素需要架构师考虑，反正架构师的职责就是为了业务的高效、稳定、安全等考虑，脱离业务的架构师，不是好架构师。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;经常有人问，架构师是干嘛的？那么今天谈谈，架构师的职责是什么。&lt;/p&gt;
&lt;h3 id=&quot;什么是架构&quot;&gt;&lt;a href=&quot;#什么是架构&quot; class=&quot;headerlink&quot; title=&quot;什么是架构&quot;&gt;&lt;/a&gt;什么是架构&lt;/h3&gt;&lt;p&gt;谈架构师职责之前，我们要先了解什么是架
      
    
    </summary>
    
      <category term="架构" scheme="https://skhon.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="Architecture" scheme="https://skhon.github.io/tags/Architecture/"/>
    
  </entry>
  
  <entry>
    <title>谈谈我喜欢的候选人</title>
    <link href="https://skhon.github.io/2021/12/17/interview/mymind/"/>
    <id>https://skhon.github.io/2021/12/17/interview/mymind/</id>
    <published>2021-12-17T08:42:03.628Z</published>
    <updated>2021-12-28T12:40:52.941Z</updated>
    
    <content type="html"><![CDATA[<p>其实作为面试官有几年了，在第一家公司2016年的时候，就开始这方面工作了，这几年的面试经历中，遇到的多数候选人普普通通，当然也遇到过优秀的，但是非常少。其实作为面试官，我是非常不赞成抛开简历中的项目，直接各种八股文去考察候选人，这样的面试是片面的，还有一些面试官，也是抛开候选人简历，只问面试官自己会的。我觉得像这些面试官，他本身的技能就不是很扎实，不是合格的面试官，但是有很多时候，公司需要大量招人，就会让一些级别不高的同学也去做面试官，就会导致一些问题。那么接下来我就谈谈，我心目中优秀的候选人，是什么样的。</p><h3 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h3><p>简历很重要，我了解候选人的整体情况，第一印象都来自于候选人的简历。简历如果没有亮点，按照我的经验，多少情况最终的结果都是fail。我们先看看千篇一律的简历，如下：<br><img src="/images/interview/jianli1.png" width="50%"><br>这个候选人，工作4年，其实也不短，专业技能写的很泛泛，面比较广，这些技能都学的怎么样，通过简历还是看不出来，需要面试中沟通。另外再看项目，就是普通的前端项目，也看不到任何的难点和亮点。所以，像这种简历，第一印象都不是很好，如果学校、工作经历都不好的情况下，简历基本过不了。<br>那么什么样的简历是有亮点的呢？可以看一下这个：<br><img src="/images/interview/jianli2.png" width="50%"><br>首先个人优势比较突出，是一个开源项目的主要负责人，并且是vue-router的Contributor，另外在极客帮做过技术分享，这几点就很多人做不到的了。这就是亮点！我们为什么喜欢对开源社区有贡献的候选人呢，因为一般开源社区中比较知名的框架或者技术都是有一定难度的，都是从架构设计到实现，是值得我们很多人去学习的，所以它出名，而对于这些优秀的开源项目有共享的同学，他们对其实现肯定是了解甚至掌握的，而这就是体现出了候选人的实力。<br>一个人的亮点可以是方方面面的，比如曾经写过《xxx》书籍，在公司申请过《xxx》专利，甚至你在leetcode上涮了200道题都是你的亮点，如果你说我就是没有亮点，那我觉得就是懒，行动上和思想上都懒。那为啥优秀的那个人不可以是你呢？</p><h3 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h3><p>我一般在面试中，除了计算机基础之外，基本上都是会按照候选人的简历去聊，由浅入深，探索候选人的深度，比如候选人主要用的技术栈是react，那我会先聊一下react的一些特性，比如生命周期、一些副作用的操作在哪里写比较合适。再往深聊，就会问一些react优化的问题，hooks的使用。如果候选人答的不错，我还会往原理上聊，比如如果要实现一个xxx需求，如何写一个自定义hooks。再往深聊，就会聊到react设计、源码这部分，如果候选人能把所有问题都答的非常好，那就是牛批的候选人。这是深度。另外也会探索一下候选人的广度，比如跳出浏览器会问一些其他的技能，比如nodejs、数据库、运维相关的，如果候选人平时后端需求也写，那可以理解为是一个全栈工程师，这样的候选人有个优势就是面对一些复杂的场景需求时，可以自己搞定，进来也好带，不用特别费劲。如果技术的深度和广度都没问题的话，我可能还会问一些解决方案的思路，比如一些工程化问题，如何分析公共依赖，确定前端页面的回归范围、如何统计相似函数以提升代码质量等。总之我的面试中，可能会问很多原理性问题，如果我们聊的来，那我觉得你就是我喜欢的那种候选人。</p><h3 id="代码能力"><a href="#代码能力" class="headerlink" title="代码能力"></a>代码能力</h3><p>我的面试中，一般都会有代码题，题目不难，都是leetcode中简单题目。考代码能力的主要目的，不是为了考的你不会，而是看你的代码能力过不过关，主要看你的代码速度、代码思路、代码规范等，通过你写代码，大概能了解你的代码能力，甚至你的性格。因为个别候选人，理论知识确实不错，进来写项目需求的时候，巨慢，这种就是代码不过关导致的问题。</p><h3 id="软性技能"><a href="#软性技能" class="headerlink" title="软性技能"></a>软性技能</h3><p>软性技能的话，对于候选人来说，可能比较好答一些，但是也分好坏。这个就是主要观察一些候选人的沟通能力、性格之类的，可能更具候选人的性格，也需要安排不同的工作，比如内向一点都，可能会擅长偏技术攻关之类的工作，因为偏内向的人，一般都有一定的耐力或者耐性。对于乐观开朗一点的候选人，会适合做一些需求联动的工作，因为他擅于和各种人（测试、产品）沟通，也会促进工作更好的完成。<br>另外就是看看他的一些学习渠道，比如喜欢看凯源的一些技术或者框架，那可以看到这样的候选人对技术还是有热情的。喜欢看书、看博客，这样的候选人也是喜欢学习的，像这样的候选人，我也比较青睐。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我觉得以上几个方面做的不错的同学，我觉得就是我喜欢的那类候选人。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;其实作为面试官有几年了，在第一家公司2016年的时候，就开始这方面工作了，这几年的面试经历中，遇到的多数候选人普普通通，当然也遇到过优秀的，但是非常少。其实作为面试官，我是非常不赞成抛开简历中的项目，直接各种八股文去考察候选人，这样的面试是片面的，还有一些面试官，也是抛开候
      
    
    </summary>
    
      <category term="面试" scheme="https://skhon.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Interview" scheme="https://skhon.github.io/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>原型链攻击</title>
    <link href="https://skhon.github.io/2021/12/17/security/prototype/"/>
    <id>https://skhon.github.io/2021/12/17/security/prototype/</id>
    <published>2021-12-17T07:32:15.614Z</published>
    <updated>2021-12-28T12:41:04.518Z</updated>
    
    <content type="html"><![CDATA[<p>安全问题是公司非常重视的问题，但是在我面试过程中，很多候选人只知道xss、csrf这两种，因为多数面经中，只会提到这两种。可以看到，前端工程师在平时的开发中，还是很少考虑安全问题的。由于本人在公司负责工程化建设相关工作，会涉及到项目的安全漏洞检测，所以后续多写一些相关的文章。<br>今天聊的是原型链污染攻击问题，我们先以一个非常简单的程序入手，我们知道在JavaScript中，一个对象有一个<strong>proto</strong>属性，它是指向Object.prototype的，像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;;</span><br><span class="line">console.log(obj.__proto__ === Object.prototype); // true</span><br></pre></td></tr></table></figure></p><p>有了这个前置知识后，大家可以看下面的程序会输出什么。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;;</span><br><span class="line">obj.__proto__.name = &apos;obj&apos;;</span><br><span class="line">console.log(obj.name); // 这个很明显，是obj</span><br><span class="line"></span><br><span class="line">let newObj = &#123;&#125;;</span><br><span class="line">console.log(newObj.name); // ???</span><br></pre></td></tr></table></figure></p><p>执行后，你会发现，newObj.name也为obj！什么情况，我新定义的newObj对象，居然可以输出name属性？？没错，这就是原型链污染。<strong>原因就是：改obj.<strong>proto</strong>,其实就是改了Object.prototype,而newObj的<strong>proto</strong>也是指向Object.prototype，这样Object的原型对象被偷偷改了，导致后面的对象不知道，这就是原型链污染的实质</strong></p><p>这种漏洞一般会出现在类似merge操作中，而很多工具库就提供merge方法，之前lodash就存在过原型链漏洞问题，后来修复了，如果存在漏洞，有些人就会故意往原型链上merge一些具有危险的属性，给系统带来危机。我们可以看一个简单的merge函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function merge(target, source) &#123;</span><br><span class="line">  for (let key in source) &#123;</span><br><span class="line">    if (key in source &amp;&amp; key in target) &#123;</span><br><span class="line">      merge(target[key], source[key])</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      target[key] = source[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们来验证一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let o1 = &#123;&#125;</span><br><span class="line">let o2 = &#123;a: 1, &quot;__proto__&quot;: &#123;b: 2&#125;&#125;</span><br><span class="line">merge(o1, o2)</span><br><span class="line">console.log(o1.a, o1.b) // 1 2</span><br><span class="line"></span><br><span class="line">o3 = &#123;&#125;</span><br><span class="line">console.log(o3.b) // undefined</span><br></pre></td></tr></table></figure></p><p>我们可以看到这么搞，是没有污染的，原因是o2这么定义，<strong>proto</strong>会直接放在原型链上，不会当作o2的属性，可以这么理解：<br>o2.<strong>proto</strong> ==&gt; { b: 2, <strong>proto</strong>: Object.prototype}，而for in是能够遍历到原型链上的属性，所以会直接在o1中增加属性b为2。加入这么写会是啥样，看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let o1 = &#123;&#125;</span><br><span class="line">let o2 = JSON.parse(&apos;&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;b&quot;: 2&#125;&#125;&apos;)</span><br><span class="line">merge(o1, o2)</span><br><span class="line">console.log(o1.a, o1.b) // 1 2</span><br><span class="line"></span><br><span class="line">o3 = &#123;&#125;</span><br><span class="line">console.log(o3.b) // 2</span><br></pre></td></tr></table></figure></p><p>这么写就污染了，因为这么写，<strong>proto</strong>会当作o2的一个属性，就是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">o2 = &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  __proto__: &#123;</span><br><span class="line">    b: 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这么会让o1.<strong>proto</strong> = {b: 2},而o1的<strong>proto</strong>就是Object.prototype，随意就会导致Object的原型对象被悄悄的改了。</p><p>如何缓解原型链漏洞呢？这里提供了几种方式可参考：</p><blockquote><p>Object.freeze 将缓解几乎所有情况。冻结 Object 阻止添加新的 Prototype。<br>使用模式验证确保 JSON 数据包含预期属性，从而删除 JSON 中出现的 <em>proto</em>。<br>使用映射原语。它在 EcmaScript6 标准中引入，目前在 NodeJS 环境中备受支持。<br>使用 Object.create(null) 函数创建的Objects 不具有 <em>proto</em> 属性。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;安全问题是公司非常重视的问题，但是在我面试过程中，很多候选人只知道xss、csrf这两种，因为多数面经中，只会提到这两种。可以看到，前端工程师在平时的开发中，还是很少考虑安全问题的。由于本人在公司负责工程化建设相关工作，会涉及到项目的安全漏洞检测，所以后续多写一些相关的文章
      
    
    </summary>
    
      <category term="安全" scheme="https://skhon.github.io/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Security" scheme="https://skhon.github.io/tags/Security/"/>
    
  </entry>
  
  <entry>
    <title>代码覆盖率</title>
    <link href="https://skhon.github.io/2021/12/16/engineering/coverage/"/>
    <id>https://skhon.github.io/2021/12/16/engineering/coverage/</id>
    <published>2021-12-16T12:50:04.517Z</published>
    <updated>2021-12-28T12:40:49.661Z</updated>
    
    <content type="html"><![CDATA[<p>最近为了防止因为漏测导致线上问题，做了一些统计测试覆盖率的工作。这个过程中用到了一个检测代码覆盖率的工具，叫：istanbul。它主要能够从几个维度来分析对应的覆盖率。比如下面几个指标：</p><blockquote><ul><li>行覆盖率（line coverage）：是否每一行都执行了？</li><li>函数覆盖率（function coverage）：是否每个函数都调用了？</li><li>分支覆盖率（branch coverage）：是否每个if代码块都执行了？</li><li>语句覆盖率（statement coverage）：是否每个语句都执行了？</li></ul></blockquote><p>使用起来也比较简单：</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Istanbul 是一个 npm 模块，安装非常简单，就一行命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g istanbul</span><br></pre></td></tr></table></figure></p><h3 id="覆盖率测试"><a href="#覆盖率测试" class="headerlink" title="覆盖率测试"></a>覆盖率测试</h3><p>来看一个例子，怎么使用 Istanbul 。下面是脚本文件 simple.js 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">var b = 1;</span><br><span class="line">if ((a + b) &gt; 2) &#123;</span><br><span class="line">  console.log(&apos;more than two&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 istanbul cover 命令，就能得到覆盖率。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ istanbul cover simple.js</span><br><span class="line"></span><br><span class="line">===== Coverage summary =====</span><br><span class="line">Statements   : 75% ( 3/4 )</span><br><span class="line">Branches     : 50% ( 1/2 )</span><br><span class="line">Functions    : 100% ( 0/0 )</span><br><span class="line">Lines        : 75% ( 3/4 )</span><br><span class="line">=============================</span><br></pre></td></tr></table></figure></p><p>返回结果显示，simple.js 有4个语句（statement），执行了3个；有2个分支（branch），执行了1个；有0个函数，调用了0个；有4行代码，执行了3行。</p><p>这条命令同时还生成了一个 coverage 子目录，其中的 coverage.json 文件包含覆盖率的原始数据，coverage/lcov-report 是可以在浏览器打开的覆盖率报告，其中有详细信息，到底哪些代码没有覆盖到。</p><h3 id="覆盖率门槛"><a href="#覆盖率门槛" class="headerlink" title="覆盖率门槛"></a>覆盖率门槛</h3><p>完美的覆盖率当然是 100%，但是现实中很难达到。需要有一个门槛，衡量覆盖率是否达标。</p><p>istanbul check-coverage 命令用来设置门槛，同时检查当前代码是否达标。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ istanbul check-coverage --statement 90</span><br><span class="line"></span><br><span class="line">ERROR: Coverage for statements (75%) does not meet global threshold (90%)</span><br></pre></td></tr></table></figure><p>上面命令设置语句覆盖率的门槛是 90% ，结果就报错了，因为实际覆盖率只有75%。</p><p>除了百分比门槛，我们还可以设置绝对值门槛，比如只允许有一个语句没有被覆盖到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ istanbul check-coverage --statement -1</span><br></pre></td></tr></table></figure><p>上面命令使用负数，表示绝对值门槛。这样一来，上面的例子就通过了覆盖率测试，不会再报错了。</p><p>百分比门槛和绝对值门槛，可以结合使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ istanbul check-coverage --statement -5 --branch -3 --function 100</span><br></pre></td></tr></table></figure><p>上面命令设置了3个覆盖率门槛：5个语句、3个 if 代码块、100%的函数。注意，这三个门槛是”与”（and）的关系，只要有一个没有达标，就会报错。</p><h3 id="与测试框架的结合"><a href="#与测试框架的结合" class="headerlink" title="与测试框架的结合"></a>与测试框架的结合</h3><p>实际开发时，istanbul 总是与测试框架结合使用，下面以常用的 Mocha 框架为例。</p><p>sqrt.js 是一个计算平方根的脚本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var My = &#123;</span><br><span class="line">  sqrt: function(x) &#123;</span><br><span class="line">    if (x &lt; 0) throw new Error(&quot;负值没有平方根&quot;);</span><br><span class="line">      return Math.exp(Math.log(x)/2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = My;</span><br></pre></td></tr></table></figure><p>它的测试脚本 test.sqrt.js 放在 test 子目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var chai = require(&apos;chai&apos;);</span><br><span class="line">var expect = chai.expect;</span><br><span class="line">var My = require(&apos;../sqrt.js&apos;);</span><br><span class="line"></span><br><span class="line">describe(&quot;sqrt&quot;, function() &#123;</span><br><span class="line"></span><br><span class="line">  it(&quot;4的平方根应该等于2&quot;, function() &#123;</span><br><span class="line">    expect(My.sqrt(4)).to.equal(2);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(&quot;参数为负值时应该报错&quot;, function() &#123;</span><br><span class="line">    expect(function()&#123; My.sqrt(-1); &#125;).to.throw(&quot;负值没有平方根&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后，执行下面的命令得到代码覆盖率。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ istanbul cover _mocha</span><br><span class="line">// or</span><br><span class="line">$ istanbul cover _mocha test/test.sqrt.js</span><br><span class="line"></span><br><span class="line">  sqrt</span><br><span class="line">    ✓ 4的平方根应该等于2 </span><br><span class="line">    ✓ 参数为负值时应该报错 </span><br><span class="line"></span><br><span class="line">  2 passing (7ms)</span><br><span class="line"></span><br><span class="line">===== Coverage summary =====</span><br><span class="line">Statements   : 100% ( 5/5 )</span><br><span class="line">Branches     : 100% ( 2/2 )</span><br><span class="line">Functions    : 100% ( 1/1 )</span><br><span class="line">Lines        : 100% ( 4/4 )</span><br><span class="line">=============================</span><br></pre></td></tr></table></figure><p>上面命令中，istanbul cover 命令后面跟的是 _mocha 命令，前面的下划线是不能省略的。</p><p>因为，mocha 和 _mocha 是两个不同的命令，前者会新建一个进程执行测试，而后者是在当前进程（即 istanbul 所在的进程）执行测试，只有这样， istanbul 才会捕捉到覆盖率数据。其他测试框架也是如此，必须在同一个进程执行测试。</p><p>如果要向 mocha 传入参数，可以写成下面的样子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ istanbul cover _mocha -- tests/test.sqrt.js -R spec</span><br></pre></td></tr></table></figure></p><p>上面命令中，两根连词线后面的部分，都会被当作参数传入 Mocha 。如果不加那两根连词线，它们就会被当作 istanbul 的参数（参考链接1，2）。</p><p>如果想在浏览器运行 Istanbul ，可以参考这篇文章。</p><p>五、忽略某些代码<br>istanbul 提供注释语法，允许某些代码不计入覆盖率。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var object = parameter || /* istanbul ignore next */ &#123;&#125;;</span><br></pre></td></tr></table></figure><p>上面代码是为 object 指定默认值（一个空对象）。如果由于种种原因，没有为 object 为空对象的情况写测试，可以用注释，不将这种情况计入覆盖率。注意，注释要写在”或”运算符的后面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* istanbul ignore if  */</span><br><span class="line">if (hardToReproduceError)) &#123;</span><br><span class="line">    return callback(hardToReproduceError);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的 if 语句块，在计算覆盖率的时候会被忽略。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近为了防止因为漏测导致线上问题，做了一些统计测试覆盖率的工作。这个过程中用到了一个检测代码覆盖率的工具，叫：istanbul。它主要能够从几个维度来分析对应的覆盖率。比如下面几个指标：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;行覆盖率（line coverag
      
    
    </summary>
    
      <category term="工程化建设" scheme="https://skhon.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%BB%BA%E8%AE%BE/"/>
    
    
      <category term="Engineering" scheme="https://skhon.github.io/tags/Engineering/"/>
    
  </entry>
  
  <entry>
    <title>搭一个小窝</title>
    <link href="https://skhon.github.io/2021/07/15/my-heart/index/"/>
    <id>https://skhon.github.io/2021/07/15/my-heart/index/</id>
    <published>2021-07-15T12:36:19.443Z</published>
    <updated>2021-12-28T12:40:56.262Z</updated>
    
    <content type="html"><![CDATA[<p>加入字节跳动已经半年多了，后续多做一些技术积累。所以在这里搭建一个小窝，记录一些自己的思想，可能是技术，也可能是扯淡。<a id="more"></a>为的就是以后可以再回忆回忆这段时光。哪怕以后不在互联网工作了，有时间也能再看看曾经走过的这段路程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;加入字节跳动已经半年多了，后续多做一些技术积累。所以在这里搭建一个小窝，记录一些自己的思想，可能是技术，也可能是扯淡。
    
    </summary>
    
      <category term="杂谈" scheme="https://skhon.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="Talking to oneself" scheme="https://skhon.github.io/tags/Talking-to-oneself/"/>
    
  </entry>
  
</feed>
