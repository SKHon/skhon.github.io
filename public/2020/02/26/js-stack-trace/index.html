<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:new URL("https://skhon.github.io").hostname,root:"/",scheme:"Gemini",version:"7.6.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="介绍今天将讨论错误和堆栈跟踪以及如何处理它们。 有时人们不会关注这些细节，但是，如果您正在编写与测试或错误相关的任何库，那么这些知识无疑会很有用。"><meta name="keywords" content="node"><meta property="og:type" content="article"><meta property="og:title" content="JavaScript Errors and Stack Traces"><meta property="og:url" content="https://skhon.github.io/2020/02/26/js-stack-trace/index.html"><meta property="og:site_name" content="前端架构之路"><meta property="og:description" content="介绍今天将讨论错误和堆栈跟踪以及如何处理它们。 有时人们不会关注这些细节，但是，如果您正在编写与测试或错误相关的任何库，那么这些知识无疑会很有用。"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2020-02-26T03:54:50.640Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="JavaScript Errors and Stack Traces"><meta name="twitter:description" content="介绍今天将讨论错误和堆栈跟踪以及如何处理它们。 有时人们不会关注这些细节，但是，如果您正在编写与测试或错误相关的任何库，那么这些知识无疑会很有用。"><link rel="canonical" href="https://skhon.github.io/2020/02/26/js-stack-trace/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0}</script><title>JavaScript Errors and Stack Traces | 前端架构之路</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><a href="https://github.com/SKHon"><img width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_right_darkblue_121621.png?resize=149%2C149" style="position:absolute;top:0;right:0" alt="Fork me on GitHub" data-recalc-dims="1"></a><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">前端架构之路</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">我宁愿犯错，也不想什么都不做</p></div><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://skhon.github.io/2020/02/26/js-stack-trace/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/i.jpg"><meta itemprop="name" content="liujianghong"><meta itemprop="description" content="但行好事，莫问前程"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="前端架构之路"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">JavaScript Errors and Stack Traces</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-02-26 00:00:00 / 修改时间：03:54:50" itemprop="dateCreated datePublished" datetime="2020-02-26T00:00:00Z">2020-02-26</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/前端/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>0</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>0:01</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>今天将讨论错误和堆栈跟踪以及如何处理它们。</p><p>有时人们不会关注这些细节，但是，如果您正在编写与测试或错误相关的任何库，那么这些知识无疑会很有用。<a id="more"></a> 例如，本周在 Chai，我们有一个很棒的 Pull Request，它极大地改善了我们处理堆栈跟踪的方式，以便用户在断言失败时获得更多信息。</p><p>通过操作堆栈跟踪，您可以清理无用的数据并集中精力处理重要的事情。 同样，在了解错误的确切含义及其属性后，您会更加自信地利用它。</p><p>这篇博客文章在开始时似乎太明显了，但是当我们开始操作堆栈跟踪时，它变得非常复杂，因此在移至该部分之前，请确保您对以前的内容有充分的了解。</p><h2 id="调用堆栈如何工作"><a href="#调用堆栈如何工作" class="headerlink" title="调用堆栈如何工作"></a>调用堆栈如何工作</h2><p>在讨论错误之前，我们必须了解调用堆栈的工作方式。 这确实很简单，但是在继续之前必须知道这一点。 如果您已经知道这一点，请随时跳过此部分。</p><p>每当有一个函数调用时，它就会被推到栈顶。 完成运行后，将其从堆栈顶部移除。</p><p>关于此数据结构的有趣之处在于，最后输入的将是第一个输出的数据。 这称为 LIFO（后进先出）属性。</p><p>这意味着，例如，当从函数 x 内部调用函数 y 时，我们将具有依次包含 x 和 y 的堆栈。</p><p>让我再举一个例子，假设您有以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"c"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"b"</span>);</span><br><span class="line">  c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"a"</span>);</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>在上面的示例中，当运行 a 时，它将被添加到我们堆栈的顶部。 然后，当 b 从 a 内部被调用时，它被推入堆栈的顶部。 从 b 调用 c 时，也是如此。</p><p>运行 c 时，我们的堆栈跟踪将按此顺序包含 a，b 和 c。</p><p>一旦 c 完成运行，它就会从堆栈顶部移走，然后控制流回到 b。 当 b 完成时，它也将从堆栈中删除，现在我们将控件放回 a。 最后，当完成运行时，它也会从堆栈中删除。</p><p>为了更好地演示此行为，我们将使用 console.trace（），它将当前的堆栈跟踪信息打印到控制台。 同样，您通常应该从上至下读取堆栈跟踪。 将每行视为从其下一行内部调用的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"c"</span>);</span><br><span class="line">  <span class="built_in">console</span>.trace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"b"</span>);</span><br><span class="line">  c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"a"</span>);</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>在 Node REPL 服务器中运行此命令时，我们会得到以下信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Trace</span><br><span class="line">    at c (repl:<span class="number">3</span>:<span class="number">9</span>)</span><br><span class="line">    at b (repl:<span class="number">3</span>:<span class="number">1</span>)</span><br><span class="line">    at a (repl:<span class="number">3</span>:<span class="number">1</span>)</span><br><span class="line">    at repl:<span class="number">1</span>:<span class="number">1</span> <span class="comment">// &lt;-- For now feel free to ignore anything below this point, these are Node's internals</span></span><br><span class="line">    at realRunInThisContextScript (vm.js:<span class="number">22</span>:<span class="number">35</span>)</span><br><span class="line">    at sigintHandlersWrap (vm.js:<span class="number">98</span>:<span class="number">12</span>)</span><br><span class="line">    at ContextifyScript.Script.runInThisContext (vm.js:<span class="number">24</span>:<span class="number">12</span>)</span><br><span class="line">    at REPLServer.defaultEval (repl.js:<span class="number">313</span>:<span class="number">29</span>)</span><br><span class="line">    at bound (domain.js:<span class="number">280</span>:<span class="number">14</span>)</span><br><span class="line">    at REPLServer.runBound [<span class="keyword">as</span> <span class="built_in">eval</span>] (domain.js:<span class="number">293</span>:<span class="number">12</span>)</span><br></pre></td></tr></table></figure><p>正如我们在这里看到的，当从 c 内部打印堆栈时，我们有 a，b 和 c。</p><p>现在，如果在 c 完成运行之后从 b 内部打印堆栈跟踪，我们将能够看到它已从堆栈顶部删除，因此我们只有 a 和 b。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"c"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"b"</span>);</span><br><span class="line">  c();</span><br><span class="line">  <span class="built_in">console</span>.trace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"a"</span>);</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>如您所见，我们的堆栈中不再有 c，因为它已经完成运行并已弹出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Trace</span><br><span class="line">    at b (repl:<span class="number">4</span>:<span class="number">9</span>)</span><br><span class="line">    at a (repl:<span class="number">3</span>:<span class="number">1</span>)</span><br><span class="line">    at repl:<span class="number">1</span>:<span class="number">1</span>  <span class="comment">// &lt;-- For now feel free to ignore anything below this point, these are Node's internals</span></span><br><span class="line">    at realRunInThisContextScript (vm.js:<span class="number">22</span>:<span class="number">35</span>)</span><br><span class="line">    at sigintHandlersWrap (vm.js:<span class="number">98</span>:<span class="number">12</span>)</span><br><span class="line">    at ContextifyScript.Script.runInThisContext (vm.js:<span class="number">24</span>:<span class="number">12</span>)</span><br><span class="line">    at REPLServer.defaultEval (repl.js:<span class="number">313</span>:<span class="number">29</span>)</span><br><span class="line">    at bound (domain.js:<span class="number">280</span>:<span class="number">14</span>)</span><br><span class="line">    at REPLServer.runBound [<span class="keyword">as</span> <span class="built_in">eval</span>] (domain.js:<span class="number">293</span>:<span class="number">12</span>)</span><br><span class="line">    at REPLServer.onLine (repl.js:<span class="number">513</span>:<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>简而言之：您调用事物，它们就会被推到栈顶。 当他们完成运行时，它们会弹出。 就那么简单。</p><h2 id="错误对象和错误处理"><a href="#错误对象和错误处理" class="headerlink" title="错误对象和错误处理"></a>错误对象和错误处理</h2><p>当发生错误时，通常会抛出一个 Error 对象。 错误对象也可以用作想要扩展它并创建自己的错误的用户的原型。</p><p>Error.prototype 对象通常具有以下属性：</p><ul><li>constructor - The constructor function responsible for this instance’s prototype.</li><li>message - An error message.</li><li>name - The error’s name.</li></ul><p>这些是标准属性，有时每个环境都有其自己的特定属性。 在某些环境中，例如 Node，Firefox，Chrome，Edge，IE 10 +，Opera 和 Safari 6+，我们甚至拥有 stack 属性，其中包含错误的堆栈跟踪。 错误的堆栈跟踪包含所有堆栈帧，直到其自己的构造函数为止。</p><p>如果您想阅读有关 Error 对象的特定属性的更多信息，我强烈建议您阅读有关 MDN 的文章。</p><p>要抛出错误，必须使用 throw 关键字。 为了捕获引发的错误，必须将可能引发错误的代码包装到 try 块中，然后再放入 catch 块。 Catch 还接受一个参数，即抛出的错误。</p><p>正如 Java 中所发生的那样，JavaScript 还允许您在 try / catch 块之后运行一个 finally 块，而不管您的 try 块是否抛出错误。 处理完毕后，最好使用最后清理的东西，无论您的操作是否有效。</p><p>到目前为止，对于大多数人来说，一切都是显而易见的，所以让我们来谈谈一些不重要的细节。</p><p>您可以使用 try 块，但不要在 catch 后面，但是必须在它们后面紧跟着。 这意味着我们可以使用三种不同形式的 try 语句：</p><ul><li>try…catch</li><li>try…finally</li><li>try…catch…finally</li></ul><p>try 语句可以嵌套在其他 try 语句中，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Nested error."</span>); <span class="comment">// The error thrown here will be caught by its own `catch` clause</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (nestedErr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Nested catch"</span>); <span class="comment">// This runs</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"This will not run."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您还可以将 try 语句嵌套到 catch 和 finally 块中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"First error"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"First catch running"</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Second error"</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (nestedErr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Second catch running."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"The try block is running..."</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Error inside finally."</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Caught an error inside the finally block."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请务必注意，您还可以抛出不是 Error 对象的值，这一点也很重要。 尽管这看起来很酷，但实际上并没有那么好，尤其是对于那些使用必须处理其他人的代码的库的开发人员而言，因为那时没有标准，而且您永远都不知道用户会期望什么。 您不能仅仅因为它们选择不这样做而仅仅抛出一个字符串或一个数字就相信它们会引发 Error 对象。 如果您需要处理堆栈跟踪和其他有意义的元数据，这也将变得更加困难。</p><p>假设您有以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runWithoutThrowing</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    func();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"There was an error, but I will not throw it."</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"The error's message was: "</span> + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcThatThrowsError</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"I am a TypeError."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runWithoutThrowing(funcThatThrowsError);</span><br></pre></td></tr></table></figure><p>如果您的用户正在传递将 Error 对象抛出到您的 runWithoutThrowing 函数的函数，这将非常有用。 但是，如果它们最终抛出一个 String，那么您可能会遇到麻烦：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runWithoutThrowing</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    func();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"There was an error, but I will not throw it."</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"The error's message was: "</span> + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcThatThrowsString</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">"I am a String."</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runWithoutThrowing(funcThatThrowsString);</span><br></pre></td></tr></table></figure><p>现在，您的第二个 console.log 将显示错误消息未定义。 现在这似乎并不重要，但是如果您需要确保某个 Error 对象上存在某些属性或以另一种方式处理特定于 Error 的属性（例如 Chai 的 throws 断言确实需要），则您需要做更多的工作来确保它可以工作 对。</p><p>另外，当抛出不是 Error 对象的值时，您将无权访问其他重要数据，例如堆栈，这是 Error 对象在某些环境中具有的属性。</p><p>错误也可以用作任何其他对象，您不一定需要将其引发，这就是为什么它们多次被用作回调函数的第一个参数的原因，例如 fs.readdir 函数就是这种情况。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line">fs.readdir(<span class="string">"/example/i-do-not-exist"</span>, <span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">err, dirs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err <span class="keyword">instanceof</span> <span class="built_in">Error</span>) &#123;</span><br><span class="line">    <span class="comment">// `readdir` will throw an error because that directory does not exist</span></span><br><span class="line">    <span class="comment">// We will now be able to use the error object passed by it in our callback function</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Error Message: "</span> + err.message);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"See? We can use Errors without using try statements."</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(dirs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最后但并非最不重要的一点是，在拒绝承诺时也可以使用 Error 对象。 这使得处理承诺拒绝更容易：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"The promise was rejected."</span>));</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"I am an error."</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err <span class="keyword">instanceof</span> <span class="built_in">Error</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"The promise was rejected with an error."</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"Error Message: "</span> + err.message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h2 id="操纵堆栈跟踪"><a href="#操纵堆栈跟踪" class="headerlink" title="操纵堆栈跟踪"></a>操纵堆栈跟踪</h2><p>现在，您一直在等待的部分：如何操作堆栈跟踪。</p><p>本章专门针对支持 Error.captureStackTrace 的环境（例如 NodeJS）。</p><p>Error.captureStackTrace 函数将一个对象作为第一个参数，并可选地将一个函数作为第二个参数。 捕获堆栈跟踪的作用是（显然）捕获当前堆栈跟踪，并在目标对象中创建一个堆栈属性来存储它。 如果提供了第二个参数，则传递的函数将被视为调用堆栈的终点，因此，堆栈跟踪将仅显示在调用此函数之前发生的调用。</p><p>让我们使用一些示例来更清楚地说明这一点。 首先，我们将捕获当前的堆栈跟踪并将其存储在一个公共对象中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Here we will store the current stack trace into myObj</span></span><br><span class="line">  <span class="built_in">Error</span>.captureStackTrace(myObj);</span><br><span class="line">  c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// First we will call these functions</span></span><br><span class="line">a();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now let's see what is the stack trace stored into myObj.stack</span></span><br><span class="line"><span class="built_in">console</span>.log(myObj.stack);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This will print the following stack to the console:</span></span><br><span class="line"><span class="comment">//    at b (repl:3:7) &lt;-- Since it was called inside B, the B call is the last entry in the stack</span></span><br><span class="line"><span class="comment">//    at a (repl:2:1)</span></span><br><span class="line"><span class="comment">//    at repl:1:1 &lt;-- Node internals below this line</span></span><br><span class="line"><span class="comment">//    at realRunInThisContextScript (vm.js:22:35)</span></span><br><span class="line"><span class="comment">//    at sigintHandlersWrap (vm.js:98:12)</span></span><br><span class="line"><span class="comment">//    at ContextifyScript.Script.runInThisContext (vm.js:24:12)</span></span><br><span class="line"><span class="comment">//    at REPLServer.defaultEval (repl.js:313:29)</span></span><br><span class="line"><span class="comment">//    at bound (domain.js:280:14)</span></span><br><span class="line"><span class="comment">//    at REPLServer.runBound [as eval] (domain.js:293:12)</span></span><br><span class="line"><span class="comment">//    at REPLServer.onLine (repl.js:513:10)</span></span><br></pre></td></tr></table></figure><p>您可以在上面的示例中注意到，我们首先调用 a（将其推入堆栈），然后从 a 内部调用 b（将其推入 a 顶部）。 然后，在 b 内部，我们捕获了当前的堆栈跟踪并将其存储到 myObj 中。 这就是为什么我们在打印到控制台的堆栈中只得到 a 然后再得到 b 的原因。</p><p>现在，将一个函数作为第二个参数传递给 Error.captureStackTrace 函数，看看会发生什么：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Here we will store the current stack trace into myObj</span></span><br><span class="line">  <span class="comment">// This time we will hide all the frames after `b` and `b` itself</span></span><br><span class="line">  <span class="built_in">Error</span>.captureStackTrace(myObj, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  d();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// First we will call these functions</span></span><br><span class="line">a();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now let's see what is the stack trace stored into myObj.stack</span></span><br><span class="line"><span class="built_in">console</span>.log(myObj.stack);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This will print the following stack to the console:</span></span><br><span class="line"><span class="comment">//    at a (repl:2:1) &lt;-- As you can see here we only get frames before `b` was called</span></span><br><span class="line"><span class="comment">//    at repl:1:1 &lt;-- Node internals below this line</span></span><br><span class="line"><span class="comment">//    at realRunInThisContextScript (vm.js:22:35)</span></span><br><span class="line"><span class="comment">//    at sigintHandlersWrap (vm.js:98:12)</span></span><br><span class="line"><span class="comment">//    at ContextifyScript.Script.runInThisContext (vm.js:24:12)</span></span><br><span class="line"><span class="comment">//    at REPLServer.defaultEval (repl.js:313:29)</span></span><br><span class="line"><span class="comment">//    at bound (domain.js:280:14)</span></span><br><span class="line"><span class="comment">//    at REPLServer.runBound [as eval] (domain.js:293:12)</span></span><br><span class="line"><span class="comment">//    at REPLServer.onLine (repl.js:513:10)</span></span><br><span class="line"><span class="comment">//    at emitOne (events.js:101:20)</span></span><br></pre></td></tr></table></figure><p>当我们将 b 传递给 Error.captureStackTraceFunction 时，它会将 b 自身及其上方的所有帧都隐藏起来。 这就是为什么我们在堆栈跟踪中仅包含一个的原因。</p><p>现在您可能会问自己：“为什么这样做有用？”。 这很有用，因为您可以使用它来隐藏与用户无关的内部实现细节。 例如，在 Chai 中，我们使用它来避免向用户显示与我们自己实现检查和断言的方式无关的细节。</p><h2 id="现实世界中的堆栈跟踪操作"><a href="#现实世界中的堆栈跟踪操作" class="headerlink" title="现实世界中的堆栈跟踪操作"></a>现实世界中的堆栈跟踪操作</h2><p>正如我在上一节中提到的，Chai 使用堆栈操纵技术使堆栈跟踪与我们的用户更加相关。 这是我们的方法。</p><p>首先，让我们看一下断言失败时抛出的 AssertionError 构造函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `ssfi` stands for "start stack function". It is the reference to the</span></span><br><span class="line"><span class="comment">// starting point for removing irrelevant frames from the stack trace</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AssertionError</span>(<span class="params">message, _props, ssf</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> extend = exclude(<span class="string">"name"</span>, <span class="string">"message"</span>, <span class="string">"stack"</span>, <span class="string">"constructor"</span>, <span class="string">"toJSON"</span>),</span><br><span class="line">    props = extend(_props || &#123;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Default values</span></span><br><span class="line">  <span class="keyword">this</span>.message = message || <span class="string">"Unspecified AssertionError"</span>;</span><br><span class="line">  <span class="keyword">this</span>.showDiff = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy from properties</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">    <span class="keyword">this</span>[key] = props[key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Here is what is relevant for us:</span></span><br><span class="line">  <span class="comment">// If a start stack function was provided we capture the current stack trace and pass</span></span><br><span class="line">  <span class="comment">// it to the `captureStackTrace` function so we can remove frames that come after it</span></span><br><span class="line">  ssf = ssf || <span class="built_in">arguments</span>.callee;</span><br><span class="line">  <span class="keyword">if</span> (ssf &amp;&amp; <span class="built_in">Error</span>.captureStackTrace) &#123;</span><br><span class="line">    <span class="built_in">Error</span>.captureStackTrace(<span class="keyword">this</span>, ssf);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// If no start stack function was provided we just use the original stack property</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">this</span>.stack = e.stack;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，我们使用 Error.captureStackTrace 捕获堆栈跟踪并将其存储到我们正在构建的 AssertionError 实例中（如果存在），我们将向其传递一个起始堆栈函数，以从中删除无关帧 堆栈跟踪，仅显示 Chai 的内部实现细节，最终使堆栈“变脏”。</p><p>现在，让我们看一下@meeber 在此出色的 PR 中编写的最新代码。</p><p>在查看下面的代码之前，我必须告诉您 addChainableMethod 的作用。 它将传递给它的可链接方法添加到断言中，并且还使用包装断言的方法标记断言本身。 它以名称 ssfi（代表启动堆栈功能指示器）存储。 这基本上意味着当前断言将是堆栈中的最后一帧，因此我们将在堆栈中不再显示 Chai 的其他内部方法。 我避免为此添加完整的代码，因为它可以完成很多事情并且有点棘手，但是如果您想阅读它，请转到此处的链接。</p><p>在下面的代码段中，我们具有 lengthOf 断言的逻辑，该逻辑检查对象是否具有特定长度。 我们希望我们的用户像这样使用它：expect([‘foo’，’bar’]).to.have.lengthOf(2)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assertLength</span>(<span class="params">n, msg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (msg) flag(<span class="keyword">this</span>, <span class="string">"message"</span>, msg);</span><br><span class="line">  <span class="keyword">var</span> obj = flag(<span class="keyword">this</span>, <span class="string">"object"</span>),</span><br><span class="line">    ssfi = flag(<span class="keyword">this</span>, <span class="string">"ssfi"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pay close attention to this line</span></span><br><span class="line">  <span class="keyword">new</span> Assertion(obj, msg, ssfi, <span class="literal">true</span>).to.have.property(<span class="string">"length"</span>);</span><br><span class="line">  <span class="keyword">var</span> len = obj.length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This line is also relevant</span></span><br><span class="line">  <span class="keyword">this</span>.assert(</span><br><span class="line">    len == n,</span><br><span class="line">    <span class="string">"expected #&#123;this&#125; to have a length of #&#123;exp&#125; but got #&#123;act&#125;"</span>,</span><br><span class="line">    <span class="string">"expected #&#123;this&#125; to not have a length of #&#123;act&#125;"</span>,</span><br><span class="line">    n,</span><br><span class="line">    len</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Assertion.addChainableMethod(<span class="string">"lengthOf"</span>, assertLength, assertLengthChain);</span><br></pre></td></tr></table></figure><p>在上面的代码中，我突出显示了当前与我们相关的行。 让我们从对 this.assert 的调用开始。</p><p>这是 this.assert 方法的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Assertion.prototype.assert = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  expr,</span></span></span><br><span class="line"><span class="function"><span class="params">  msg,</span></span></span><br><span class="line"><span class="function"><span class="params">  negateMsg,</span></span></span><br><span class="line"><span class="function"><span class="params">  expected,</span></span></span><br><span class="line"><span class="function"><span class="params">  _actual,</span></span></span><br><span class="line"><span class="function"><span class="params">  showDiff</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ok = util.test(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span> !== showDiff) showDiff = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">undefined</span> === expected &amp;&amp; <span class="literal">undefined</span> === _actual) showDiff = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span> !== config.showDiff) showDiff = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">    msg = util.getMessage(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">var</span> actual = util.getActual(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is the relevant line for us</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(</span><br><span class="line">      msg,</span><br><span class="line">      &#123;</span><br><span class="line">        actual: actual,</span><br><span class="line">        expected: expected,</span><br><span class="line">        showDiff: showDiff</span><br><span class="line">      &#125;,</span><br><span class="line">      config.includeStack ? <span class="keyword">this</span>.assert : flag(<span class="keyword">this</span>, <span class="string">"ssfi"</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>基本上，assert 方法负责检查 assert 布尔表达式是否通过。 如果没有，我们必须实例化一个 AssertionError。 请注意，在实例化此新的 AssertionError 时，我们还向其传递了堆栈跟踪功能指示器（ssfi）。 如果打开了配置标记 includeStack，我们通过将 this.assert 本身传递给用户，向用户显示整个堆栈跟踪，这实际上是堆栈中的最后一帧。 但是，如果关闭了 includeStack 配置标志，我们必须从堆栈跟踪中隐藏更多内部实现细节，因此我们将使用存储在 ssfi 标志中的内容。</p><p>现在，让我们谈谈与我们相关的另一条线：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Assertion(obj, msg, ssfi, <span class="literal">true</span>).to.have.property(<span class="string">"length"</span>);</span><br></pre></td></tr></table></figure><p>如您所见，在创建嵌套断言时，我们将传递从 ssfi 标志获得的内容。 这意味着在创建新的断言时，它将使用此函数作为从堆栈跟踪中删除无用帧的起点。 顺便说一下，这是 Assertion 构造函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Assertion</span>(<span class="params">obj, msg, ssfi, lockSsfi</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// This is the line that matters to us</span></span><br><span class="line">  flag(<span class="keyword">this</span>, <span class="string">"ssfi"</span>, ssfi || Assertion);</span><br><span class="line">  flag(<span class="keyword">this</span>, <span class="string">"lockSsfi"</span>, lockSsfi);</span><br><span class="line">  flag(<span class="keyword">this</span>, <span class="string">"object"</span>, obj);</span><br><span class="line">  flag(<span class="keyword">this</span>, <span class="string">"message"</span>, msg);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> util.proxify(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以从我对 addChainableMethod 的描述中记住，它使用自己的 wrapper 方法设置 ssfi 标志，这意味着这是堆栈跟踪中的最低内部框架，因此我们可以删除其上方的所有框架。</p><p>通过将 ssfi 传递给嵌套断言，该断言仅检查我们的对象是否具有属性长度，从而避免了重置框架（该框架将用作起点指示符），而使先前的 addChainableMethod 在堆栈中可见。</p><p>这看起来似乎有些复杂，所以让我们回顾一下 Chai 内部发生的情况，我们想从堆栈中删除无用的帧：</p><ul><li>当运行断言时，我们将其自己的方法设置为删除堆栈中下一帧的参考</li><li>断言运行，如果失败，我们将在存储引用后删除所有内部框架</li><li>如果我们嵌套了断言，则仍必须使用当前断言包装器方法作为删除堆栈中下一帧的参考点，因此我们将当前的 ssfi（启动栈功能指示器）传递给我们正在创建的断言，以便可以保留它</li></ul><p>我也强烈建议您阅读@meeber 的评论，以了解它。</p></div><div><div class="my_post_copyright"><script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script><script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script><script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script><p><span>本文标题:</span><a href="/2020/02/26/js-stack-trace/">JavaScript Errors and Stack Traces</a></p><p><span>文章作者:</span><a href="/" title="访问 liujianghong 的个人博客">liujianghong</a></p><p><span>发布时间:</span>2020年02月26日 - 00:00</p><p><span>最后更新:</span>2020年02月26日 - 03:54</p><p><span>原始链接:</span><a href="/2020/02/26/js-stack-trace/" title="JavaScript Errors and Stack Traces">https://skhon.github.io/2020/02/26/js-stack-trace/</a> <span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="https://skhon.github.io/2020/02/26/js-stack-trace/" aria-label="复制成功！"></i></span></p><p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p></div><script>var clipboard=new Clipboard(".fa-clipboard");$(".fa-clipboard").click(function(){clipboard.on("success",function(){swal({title:"",text:"复制成功",icon:"success",showConfirmButton:!0})})})</script></div><div class="reward-container"><div>坚持原创技术分享，您的支持将鼓励我继续创作！</div><button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/wechatpay.jpg" alt="liujianghong 微信支付"><p>微信支付</p></div><div style="display:inline-block"><img src="/images/alipay.jpg" alt="liujianghong 支付宝"><p>支付宝</p></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/node/" rel="tag"><i class="fa fa-tag"></i> node</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2020/02/25/jmeter-test/" rel="prev" title="jmeter压测"><i class="fa fa-chevron-left"></i> jmeter压测</a></div><div class="post-nav-item"><a href="/2020/03/04/hobber/" rel="next" title="整理一下hobber">整理一下hobber <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><script>window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#介绍"><span class="nav-number">1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调用堆栈如何工作"><span class="nav-number">2.</span> <span class="nav-text">调用堆栈如何工作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#错误对象和错误处理"><span class="nav-number">3.</span> <span class="nav-text">错误对象和错误处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操纵堆栈跟踪"><span class="nav-number">4.</span> <span class="nav-text">操纵堆栈跟踪</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#现实世界中的堆栈跟踪操作"><span class="nav-number">5.</span> <span class="nav-text">现实世界中的堆栈跟踪操作</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="liujianghong" src="/images/i.jpg"><p class="site-author-name" itemprop="name">liujianghong</p><div class="site-description" itemprop="description">但行好事，莫问前程</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">10</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">1</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">4</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/SKHon" title="GitHub → https://github.com/SKHon" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:ljhtianhonng@163.com" title="E-Mail → mailto:ljhtianhonng@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://zhuanlan.zhihu.com/c_1099361240064921600" title="https://zhuanlan.zhihu.com/c_1099361240064921600" rel="noopener" target="_blank">贝壳架构组</a></li></ul></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">liujianghong</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">32k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">0:29</span></div><div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div><span class="post-meta-divider">|</span><div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0</div></div></footer></div><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script></body></html>