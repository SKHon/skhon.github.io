<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>前端架构之路</title>
  <icon>https://www.gravatar.com/avatar/bafeed710faffad62197c060e0e91fda</icon>
  <subtitle>我宁愿犯错，也不想什么都不做</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://skhon.github.io/"/>
  <updated>2020-06-09T09:42:57.963Z</updated>
  <id>https://skhon.github.io/</id>
  
  <author>
    <name>liujianghong</name>
    <email>ljhtianhong@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>node端请求库选型</title>
    <link href="https://skhon.github.io/2020/06/09/http-request/"/>
    <id>https://skhon.github.io/2020/06/09/http-request/</id>
    <published>2020-06-08T16:25:24.000Z</published>
    <updated>2020-06-09T09:42:57.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>项目之前node端http请求库用端request，由于request后续不维护了，所以，为了后续项目更好的迭代，就打算换一个。<a id="more"></a></p><h2 id="需要考虑的因素"><a href="#需要考虑的因素" class="headerlink" title="需要考虑的因素"></a>需要考虑的因素</h2><p>需要考虑的因素有这么几个方面：</p><ol><li><p>性能问题。之前压过request的性能，基于我们项目qps大概能压到1000所有。那用的新的请求库，qps不应该低于1000，要不然业务方会找你的。</p></li><li><p>兼容问题。别我们选完了，发了新版本，最后业务方说我们的服务不能用了，当然，如果非要业务方做一些改动来适配，那也可以，但是尽量让业务方改动最小，不然他们会觉得你的这个框架很low，尽管他不会关注你框架的实现。当然，兼容问题不光是业务方的项目代码，还有node版本，有的请求库要求的node版本不一样，而业务方线上环境的node大多是在v8.6.0.如果你的框架node需要更高的版本，还需要线上环境的node升级，这个时候，业务方又觉得你的框架有点low。</p></li><li><p>框架自身。框架本身好不好使用，也是一个问题，别你选了一个请求库，最后发现，自己都觉得超级复杂，那我觉得还是算了吧，后续迭代，如果出了什么问题，或者需要加个什么需求，你会痛苦死的。</p></li><li><p>框架生态。看看框架生态活不活跃，如果不活跃了，你想提个issue，发现一百年没人理你，一看open的issue一堆，没人管，那也算了吧，出了问题，估计需要你动手改请求库的源码了。</p></li><li><p>使用数量。这个指标其实是一个参考性，用的人多，说明这个框架还是受人青睐的，群众的眼睛还是雪亮的，所以，需要参考一下。</p></li></ol><h2 id="几个node请求库"><a href="#几个node请求库" class="headerlink" title="几个node请求库"></a>几个node请求库</h2><p>由于我们项目之前用的request，所以，看看别的库吧。</p><ol><li><p><a href="https://github.com/sindresorhus/got#readme" target="_blank" rel="noopener">got</a><br>这个库我看了一下，什么都挺好的，就有一点，node版本需要10.19.0以上，所以就pass了吧，我们公司线上的node环境很多是8.6.0的。</p></li><li><p><a href="https://github.com/axios/axios" target="_blank" rel="noopener">axios</a></p><blockquote><p>先看性能，压了一下，基本和request的差不多，所以，这方面可以接受<br>兼容问题，这个有返回的response结构，和request的不一样，改动比较多，node版本倒是没啥问题，符合我们公司线上的node版本。<br>框架自身也也比较好使<br>生态比较丰富<br>用的人也挺多的。</p></blockquote></li><li><p><a href="https://github.com/visionmedia/superagent" target="_blank" rel="noopener">Superagent</a></p><blockquote><p>主要是插件式写法，和之前request的使用方式差别比较大，就算了吧，要不然，给之前用户带来的风险很大。</p></blockquote></li><li><p><a href="https://github.com/node-fetch/node-fetch#options" target="_blank" rel="noopener">node-fetch</a></p><blockquote><p>功能不是很全，覆盖不了之前的功能，就算了吧。</p></blockquote></li></ol><p>所以，选择axios吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;项目之前node端http请求库用端request，由于request后续不维护了，所以，为了后续项目更好的迭代，就打算换一个。
    
    </summary>
    
      <category term="前端" scheme="https://skhon.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://skhon.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>探索一下node的性能瓶颈</title>
    <link href="https://skhon.github.io/2020/06/02/koa/"/>
    <id>https://skhon.github.io/2020/06/02/koa/</id>
    <published>2020-06-01T18:10:00.000Z</published>
    <updated>2020-06-04T04:13:21.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>这两天自己压测 hobber 框架，想看看 qps 能打到多少。和测试借了一台 cpu 8 核， 内存 32GB 的机器，node 版本 12.8。另外 4 台发压机。压测工具用的 jmeter。<a id="more"></a></p><h2 id="裸压-hello-world"><a href="#裸压-hello-world" class="headerlink" title="裸压 hello world"></a>裸压 hello world</h2><p>先裸压 hello world，并发 400，压了 120s。最后结论是 qps 打到 3000 多就上不去了，但是机器 cpu 使用率一直在 25%左右。<br><img src="/images/node_pro/hobber01.png" alt></p><p><img src="/images/node_pro/hobber02.png" alt></p><p>后续并发增加到 800，发现 qps 上不去了，cpu 的使用率也上不去了。那么到这里，就有个疑问，qps 为什么压不上去了？cpu 还没打满呀，应该还有空间的呀。到这里，就卡壳了，不知道怎么回事了。</p><p>我想了想，因为 hobber 是基于 koa 开发的，那我就想着用直接写一个简单的应用，koa + koa-router + log4js 来大概模拟一个简单的服务，看能不能把 cpu 给压上去。</p><h2 id="压-koa"><a href="#压-koa" class="headerlink" title="压 koa"></a>压 koa</h2><p>还是上述的配置，来压 koa，单核，800 并发，压了 120s，qps 大概能飙到 6000 多，cpu 在 35%左右。看起来是相比 hobber，qps 和 cpu 都压上去一点了，但是还是上述的问题，增加并发，cpu 和 qps 都上不去了，感觉就像到了瓶颈一样。那么这个时候，可以有多种可能，可能是 linux 系统就是这么调度的，单核情况下，你的 cpu 不会给你分配很高的。也可能是 node 的性能瓶颈，并发达到一定程度后，libuv 管理的线程池操作不了这么大的量，就挂起等待了，就是说 node 性能本身就有瓶颈。到这里，问题好想有点难搞了，但是我觉得，要是 node 本身有瓶颈，那应该早有人爆出来了呀。。我反正觉得，应该不是 node 的问题。这个时候，我又想起了一个框架就是 egg，把 egg 也压一下，和 hobber 做个对比。</p><h2 id="压-egg"><a href="#压-egg" class="headerlink" title="压 egg"></a>压 egg</h2><p>配置没变，还是 8 核，32g 内存的配置，先单核裸压 egg，压的结果和 hobber 基本一致，qps3000 多，cpu 在 25%左右，增加并发也上不去了。然后！！我把 egg 多核打开，我的机器 8 核，跑 8 个进程，800 并发开始压，发现 qps 能飙到 1w 左右，cpu 能打到 90%左右。</p><h2 id="压-node-自带-http-模块"><a href="#压-node-自带-http-模块" class="headerlink" title="压 node 自带 http 模块"></a>压 node 自带 http 模块</h2><p>配置依然没变，800 并发，压 http 模块，发现 qps 上去了，能打到近 9k，cpu 只能到 30%。那么，cpu 为什么上不去呢？</p><h2 id="为什么压测-node-服务系统-cpu-上不去"><a href="#为什么压测-node-服务系统-cpu-上不去" class="headerlink" title="为什么压测 node 服务系统 cpu 上不去"></a>为什么压测 node 服务系统 cpu 上不去</h2><p>到这里，其实就有结论了。node 不开 cluster 情况下，单进程单线程，就跑一个 cpu，我们服务所在机器共 8 核，你只跑一个，最多也只把 node 用的这个 cpu 跑满， 这种情况系统 cpu 肯定不会打满的，这就是为什么你 node 服务（未开启 cluster）压测，cpu 一直上不去的原因。</p><h2 id="node-的负载有瓶颈吗"><a href="#node-的负载有瓶颈吗" class="headerlink" title="node 的负载有瓶颈吗"></a>node 的负载有瓶颈吗</h2><p>我网上搜了一下 node 负载相关文章，看到这篇：<a href="https://www.cnblogs.com/cqq626/p/7775196.html" target="_blank" rel="noopener">点这里</a> ，我看作者也是压了 koa，他的机器是 48 核，他最后把 48 核都开启了，node 的最后 qps 也最多打到 1w 左右，作者最后给的结论是，http 模块的 qps 最多 1w。</p><p>我这个人，就是爱动手。。。我压了 http 模块，机器还是我上面提到的机器，4 台发压机，2000 并能，压 5 分钟，未开启 cluster 情况下，qps 能到近 9k，cpu 在 30%（这里基本可以验证，为什么压测 node 服务系统【单进程】 cpu 上不去 的原因），然后我开启 cluster，qps 能到 14k。。。那这基本可以反驳上述作者的观点了<br>。最后，我觉得，node 的负载瓶颈肯定是有的，只不过，我目前能拿到的机器，还达不到能压出 node 瓶颈的配置，后续结论，随缘吧。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;这两天自己压测 hobber 框架，想看看 qps 能打到多少。和测试借了一台 cpu 8 核， 内存 32GB 的机器，node 版本 12.8。另外 4 台发压机。压测工具用的 jmeter。
    
    </summary>
    
      <category term="前端" scheme="https://skhon.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="node" scheme="https://skhon.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>项目代码没动过，之前好使，现在报错了？</title>
    <link href="https://skhon.github.io/2020/05/14/package-lock/"/>
    <id>https://skhon.github.io/2020/05/14/package-lock/</id>
    <published>2020-05-14T15:00:00.000Z</published>
    <updated>2020-05-14T08:21:22.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>昨天晚上，有个业务方过来问，之前hobber项目跑的好好的，下午部署怎么报错了？看git提交记录，也没动过代码呀。<br>然后我就帮他查，最后定位到require一个依赖库的时候，报错了。那为什么代码没动过，之前部署没问题，现在就不行了呢？<br><a id="more"></a></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先，我们项目代码没动过，之前好使，现在不好使，基本可以说明，我们项目的业务代码是没问题的，那么，哪些地方会出问题呢？<br>我们先分析一下我开始说的案例，我回头看了一下他们项目的git仓库，发现缺少一个文件：package-lock.json。这个是破案的关键，因为package-lock.json是锁定依赖版本的，那么项目重新部署时，项目是没有package-lock.json的，那在npm install的时候，会拉一下依赖版本的最新小版本，如果某个依赖，刚刚发了一个小版本，但是这个小版本可能会影响你的项目，一旦这中小概率时间命中了你的项目，那就出现了上述提到的问题。我的项目代码明明没动过，为什么重新部署的时候，就会报错。</p><h2 id="怎么解决"><a href="#怎么解决" class="headerlink" title="怎么解决"></a>怎么解决</h2><p>知道问题的原因，就比较容易找解决方案了。找到之前项目没问题时候的package-lock.json文件，把这个文件拷贝过来替换到有问题的项目中，把node_modules删掉，重新npm install 一下，基本就ok了。所以，大家要注意，在提交代码的时候，package-lock.json也应该被提交。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;昨天晚上，有个业务方过来问，之前hobber项目跑的好好的，下午部署怎么报错了？看git提交记录，也没动过代码呀。&lt;br&gt;然后我就帮他查，最后定位到require一个依赖库的时候，报错了。那为什么代码没动过，之前部署没问题，现在就不行了呢？&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="https://skhon.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="node" scheme="https://skhon.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>你见过js报的这些错吗</title>
    <link href="https://skhon.github.io/2020/05/13/js-error/"/>
    <id>https://skhon.github.io/2020/05/13/js-error/</id>
    <published>2020-05-13T10:00:00.000Z</published>
    <updated>2020-05-14T08:21:22.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数字–"><a href="#数字–" class="headerlink" title="数字–"></a>数字–</h2><p>在刷题过程中，这么写了一下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var map = new Map()</span><br><span class="line">map.set(1,1)</span><br><span class="line">var result = map.get(1)--</span><br></pre></td></tr></table></figure><p>会报这样的错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught ReferenceError: Invalid left-hand side expression in postfix operation</span><br></pre></td></tr></table></figure><a id="more"></a><p>【原因】数字不能–，得用变量</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数字–&quot;&gt;&lt;a href=&quot;#数字–&quot; class=&quot;headerlink&quot; title=&quot;数字–&quot;&gt;&lt;/a&gt;数字–&lt;/h2&gt;&lt;p&gt;在刷题过程中，这么写了一下代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var map = new Map()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;map.set(1,1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var result = map.get(1)--&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;会报这样的错：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Uncaught ReferenceError: Invalid left-hand side expression in postfix operation&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="前端" scheme="https://skhon.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="node" scheme="https://skhon.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>谈谈JSON.stringify</title>
    <link href="https://skhon.github.io/2020/04/16/JSON/"/>
    <id>https://skhon.github.io/2020/04/16/JSON/</id>
    <published>2020-04-16T12:00:00.000Z</published>
    <updated>2020-04-16T08:54:00.466Z</updated>
    
    <content type="html"><![CDATA[<h2 id="先谈谈深拷贝的局限"><a href="#先谈谈深拷贝的局限" class="headerlink" title="先谈谈深拷贝的局限"></a>先谈谈深拷贝的局限</h2><p>有些文章介绍深拷贝的方法，说 JSON.parse(JSON.stringify(obj))可以进行深拷贝。其实这种深拷贝方法有很多局限：</p><a id="more"></a><h3 id="如果-json-里面有时间对象，则序列化结果：时间对象-gt-字符串的形式"><a href="#如果-json-里面有时间对象，则序列化结果：时间对象-gt-字符串的形式" class="headerlink" title="如果 json 里面有时间对象，则序列化结果：时间对象=&gt;字符串的形式"></a>如果 json 里面有时间对象，则序列化结果：时间对象=&gt;字符串的形式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    age: 18,</span><br><span class="line">    date: new Date()</span><br><span class="line">&#125;;</span><br><span class="line">let objCopy = JSON.parse(JSON.stringify(obj));</span><br><span class="line">console.log(&apos;obj&apos;, obj);</span><br><span class="line">console.log(&apos;objCopy&apos;, objCopy);</span><br><span class="line">console.log(typeof obj.date); // object</span><br><span class="line">console.log(typeof objCopy.date); // string</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/images/JSON_1.png" alt></p><h3 id="如果-json-里有-RegExp、Error-对象，则序列化的结果将只得到空对象-RegExp、Error-gt"><a href="#如果-json-里有-RegExp、Error-对象，则序列化的结果将只得到空对象-RegExp、Error-gt" class="headerlink" title="如果 json 里有 RegExp、Error 对象，则序列化的结果将只得到空对象 RegExp、Error =&gt; {}"></a>如果 json 里有 RegExp、Error 对象，则序列化的结果将只得到空对象 RegExp、Error =&gt; {}</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let obj = &#123;</span><br><span class="line">        age: 18,</span><br><span class="line">        reg: new RegExp(&apos;\\w+&apos;),</span><br><span class="line">        err: new Error(&apos;error message&apos;)</span><br><span class="line">    &#125;;</span><br><span class="line">    let objCopy = JSON.parse(JSON.stringify(obj));</span><br><span class="line">    console.log(&apos;obj&apos;, obj);</span><br><span class="line">    console.log(&apos;objCopy&apos;, objCopy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/images/JSON_2.png" alt></p><h3 id="如果-json-里有-function-undefined，则序列化的结果会把-function-undefined-丢失"><a href="#如果-json-里有-function-undefined，则序列化的结果会把-function-undefined-丢失" class="headerlink" title="如果 json 里有 function,undefined，则序列化的结果会把 function,undefined 丢失"></a>如果 json 里有 function,undefined，则序列化的结果会把 function,undefined 丢失</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let obj = &#123;</span><br><span class="line">        age: 18,</span><br><span class="line">        fn: function () &#123;</span><br><span class="line">            console.log(&apos;fn&apos;);</span><br><span class="line">        &#125;,</span><br><span class="line">        hh: undefined</span><br><span class="line">    &#125;;</span><br><span class="line">    let objCopy = JSON.parse(JSON.stringify(obj));</span><br><span class="line">    console.log(&apos;obj&apos;, obj);</span><br><span class="line">    console.log(&apos;objCopy&apos;, objCopy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/images/JSON_3.png" alt></p><h3 id="如果-json-里有-NaN、Infinity-和-Infinity，则序列化的结果会变成-null"><a href="#如果-json-里有-NaN、Infinity-和-Infinity，则序列化的结果会变成-null" class="headerlink" title="如果 json 里有 NaN、Infinity 和-Infinity，则序列化的结果会变成 null"></a>如果 json 里有 NaN、Infinity 和-Infinity，则序列化的结果会变成 null</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let obj = &#123;</span><br><span class="line">        age: 18,</span><br><span class="line">        hh: NaN,</span><br><span class="line">        isInfinite: 1.7976931348623157E+10308,</span><br><span class="line">        minusInfinity: -1.7976931348623157E+10308</span><br><span class="line">    &#125;;</span><br><span class="line">    let objCopy = JSON.parse(JSON.stringify(obj));</span><br><span class="line">    console.log(&apos;obj&apos;, obj);</span><br><span class="line">    console.log(&apos;objCopy&apos;, objCopy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/images/JSON_4.png" alt></p><h3 id="如果-json-里有对象是由构造函数生成的，则序列化的结果会丢弃对象的-constructor"><a href="#如果-json-里有对象是由构造函数生成的，则序列化的结果会丢弃对象的-constructor" class="headerlink" title="如果 json 里有对象是由构造函数生成的，则序列化的结果会丢弃对象的 constructor"></a>如果 json 里有对象是由构造函数生成的，则序列化的结果会丢弃对象的 constructor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    function Person(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    let obj = &#123;</span><br><span class="line">        age: 18,</span><br><span class="line">        p1: new Person(&apos;lxcan&apos;)</span><br><span class="line">    &#125;;</span><br><span class="line">    let objCopy = JSON.parse(JSON.stringify(obj));</span><br><span class="line">    console.log(&apos;obj&apos;, obj);</span><br><span class="line">    console.log(&apos;objCopy&apos;, objCopy);</span><br><span class="line">    console.log(obj.p1.__proto__.constructor === Person); // true</span><br><span class="line">    console.log(objCopy.p1.__proto__.constructor === Object); // true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/images/JSON_5.png" alt></p><h3 id="如果对象中存在循环引用的情况也无法实现深拷贝"><a href="#如果对象中存在循环引用的情况也无法实现深拷贝" class="headerlink" title="如果对象中存在循环引用的情况也无法实现深拷贝"></a>如果对象中存在循环引用的情况也无法实现深拷贝</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let obj = &#123;</span><br><span class="line">        age: 18</span><br><span class="line">    &#125;;</span><br><span class="line">    obj.obj = obj;</span><br><span class="line">    let objCopy = JSON.parse(JSON.stringify(obj));</span><br><span class="line">    console.log(&apos;obj&apos;, obj);</span><br><span class="line">    console.log(&apos;objCopy&apos;, objCopy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/images/JSON_6.png" alt></p><h2 id="再谈谈-JSON-stringify-的性能"><a href="#再谈谈-JSON-stringify-的性能" class="headerlink" title="再谈谈 JSON.stringify 的性能"></a>再谈谈 JSON.stringify 的性能</h2><p>在 hobber 框架里，打日志的时候，用了一个库，叫 flatted，在进行对象序列化的时候，用的这个库中的 stringify，flatted 序列化后的对象，是平铺的，key 值后面跟了一个序号，比如我有个对象：{ name: ‘ljh’, age: 18 }，其序列化之后长这样：[{“name”:”1”,”age”:18},”ljh”]，如果不知道的人就很懵逼，我要的结果是这样的呀：’{“name”:”ljh”,”age”:18}’。<br>其实当时的我也很懵逼，随手就想把序列化的方法改成 JSON.stringify。但是有个问题，就是 JSON.stringify 的性能。如果一条日志很大的时候，JSON.stringify 的性能堪忧。我们这里谈谈 JSON.stringify 的性能。</p><p>这里我写了一个统计解析时间的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">// 构造一个大对象</span><br><span class="line">const fs = require(&apos;fs&apos;);</span><br><span class="line">const &#123; stringify &#125; = require(&apos;flatted/cjs&apos;);</span><br><span class="line">const fastJson = require(&apos;fast-json-stringify&apos;);</span><br><span class="line">const stringify_fast = fastJson(&#123;</span><br><span class="line">  title: &apos;Example Schema&apos;,</span><br><span class="line">  type: &apos;object&apos;,</span><br><span class="line">  patternProperties: &#123;</span><br><span class="line">    &apos;^pro.*&apos;: &#123;</span><br><span class="line">      type: &apos;object&apos;,</span><br><span class="line">      patternProperties: &#123;</span><br><span class="line">        &apos;^person.*&apos;: &#123;</span><br><span class="line">          type: &apos;object&apos;,</span><br><span class="line">          patternProperties: &#123;</span><br><span class="line">            &apos;^name.*&apos;: &#123;</span><br><span class="line">              type: &apos;string&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            &apos;^age.*&apos;: &#123;</span><br><span class="line">              type: &apos;number&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            &apos;^sex.*&apos;: &#123;</span><br><span class="line">              type: &apos;string&apos;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &apos;^an.*&apos;: &#123;</span><br><span class="line">          type: &apos;object&apos;,</span><br><span class="line">          patternProperties: &#123;</span><br><span class="line">            &apos;^name.*&apos;: &#123;</span><br><span class="line">              type: &apos;string&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            &apos;^age.*&apos;: &#123;</span><br><span class="line">              type: &apos;number&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            &apos;^sex.*&apos;: &#123;</span><br><span class="line">              type: &apos;string&apos;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">function createBigObj(num) &#123;</span><br><span class="line">  let obj = &#123;&#125;;</span><br><span class="line">  for (let i = 0; i &lt; num; i++) &#123;</span><br><span class="line">    let key = `pro$&#123;i&#125;`;</span><br><span class="line">    obj[key] = &#123;</span><br><span class="line">      [`person$&#123;i&#125;`]: &#123;</span><br><span class="line">        [`name$&#123;i&#125;`]: `name$&#123;i&#125;`,</span><br><span class="line">        [`age$&#123;i&#125;`]: i,</span><br><span class="line">        [`sex$&#123;i&#125;`]: `sex$&#123;i&#125;`</span><br><span class="line">        // [`unknown$&#123;i&#125;`]: function() &#123;&#125;,</span><br><span class="line">        // [`unknown1$&#123;i&#125;`]: undefined,</span><br><span class="line">        // [`unknown2$&#123;i&#125;`]: NaN</span><br><span class="line">      &#125;,</span><br><span class="line">      [`an$&#123;i&#125;`]: &#123;</span><br><span class="line">        [`name$&#123;i&#125;`]: `name$&#123;i&#125;`,</span><br><span class="line">        [`age$&#123;i&#125;`]: `$&#123;i + 100&#125;`,</span><br><span class="line">        [`sex$&#123;i&#125;`]: `sex$&#123;i&#125;`</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;</span><br><span class="line">let newObj = createBigObj(10000);</span><br><span class="line"></span><br><span class="line">function calTime(obj) &#123;</span><br><span class="line">  let oldTime = new Date().getTime();</span><br><span class="line">  console.log(oldTime);</span><br><span class="line">  //let work = JSON.stringify(obj);</span><br><span class="line">  //let work = stringify(obj);</span><br><span class="line"></span><br><span class="line">  let work = stringify_fast(obj);</span><br><span class="line">  fs.writeFile(&apos;testfiles.txt&apos;, work, function() &#123;</span><br><span class="line">    console.log(&apos;finish&apos;);</span><br><span class="line">    console.log(&apos;写文件时间：&apos;, new Date().getTime() - oldTime, &apos;ms&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line">  let nowTime = new Date().getTime();</span><br><span class="line">  console.log(nowTime);</span><br><span class="line">  console.log(&apos;stringify计算时间&apos;, nowTime - oldTime, &apos;ms&apos;);</span><br><span class="line">&#125;</span><br><span class="line">calTime(newObj);</span><br></pre></td></tr></table></figure><p>循环 10000 次构造的大对象，对比如下：<br>原生的 JSON.stringify</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1587026878274</span><br><span class="line">1587026878288</span><br><span class="line">stringify计算时间 14 ms</span><br><span class="line">finish</span><br><span class="line">写文件时间： 25 ms</span><br></pre></td></tr></table></figure><p>flatted/cjs stringify</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1587026906069</span><br><span class="line">1587026906341</span><br><span class="line">stringify计算时间 272 ms</span><br><span class="line">finish</span><br><span class="line">写文件时间： 286 ms</span><br></pre></td></tr></table></figure><p>fast-json-stringify</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1587026945311</span><br><span class="line">1587026945523</span><br><span class="line">stringify计算时间 212 ms</span><br><span class="line">finish</span><br><span class="line">写文件时间： 242 ms</span><br></pre></td></tr></table></figure><p>使用命令看一下 testfiles.txt 文件大小：du -sh testfiles.txt</p><p>JSON.stringify 和 fast-json-stringify 生成的文件 1.4M，flatted/cjs stringify 生成的文件 1.9M，所以看统计结果原生的最快呀？？？什么情况下 fast-json-stringify 和 flatted/cjs 会比原生的 JSON.stringify 更快呢？？</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;先谈谈深拷贝的局限&quot;&gt;&lt;a href=&quot;#先谈谈深拷贝的局限&quot; class=&quot;headerlink&quot; title=&quot;先谈谈深拷贝的局限&quot;&gt;&lt;/a&gt;先谈谈深拷贝的局限&lt;/h2&gt;&lt;p&gt;有些文章介绍深拷贝的方法，说 JSON.parse(JSON.stringify(obj))可以进行深拷贝。其实这种深拷贝方法有很多局限：&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://skhon.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://skhon.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>整理一下正则</title>
    <link href="https://skhon.github.io/2020/03/21/regexp/"/>
    <id>https://skhon.github.io/2020/03/21/regexp/</id>
    <published>2020-03-21T00:00:00.000Z</published>
    <updated>2020-04-16T08:54:00.466Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字面量字符和元字符"><a href="#字面量字符和元字符" class="headerlink" title="字面量字符和元字符"></a>字面量字符和元字符</h2><p><code>字面量字符</code>： 写的啥就匹配啥。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dog/.test(&apos;old dog&apos;) // true</span><br></pre></td></tr></table></figure></p><p><code>点字符(.)</code>：匹配一个除回车（\r）、换行(\n) 、行分隔符（\u2028）和段分隔符（\u2029）以外的所有字符<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/c.t/.test(&apos;cst&apos;) // true</span><br><span class="line">/c.t/.test(&apos;c\nt&apos;) // false</span><br></pre></td></tr></table></figure></p><p><code>位置字符(^ 和 $)</code>：^ 表示字符串的开始位置，$ 表示字符串的结束位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/^test/.test(&apos;test123&apos;) // true</span><br><span class="line">/test$/.test(&apos;new test&apos;) // true</span><br><span class="line">/^test$/.test(&apos;test&apos;) // true</span><br><span class="line">/^test$/.test(&apos;test test&apos;) // false</span><br></pre></td></tr></table></figure></p><p><code>选择符（|）</code>:表示“或关系”（OR），即cat|dog表示匹配cat或dog。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 正则表达式指定必须匹配11或22。</span><br><span class="line">/11|22/.test(&apos;911&apos;) // true</span><br><span class="line"></span><br><span class="line">/a(1|2)b/.test(&apos;a1b&apos;) // true</span><br></pre></td></tr></table></figure></p><h2 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h2><p>需要反斜杠转义的，一共有12个字符：^、.、[、$、(、)、|、*、+、?、{和\。需要特别注意的是，如果使用RegExp方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。</p><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><p>\cX     表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符。<br>[\b]    匹配退格键(U+0008)，不要与\b混淆。<br>\n      匹配换行键。<br>\r      匹配回车键。<br>\t      匹配制表符 tab（U+0009）。<br>\v      匹配垂直制表符（U+000B）。<br>\f      匹配换页符（U+000C）。<br>\0      匹配null字符（U+0000）。<br>\xhh    匹配一个以两位十六进制数（\x00-\xFF）表示的字符。<br>\uhhhh  匹配一个以四位十六进制数（\u0000-\uFFFF）表示的 Unicode 字符。</p><h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类 []"></a>字符类 []</h2><p>字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[xyz] 表示x、y、z之中任选一个匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/[abc]/.test(&apos;hello world&apos;) // false </span><br><span class="line">/[abc]/.test(&apos;apple&apos;) // true</span><br></pre></td></tr></table></figure><h3 id="脱字符"><a href="#脱字符" class="headerlink" title="脱字符 ^"></a>脱字符 ^</h3><p>如果方括号内的第一个字符是[^]，则表示除了字符类之中的字符，其他字符都可以匹配。比如，[^xyz]表示除了x、y、z之外都可以匹配。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/[^abc]/.test(&apos;hello world&apos;) // true</span><br><span class="line">/[^abc]/.test(&apos;bbc&apos;) // false</span><br></pre></td></tr></table></figure></p><p>如果方括号内没有其他字符，即只有[^]，就表示匹配一切字符，其中包括换行符。相比之下，点号作为元字符（.）是不包括换行符的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;Please yes\nmake my day!&apos;;</span><br><span class="line"></span><br><span class="line">s.match(/yes.*day/) // null</span><br><span class="line">s.match(/yes[^]*day/) // [ &apos;yes\nmake my day&apos;]</span><br></pre></td></tr></table></figure></p><blockquote><p>在[]中，^只有在第一位才标示非，否则就是字面量<br>在[]中，.就是字面量</p></blockquote><h3 id="连字符"><a href="#连字符" class="headerlink" title="连字符 -"></a>连字符 -</h3><p>某些情况下，对于连续序列的字符，连字符（-）用来提供简写形式，表示字符的连续范围。比如，[abc]可以写成[a-c]，[0123456789]可以写成[0-9]，同理[A-Z]表示26个大写字母。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/a-z/.test(&apos;b&apos;) // false</span><br><span class="line">/[a-z]/.test(&apos;b&apos;) // true</span><br></pre></td></tr></table></figure></p><h2 id="预定义模式"><a href="#预定义模式" class="headerlink" title="预定义模式"></a>预定义模式</h2><p>\d 匹配0-9之间的任一数字，相当于[0-9]。<br>\D 匹配所有0-9以外的字符，相当于[^0-9]。<br>\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。<br>\W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。<br>\s 匹配空格（包括换行符、制表符、空格符等），相等于[ \t\r\n\v\f]。<br>\S 匹配非空格的字符，相当于[^ \t\r\n\v\f]。<br>\b 匹配词的边界。<br>\B 匹配非词边界，即在词的内部。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// \s 的例子</span><br><span class="line">/\s\w*/.exec(&apos;hello world&apos;) // [&quot; world&quot;]</span><br><span class="line"></span><br><span class="line">// \b 的例子</span><br><span class="line">/\bworld/.test(&apos;hello world&apos;) // true</span><br><span class="line">/\bworld/.test(&apos;hello-world&apos;) // true</span><br><span class="line">/\bworld/.test(&apos;helloworld&apos;) // false</span><br><span class="line"></span><br><span class="line">// \B 的例子</span><br><span class="line">/\Bworld/.test(&apos;hello-world&apos;) // false</span><br><span class="line">/\Bworld/.test(&apos;helloworld&apos;) // true</span><br></pre></td></tr></table></figure><h2 id="重复类"><a href="#重复类" class="headerlink" title="重复类 {}"></a>重复类 {}</h2><p>模式的精确匹配次数，使用大括号（{}）表示。{n}表示恰好重复n次，{n,}表示至少重复n次，{n,m}表示重复不少于n次，不多于m次。</p><h3 id="量词符"><a href="#量词符" class="headerlink" title="量词符"></a>量词符</h3><p>? 问号表示某个模式出现0次或1次，等同于{0, 1}。<br>* 星号表示某个模式出现0次或多次，等同于{0,}。<br>+ 加号表示某个模式出现1次或多次，等同于{1,}。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// t 出现0次或1次</span><br><span class="line">/t?est/.test(&apos;test&apos;) // true</span><br><span class="line">/t?est/.test(&apos;est&apos;) // true</span><br><span class="line"></span><br><span class="line">// t 出现1次或多次</span><br><span class="line">/t+est/.test(&apos;test&apos;) // true</span><br><span class="line">/t+est/.test(&apos;ttest&apos;) // true</span><br><span class="line">/t+est/.test(&apos;est&apos;) // false</span><br><span class="line"></span><br><span class="line">// t 出现0次或多次</span><br><span class="line">/t*est/.test(&apos;test&apos;) // true</span><br><span class="line">/t*est/.test(&apos;ttest&apos;) // true</span><br><span class="line">/t*est/.test(&apos;tttest&apos;) // true</span><br><span class="line">/t*est/.test(&apos;est&apos;) // true</span><br></pre></td></tr></table></figure><h2 id="贪婪模式"><a href="#贪婪模式" class="headerlink" title="贪婪模式"></a>贪婪模式</h2><p>上一小节的三个量词符，默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;aaa&apos;;</span><br><span class="line">s.match(/a+/) // [&quot;aaa&quot;]</span><br></pre></td></tr></table></figure></p><p>上面代码中，模式是/a+/，表示匹配1个a或多个a，那么到底会匹配几个a呢？因为默认是贪婪模式，会一直匹配到字符a不出现为止，所以匹配结果是3个a。</p><p>如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;aaa&apos;;</span><br><span class="line">s.match(/a+?/) // [&quot;a&quot;]</span><br></pre></td></tr></table></figure></p><blockquote><p>*?：表示某个模式出现0次或多次，匹配时采用非贪婪模式。<br>+?：表示某个模式出现1次或多次，匹配时采用非贪婪模式。</p></blockquote><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><h3 id="g修饰符"><a href="#g修饰符" class="headerlink" title="g修饰符"></a>g修饰符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var regex = /b/;</span><br><span class="line">var str = &apos;abba&apos;;</span><br><span class="line"></span><br><span class="line">regex.test(str); // true</span><br><span class="line">regex.test(str); // true</span><br><span class="line">regex.test(str); // true</span><br></pre></td></tr></table></figure><p>上面代码中，正则模式不含g修饰符，每次都是从字符串头部开始匹配。所以，连续做了三次匹配，都返回true。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var regex = /b/g;</span><br><span class="line">var str = &apos;abba&apos;;</span><br><span class="line"></span><br><span class="line">regex.test(str); // true</span><br><span class="line">regex.test(str); // true</span><br><span class="line">regex.test(str); // false</span><br></pre></td></tr></table></figure><p>上面代码中，正则模式含有g修饰符，每次都是从上一次匹配成功处，开始向后匹配。因为字符串abba只有两个b，所以前两次匹配结果为true，第三次匹配结果为false。</p><h3 id="i-修饰符"><a href="#i-修饰符" class="headerlink" title="i 修饰符"></a>i 修饰符</h3><p>默认情况下，正则对象区分字母的大小写，加上i修饰符以后表示忽略大小写（ignorecase）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/abc/.test(&apos;ABC&apos;) // false</span><br><span class="line">/abc/i.test(&apos;ABC&apos;) // true</span><br></pre></td></tr></table></figure></p><h3 id="m-修饰符"><a href="#m-修饰符" class="headerlink" title="m 修饰符"></a>m 修饰符</h3><p>m修饰符表示多行模式（multiline），会修改^和$的行为。默认情况下（即不加m修饰符时），^和$匹配字符串的开始处和结尾处，加上m修饰符以后，^和$还会匹配行首和行尾，即^和$会识别换行符（\n）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/world$/.test(&apos;hello world\n&apos;) // false</span><br><span class="line">/world$/m.test(&apos;hello world\n&apos;) // true</span><br></pre></td></tr></table></figure></p><h2 id="组匹配"><a href="#组匹配" class="headerlink" title="组匹配 ()"></a>组匹配 ()</h2><p>括号有两个功能，分别是分组和引用</p><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>量词控制之前元素的出现次数，而这个元素可能是一个字符，也可能是一个字符组，也可以是一个表达式</p><p>如果把一个表达式用括号包围起来，这个元素就是括号里的表达式，被称为子表达式</p><p>如果希望字符串’ab’重复出现2次，应该写为(ab){2}，而如果写为ab{2}，则{2}只限定b<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(/(ab)&#123;2&#125;/.test(&apos;abab&apos;)); //true</span><br><span class="line">console.log(/(ab)&#123;2&#125;/.test(&apos;abb&apos;)); //false</span><br><span class="line">console.log(/ab&#123;2&#125;/.test(&apos;abab&apos;)); //false</span><br><span class="line">console.log(/ab&#123;2&#125;/.test(&apos;abb&apos;)); //true</span><br></pre></td></tr></table></figure></p><h3 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h3><p>括号不仅可以对元素进行分组，还会保存每个分组匹配的文本，等到匹配完成后，引用捕获的内容。因为捕获了文本，这种功能叫捕获分组<br>比如，要匹配诸如2016-06-23这样的日期字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span><br><span class="line"></span><br><span class="line">console.log(/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/.test(&apos;2016-06-23&apos;));//true</span><br><span class="line">console.log(RegExp.$1);//&apos;2016&apos;</span><br><span class="line">console.log(RegExp.$2);//&apos;06&apos;</span><br><span class="line">console.log(RegExp.$3);//&apos;23&apos;</span><br><span class="line">console.log(RegExp.$4);//&apos;&apos;</span><br></pre></td></tr></table></figure></p><h3 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h3><p>反向引用允许在正则表达式内部引用之前捕获分组匹配的文本，形式是\num，num表示所引用分组的编号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//重复字母</span><br><span class="line">/([a-z])\1/</span><br><span class="line">console.log(/([a-z])\1/.test(&apos;aa&apos;));//true</span><br><span class="line">console.log(/([a-z])\1/.test(&apos;ab&apos;));//false</span><br></pre></td></tr></table></figure></p><h3 id="非捕获"><a href="#非捕获" class="headerlink" title="非捕获"></a>非捕获</h3><p>除了捕获分组，正则表达式还提供了非捕获分组(non-capturing group)，以(?:)的形式表示，它只用于限定作用范围，而不捕获任何文本<br>比如，要匹配abcabc这个字符，一般地，可以写为(abc){2}，但由于并不需要捕获文本，只是限定了量词的作用范围，所以应该写为(?:abc){2}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(/(abc)&#123;2&#125;/.test(&apos;abcabc&apos;));//true</span><br><span class="line">console.log(/(?:abc)&#123;2&#125;/.test(&apos;abcabc&apos;));//true</span><br></pre></td></tr></table></figure></p><p>由于非捕获分组不捕获文本，对应地，也就没有捕获组编号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(/(abc)&#123;2&#125;/.test(&apos;abcabc&apos;));//true</span><br><span class="line">console.log(RegExp.$1);//&apos;abc&apos;</span><br><span class="line">console.log(/(?:abc)&#123;2&#125;/.test(&apos;abcabc&apos;));//true</span><br><span class="line">console.log(RegExp.$1);//&apos;&apos;</span><br></pre></td></tr></table></figure></p><p>非捕获分组也不可以使用反向引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/(?:123)\1/.test(&apos;123123&apos;);//false</span><br><span class="line">/(123)\1/.test(&apos;123123&apos;);//true</span><br></pre></td></tr></table></figure></p><p>捕获分组和非捕获分组可以在一个正则表达式中同时出现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(/(\d)(\d)(?:\d)(\d)(\d)/.exec(&apos;12345&apos;));//[&quot;12345&quot;, &quot;1&quot;, &quot;2&quot;, &quot;4&quot;, &quot;5&quot;]</span><br></pre></td></tr></table></figure></p><h3 id="先行断言"><a href="#先行断言" class="headerlink" title="先行断言"></a>先行断言</h3><p>x(?=y)称为先行断言（Positive look-ahead），x只有在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成/\d+(?=%)/。“先行断言”中，括号里的部分是不会返回的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var m = &apos;abc&apos;.match(/b(?=c)/);</span><br><span class="line">m // [&quot;b&quot;]</span><br></pre></td></tr></table></figure></p><h3 id="先行否定断言"><a href="#先行否定断言" class="headerlink" title="先行否定断言"></a>先行否定断言</h3><p>x(?!y)称为先行否定断言（Negative look-ahead），x只有不在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成/\d+(?!%)/。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/\d+(?!\.)/.exec(&apos;3.14&apos;)</span><br><span class="line">// [&quot;14&quot;]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;字面量字符和元字符&quot;&gt;&lt;a href=&quot;#字面量字符和元字符&quot; class=&quot;headerlink&quot; title=&quot;字面量字符和元字符&quot;&gt;&lt;/a&gt;字面量字符和元字符&lt;/h2&gt;&lt;p&gt;&lt;code&gt;字面量字符&lt;/code&gt;： 写的啥就匹配啥。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dog/.test(&amp;apos;old dog&amp;apos;) // true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;点字符(.)&lt;/code&gt;：匹配一个除回车（\r）、换行(\n) 、行分隔符（\u2028）和段分隔符（\u2029）以外的所有字符&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="https://skhon.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://skhon.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>整理一下hobber</title>
    <link href="https://skhon.github.io/2020/03/04/hobber/"/>
    <id>https://skhon.github.io/2020/03/04/hobber/</id>
    <published>2020-03-04T00:00:00.000Z</published>
    <updated>2020-04-16T08:54:00.466Z</updated>
    
    <content type="html"><![CDATA[<h2 id="path的几个api用法"><a href="#path的几个api用法" class="headerlink" title="path的几个api用法"></a>path的几个api用法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">console.log(`__dirname ==&gt; $&#123;__dirname&#125;`)</span><br><span class="line">console.log(`path.basename ==&gt; $&#123;path.basename(__dirname)&#125;`)</span><br><span class="line">console.log(`path.delimiter ==&gt; $&#123;path.delimiter&#125;`)</span><br><span class="line">console.log(`path.dirname ==&gt; $&#123;path.dirname(__dirname)&#125;`)</span><br><span class="line">console.log(`path.extname ==&gt; $&#123;path.extname(&apos;/user/test/index.jsx&apos;)&#125;`)</span><br><span class="line"></span><br><span class="line">// path.join([...paths]) 连接片段，并生成规范化路径</span><br><span class="line">console.log(`path.join() ==&gt; $&#123;path.join(&apos;/base&apos;,&apos;test&apos;,&apos;ce&apos;,&apos;../&apos;)&#125;`)</span><br><span class="line"></span><br><span class="line">// path.relative(from, to) 生成相对路径</span><br><span class="line">console.log(`path.relative() ==&gt; $&#123;path.relative(&apos;/root/test/ce&apos;,&apos;/root&apos;)&#125;`)</span><br><span class="line"></span><br><span class="line">// path.resolve([...paths]) 给定的路径序列从右到左进行处理，每个后续的 path 前置，直到构造出一个绝对路径</span><br><span class="line">console.log(`path.resolve() ==&gt; $&#123;path.resolve()&#125;`)</span><br><span class="line">console.log(`path.resolve() ==&gt; $&#123;path.resolve(&apos;baidu&apos;,&apos;home&apos;)&#125;`)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">输出：</span><br><span class="line">__dirname ==&gt; /Users/lianjia/Desktop/my notes/node/test</span><br><span class="line">path.basename ==&gt; test</span><br><span class="line">path.delimiter ==&gt; :</span><br><span class="line">path.dirname ==&gt; /Users/lianjia/Desktop/my notes/node</span><br><span class="line">path.extname ==&gt; .jsx</span><br><span class="line">path.join() ==&gt; /base/test/</span><br><span class="line">path.relative() ==&gt; ../..</span><br><span class="line">path.resolve() ==&gt; /Users/lianjia/Desktop/my notes/node/test</span><br><span class="line">path.resolve() ==&gt; /Users/lianjia/Desktop/my notes/node/test/baidu/home</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;path的几个api用法&quot;&gt;&lt;a href=&quot;#path的几个api用法&quot; class=&quot;headerlink&quot; title=&quot;path的几个api用法&quot;&gt;&lt;/a&gt;path的几个api用法&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="前端" scheme="https://skhon.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="node" scheme="https://skhon.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Errors and Stack Traces</title>
    <link href="https://skhon.github.io/2020/02/26/js-stack-trace/"/>
    <id>https://skhon.github.io/2020/02/26/js-stack-trace/</id>
    <published>2020-02-26T00:00:00.000Z</published>
    <updated>2020-02-26T03:54:50.640Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>今天将讨论错误和堆栈跟踪以及如何处理它们。</p><p>有时人们不会关注这些细节，但是，如果您正在编写与测试或错误相关的任何库，那么这些知识无疑会很有用。<a id="more"></a> 例如，本周在 Chai，我们有一个很棒的 Pull Request，它极大地改善了我们处理堆栈跟踪的方式，以便用户在断言失败时获得更多信息。</p><p>通过操作堆栈跟踪，您可以清理无用的数据并集中精力处理重要的事情。 同样，在了解错误的确切含义及其属性后，您会更加自信地利用它。</p><p>这篇博客文章在开始时似乎太明显了，但是当我们开始操作堆栈跟踪时，它变得非常复杂，因此在移至该部分之前，请确保您对以前的内容有充分的了解。</p><h2 id="调用堆栈如何工作"><a href="#调用堆栈如何工作" class="headerlink" title="调用堆栈如何工作"></a>调用堆栈如何工作</h2><p>在讨论错误之前，我们必须了解调用堆栈的工作方式。 这确实很简单，但是在继续之前必须知道这一点。 如果您已经知道这一点，请随时跳过此部分。</p><p>每当有一个函数调用时，它就会被推到栈顶。 完成运行后，将其从堆栈顶部移除。</p><p>关于此数据结构的有趣之处在于，最后输入的将是第一个输出的数据。 这称为 LIFO（后进先出）属性。</p><p>这意味着，例如，当从函数 x 内部调用函数 y 时，我们将具有依次包含 x 和 y 的堆栈。</p><p>让我再举一个例子，假设您有以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"c"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"b"</span>);</span><br><span class="line">  c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"a"</span>);</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>在上面的示例中，当运行 a 时，它将被添加到我们堆栈的顶部。 然后，当 b 从 a 内部被调用时，它被推入堆栈的顶部。 从 b 调用 c 时，也是如此。</p><p>运行 c 时，我们的堆栈跟踪将按此顺序包含 a，b 和 c。</p><p>一旦 c 完成运行，它就会从堆栈顶部移走，然后控制流回到 b。 当 b 完成时，它也将从堆栈中删除，现在我们将控件放回 a。 最后，当完成运行时，它也会从堆栈中删除。</p><p>为了更好地演示此行为，我们将使用 console.trace（），它将当前的堆栈跟踪信息打印到控制台。 同样，您通常应该从上至下读取堆栈跟踪。 将每行视为从其下一行内部调用的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"c"</span>);</span><br><span class="line">  <span class="built_in">console</span>.trace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"b"</span>);</span><br><span class="line">  c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"a"</span>);</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>在 Node REPL 服务器中运行此命令时，我们会得到以下信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Trace</span><br><span class="line">    at c (repl:<span class="number">3</span>:<span class="number">9</span>)</span><br><span class="line">    at b (repl:<span class="number">3</span>:<span class="number">1</span>)</span><br><span class="line">    at a (repl:<span class="number">3</span>:<span class="number">1</span>)</span><br><span class="line">    at repl:<span class="number">1</span>:<span class="number">1</span> <span class="comment">// &lt;-- For now feel free to ignore anything below this point, these are Node's internals</span></span><br><span class="line">    at realRunInThisContextScript (vm.js:<span class="number">22</span>:<span class="number">35</span>)</span><br><span class="line">    at sigintHandlersWrap (vm.js:<span class="number">98</span>:<span class="number">12</span>)</span><br><span class="line">    at ContextifyScript.Script.runInThisContext (vm.js:<span class="number">24</span>:<span class="number">12</span>)</span><br><span class="line">    at REPLServer.defaultEval (repl.js:<span class="number">313</span>:<span class="number">29</span>)</span><br><span class="line">    at bound (domain.js:<span class="number">280</span>:<span class="number">14</span>)</span><br><span class="line">    at REPLServer.runBound [<span class="keyword">as</span> <span class="built_in">eval</span>] (domain.js:<span class="number">293</span>:<span class="number">12</span>)</span><br></pre></td></tr></table></figure><p>正如我们在这里看到的，当从 c 内部打印堆栈时，我们有 a，b 和 c。</p><p>现在，如果在 c 完成运行之后从 b 内部打印堆栈跟踪，我们将能够看到它已从堆栈顶部删除，因此我们只有 a 和 b。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"c"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"b"</span>);</span><br><span class="line">  c();</span><br><span class="line">  <span class="built_in">console</span>.trace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"a"</span>);</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>如您所见，我们的堆栈中不再有 c，因为它已经完成运行并已弹出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Trace</span><br><span class="line">    at b (repl:<span class="number">4</span>:<span class="number">9</span>)</span><br><span class="line">    at a (repl:<span class="number">3</span>:<span class="number">1</span>)</span><br><span class="line">    at repl:<span class="number">1</span>:<span class="number">1</span>  <span class="comment">// &lt;-- For now feel free to ignore anything below this point, these are Node's internals</span></span><br><span class="line">    at realRunInThisContextScript (vm.js:<span class="number">22</span>:<span class="number">35</span>)</span><br><span class="line">    at sigintHandlersWrap (vm.js:<span class="number">98</span>:<span class="number">12</span>)</span><br><span class="line">    at ContextifyScript.Script.runInThisContext (vm.js:<span class="number">24</span>:<span class="number">12</span>)</span><br><span class="line">    at REPLServer.defaultEval (repl.js:<span class="number">313</span>:<span class="number">29</span>)</span><br><span class="line">    at bound (domain.js:<span class="number">280</span>:<span class="number">14</span>)</span><br><span class="line">    at REPLServer.runBound [<span class="keyword">as</span> <span class="built_in">eval</span>] (domain.js:<span class="number">293</span>:<span class="number">12</span>)</span><br><span class="line">    at REPLServer.onLine (repl.js:<span class="number">513</span>:<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>简而言之：您调用事物，它们就会被推到栈顶。 当他们完成运行时，它们会弹出。 就那么简单。</p><h2 id="错误对象和错误处理"><a href="#错误对象和错误处理" class="headerlink" title="错误对象和错误处理"></a>错误对象和错误处理</h2><p>当发生错误时，通常会抛出一个 Error 对象。 错误对象也可以用作想要扩展它并创建自己的错误的用户的原型。</p><p>Error.prototype 对象通常具有以下属性：</p><ul><li>constructor - The constructor function responsible for this instance’s prototype.</li><li>message - An error message.</li><li>name - The error’s name.</li></ul><p>这些是标准属性，有时每个环境都有其自己的特定属性。 在某些环境中，例如 Node，Firefox，Chrome，Edge，IE 10 +，Opera 和 Safari 6+，我们甚至拥有 stack 属性，其中包含错误的堆栈跟踪。 错误的堆栈跟踪包含所有堆栈帧，直到其自己的构造函数为止。</p><p>如果您想阅读有关 Error 对象的特定属性的更多信息，我强烈建议您阅读有关 MDN 的文章。</p><p>要抛出错误，必须使用 throw 关键字。 为了捕获引发的错误，必须将可能引发错误的代码包装到 try 块中，然后再放入 catch 块。 Catch 还接受一个参数，即抛出的错误。</p><p>正如 Java 中所发生的那样，JavaScript 还允许您在 try / catch 块之后运行一个 finally 块，而不管您的 try 块是否抛出错误。 处理完毕后，最好使用最后清理的东西，无论您的操作是否有效。</p><p>到目前为止，对于大多数人来说，一切都是显而易见的，所以让我们来谈谈一些不重要的细节。</p><p>您可以使用 try 块，但不要在 catch 后面，但是必须在它们后面紧跟着。 这意味着我们可以使用三种不同形式的 try 语句：</p><ul><li>try…catch</li><li>try…finally</li><li>try…catch…finally</li></ul><p>try 语句可以嵌套在其他 try 语句中，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Nested error."</span>); <span class="comment">// The error thrown here will be caught by its own `catch` clause</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (nestedErr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Nested catch"</span>); <span class="comment">// This runs</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"This will not run."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您还可以将 try 语句嵌套到 catch 和 finally 块中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"First error"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"First catch running"</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Second error"</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (nestedErr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Second catch running."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"The try block is running..."</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Error inside finally."</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Caught an error inside the finally block."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请务必注意，您还可以抛出不是 Error 对象的值，这一点也很重要。 尽管这看起来很酷，但实际上并没有那么好，尤其是对于那些使用必须处理其他人的代码的库的开发人员而言，因为那时没有标准，而且您永远都不知道用户会期望什么。 您不能仅仅因为它们选择不这样做而仅仅抛出一个字符串或一个数字就相信它们会引发 Error 对象。 如果您需要处理堆栈跟踪和其他有意义的元数据，这也将变得更加困难。</p><p>假设您有以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runWithoutThrowing</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    func();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"There was an error, but I will not throw it."</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"The error's message was: "</span> + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcThatThrowsError</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"I am a TypeError."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runWithoutThrowing(funcThatThrowsError);</span><br></pre></td></tr></table></figure><p>如果您的用户正在传递将 Error 对象抛出到您的 runWithoutThrowing 函数的函数，这将非常有用。 但是，如果它们最终抛出一个 String，那么您可能会遇到麻烦：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runWithoutThrowing</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    func();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"There was an error, but I will not throw it."</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"The error's message was: "</span> + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcThatThrowsString</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">"I am a String."</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runWithoutThrowing(funcThatThrowsString);</span><br></pre></td></tr></table></figure><p>现在，您的第二个 console.log 将显示错误消息未定义。 现在这似乎并不重要，但是如果您需要确保某个 Error 对象上存在某些属性或以另一种方式处理特定于 Error 的属性（例如 Chai 的 throws 断言确实需要），则您需要做更多的工作来确保它可以工作 对。</p><p>另外，当抛出不是 Error 对象的值时，您将无权访问其他重要数据，例如堆栈，这是 Error 对象在某些环境中具有的属性。</p><p>错误也可以用作任何其他对象，您不一定需要将其引发，这就是为什么它们多次被用作回调函数的第一个参数的原因，例如 fs.readdir 函数就是这种情况。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line">fs.readdir(<span class="string">"/example/i-do-not-exist"</span>, <span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">err, dirs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err <span class="keyword">instanceof</span> <span class="built_in">Error</span>) &#123;</span><br><span class="line">    <span class="comment">// `readdir` will throw an error because that directory does not exist</span></span><br><span class="line">    <span class="comment">// We will now be able to use the error object passed by it in our callback function</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Error Message: "</span> + err.message);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"See? We can use Errors without using try statements."</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(dirs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最后但并非最不重要的一点是，在拒绝承诺时也可以使用 Error 对象。 这使得处理承诺拒绝更容易：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"The promise was rejected."</span>));</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"I am an error."</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err <span class="keyword">instanceof</span> <span class="built_in">Error</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"The promise was rejected with an error."</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"Error Message: "</span> + err.message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h2 id="操纵堆栈跟踪"><a href="#操纵堆栈跟踪" class="headerlink" title="操纵堆栈跟踪"></a>操纵堆栈跟踪</h2><p>现在，您一直在等待的部分：如何操作堆栈跟踪。</p><p>本章专门针对支持 Error.captureStackTrace 的环境（例如 NodeJS）。</p><p>Error.captureStackTrace 函数将一个对象作为第一个参数，并可选地将一个函数作为第二个参数。 捕获堆栈跟踪的作用是（显然）捕获当前堆栈跟踪，并在目标对象中创建一个堆栈属性来存储它。 如果提供了第二个参数，则传递的函数将被视为调用堆栈的终点，因此，堆栈跟踪将仅显示在调用此函数之前发生的调用。</p><p>让我们使用一些示例来更清楚地说明这一点。 首先，我们将捕获当前的堆栈跟踪并将其存储在一个公共对象中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Here we will store the current stack trace into myObj</span></span><br><span class="line">  <span class="built_in">Error</span>.captureStackTrace(myObj);</span><br><span class="line">  c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// First we will call these functions</span></span><br><span class="line">a();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now let's see what is the stack trace stored into myObj.stack</span></span><br><span class="line"><span class="built_in">console</span>.log(myObj.stack);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This will print the following stack to the console:</span></span><br><span class="line"><span class="comment">//    at b (repl:3:7) &lt;-- Since it was called inside B, the B call is the last entry in the stack</span></span><br><span class="line"><span class="comment">//    at a (repl:2:1)</span></span><br><span class="line"><span class="comment">//    at repl:1:1 &lt;-- Node internals below this line</span></span><br><span class="line"><span class="comment">//    at realRunInThisContextScript (vm.js:22:35)</span></span><br><span class="line"><span class="comment">//    at sigintHandlersWrap (vm.js:98:12)</span></span><br><span class="line"><span class="comment">//    at ContextifyScript.Script.runInThisContext (vm.js:24:12)</span></span><br><span class="line"><span class="comment">//    at REPLServer.defaultEval (repl.js:313:29)</span></span><br><span class="line"><span class="comment">//    at bound (domain.js:280:14)</span></span><br><span class="line"><span class="comment">//    at REPLServer.runBound [as eval] (domain.js:293:12)</span></span><br><span class="line"><span class="comment">//    at REPLServer.onLine (repl.js:513:10)</span></span><br></pre></td></tr></table></figure><p>您可以在上面的示例中注意到，我们首先调用 a（将其推入堆栈），然后从 a 内部调用 b（将其推入 a 顶部）。 然后，在 b 内部，我们捕获了当前的堆栈跟踪并将其存储到 myObj 中。 这就是为什么我们在打印到控制台的堆栈中只得到 a 然后再得到 b 的原因。</p><p>现在，将一个函数作为第二个参数传递给 Error.captureStackTrace 函数，看看会发生什么：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Here we will store the current stack trace into myObj</span></span><br><span class="line">  <span class="comment">// This time we will hide all the frames after `b` and `b` itself</span></span><br><span class="line">  <span class="built_in">Error</span>.captureStackTrace(myObj, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  d();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// First we will call these functions</span></span><br><span class="line">a();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now let's see what is the stack trace stored into myObj.stack</span></span><br><span class="line"><span class="built_in">console</span>.log(myObj.stack);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This will print the following stack to the console:</span></span><br><span class="line"><span class="comment">//    at a (repl:2:1) &lt;-- As you can see here we only get frames before `b` was called</span></span><br><span class="line"><span class="comment">//    at repl:1:1 &lt;-- Node internals below this line</span></span><br><span class="line"><span class="comment">//    at realRunInThisContextScript (vm.js:22:35)</span></span><br><span class="line"><span class="comment">//    at sigintHandlersWrap (vm.js:98:12)</span></span><br><span class="line"><span class="comment">//    at ContextifyScript.Script.runInThisContext (vm.js:24:12)</span></span><br><span class="line"><span class="comment">//    at REPLServer.defaultEval (repl.js:313:29)</span></span><br><span class="line"><span class="comment">//    at bound (domain.js:280:14)</span></span><br><span class="line"><span class="comment">//    at REPLServer.runBound [as eval] (domain.js:293:12)</span></span><br><span class="line"><span class="comment">//    at REPLServer.onLine (repl.js:513:10)</span></span><br><span class="line"><span class="comment">//    at emitOne (events.js:101:20)</span></span><br></pre></td></tr></table></figure><p>当我们将 b 传递给 Error.captureStackTraceFunction 时，它会将 b 自身及其上方的所有帧都隐藏起来。 这就是为什么我们在堆栈跟踪中仅包含一个的原因。</p><p>现在您可能会问自己：“为什么这样做有用？”。 这很有用，因为您可以使用它来隐藏与用户无关的内部实现细节。 例如，在 Chai 中，我们使用它来避免向用户显示与我们自己实现检查和断言的方式无关的细节。</p><h2 id="现实世界中的堆栈跟踪操作"><a href="#现实世界中的堆栈跟踪操作" class="headerlink" title="现实世界中的堆栈跟踪操作"></a>现实世界中的堆栈跟踪操作</h2><p>正如我在上一节中提到的，Chai 使用堆栈操纵技术使堆栈跟踪与我们的用户更加相关。 这是我们的方法。</p><p>首先，让我们看一下断言失败时抛出的 AssertionError 构造函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `ssfi` stands for "start stack function". It is the reference to the</span></span><br><span class="line"><span class="comment">// starting point for removing irrelevant frames from the stack trace</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AssertionError</span>(<span class="params">message, _props, ssf</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> extend = exclude(<span class="string">"name"</span>, <span class="string">"message"</span>, <span class="string">"stack"</span>, <span class="string">"constructor"</span>, <span class="string">"toJSON"</span>),</span><br><span class="line">    props = extend(_props || &#123;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Default values</span></span><br><span class="line">  <span class="keyword">this</span>.message = message || <span class="string">"Unspecified AssertionError"</span>;</span><br><span class="line">  <span class="keyword">this</span>.showDiff = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy from properties</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">    <span class="keyword">this</span>[key] = props[key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Here is what is relevant for us:</span></span><br><span class="line">  <span class="comment">// If a start stack function was provided we capture the current stack trace and pass</span></span><br><span class="line">  <span class="comment">// it to the `captureStackTrace` function so we can remove frames that come after it</span></span><br><span class="line">  ssf = ssf || <span class="built_in">arguments</span>.callee;</span><br><span class="line">  <span class="keyword">if</span> (ssf &amp;&amp; <span class="built_in">Error</span>.captureStackTrace) &#123;</span><br><span class="line">    <span class="built_in">Error</span>.captureStackTrace(<span class="keyword">this</span>, ssf);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// If no start stack function was provided we just use the original stack property</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">this</span>.stack = e.stack;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，我们使用 Error.captureStackTrace 捕获堆栈跟踪并将其存储到我们正在构建的 AssertionError 实例中（如果存在），我们将向其传递一个起始堆栈函数，以从中删除无关帧 堆栈跟踪，仅显示 Chai 的内部实现细节，最终使堆栈“变脏”。</p><p>现在，让我们看一下@meeber 在此出色的 PR 中编写的最新代码。</p><p>在查看下面的代码之前，我必须告诉您 addChainableMethod 的作用。 它将传递给它的可链接方法添加到断言中，并且还使用包装断言的方法标记断言本身。 它以名称 ssfi（代表启动堆栈功能指示器）存储。 这基本上意味着当前断言将是堆栈中的最后一帧，因此我们将在堆栈中不再显示 Chai 的其他内部方法。 我避免为此添加完整的代码，因为它可以完成很多事情并且有点棘手，但是如果您想阅读它，请转到此处的链接。</p><p>在下面的代码段中，我们具有 lengthOf 断言的逻辑，该逻辑检查对象是否具有特定长度。 我们希望我们的用户像这样使用它：expect([‘foo’，’bar’]).to.have.lengthOf(2)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assertLength</span>(<span class="params">n, msg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (msg) flag(<span class="keyword">this</span>, <span class="string">"message"</span>, msg);</span><br><span class="line">  <span class="keyword">var</span> obj = flag(<span class="keyword">this</span>, <span class="string">"object"</span>),</span><br><span class="line">    ssfi = flag(<span class="keyword">this</span>, <span class="string">"ssfi"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pay close attention to this line</span></span><br><span class="line">  <span class="keyword">new</span> Assertion(obj, msg, ssfi, <span class="literal">true</span>).to.have.property(<span class="string">"length"</span>);</span><br><span class="line">  <span class="keyword">var</span> len = obj.length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This line is also relevant</span></span><br><span class="line">  <span class="keyword">this</span>.assert(</span><br><span class="line">    len == n,</span><br><span class="line">    <span class="string">"expected #&#123;this&#125; to have a length of #&#123;exp&#125; but got #&#123;act&#125;"</span>,</span><br><span class="line">    <span class="string">"expected #&#123;this&#125; to not have a length of #&#123;act&#125;"</span>,</span><br><span class="line">    n,</span><br><span class="line">    len</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Assertion.addChainableMethod(<span class="string">"lengthOf"</span>, assertLength, assertLengthChain);</span><br></pre></td></tr></table></figure><p>在上面的代码中，我突出显示了当前与我们相关的行。 让我们从对 this.assert 的调用开始。</p><p>这是 this.assert 方法的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Assertion.prototype.assert = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  expr,</span></span></span><br><span class="line"><span class="function"><span class="params">  msg,</span></span></span><br><span class="line"><span class="function"><span class="params">  negateMsg,</span></span></span><br><span class="line"><span class="function"><span class="params">  expected,</span></span></span><br><span class="line"><span class="function"><span class="params">  _actual,</span></span></span><br><span class="line"><span class="function"><span class="params">  showDiff</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ok = util.test(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span> !== showDiff) showDiff = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">undefined</span> === expected &amp;&amp; <span class="literal">undefined</span> === _actual) showDiff = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span> !== config.showDiff) showDiff = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">    msg = util.getMessage(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">var</span> actual = util.getActual(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is the relevant line for us</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(</span><br><span class="line">      msg,</span><br><span class="line">      &#123;</span><br><span class="line">        actual: actual,</span><br><span class="line">        expected: expected,</span><br><span class="line">        showDiff: showDiff</span><br><span class="line">      &#125;,</span><br><span class="line">      config.includeStack ? <span class="keyword">this</span>.assert : flag(<span class="keyword">this</span>, <span class="string">"ssfi"</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>基本上，assert 方法负责检查 assert 布尔表达式是否通过。 如果没有，我们必须实例化一个 AssertionError。 请注意，在实例化此新的 AssertionError 时，我们还向其传递了堆栈跟踪功能指示器（ssfi）。 如果打开了配置标记 includeStack，我们通过将 this.assert 本身传递给用户，向用户显示整个堆栈跟踪，这实际上是堆栈中的最后一帧。 但是，如果关闭了 includeStack 配置标志，我们必须从堆栈跟踪中隐藏更多内部实现细节，因此我们将使用存储在 ssfi 标志中的内容。</p><p>现在，让我们谈谈与我们相关的另一条线：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Assertion(obj, msg, ssfi, <span class="literal">true</span>).to.have.property(<span class="string">"length"</span>);</span><br></pre></td></tr></table></figure><p>如您所见，在创建嵌套断言时，我们将传递从 ssfi 标志获得的内容。 这意味着在创建新的断言时，它将使用此函数作为从堆栈跟踪中删除无用帧的起点。 顺便说一下，这是 Assertion 构造函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Assertion</span>(<span class="params">obj, msg, ssfi, lockSsfi</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// This is the line that matters to us</span></span><br><span class="line">  flag(<span class="keyword">this</span>, <span class="string">"ssfi"</span>, ssfi || Assertion);</span><br><span class="line">  flag(<span class="keyword">this</span>, <span class="string">"lockSsfi"</span>, lockSsfi);</span><br><span class="line">  flag(<span class="keyword">this</span>, <span class="string">"object"</span>, obj);</span><br><span class="line">  flag(<span class="keyword">this</span>, <span class="string">"message"</span>, msg);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> util.proxify(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以从我对 addChainableMethod 的描述中记住，它使用自己的 wrapper 方法设置 ssfi 标志，这意味着这是堆栈跟踪中的最低内部框架，因此我们可以删除其上方的所有框架。</p><p>通过将 ssfi 传递给嵌套断言，该断言仅检查我们的对象是否具有属性长度，从而避免了重置框架（该框架将用作起点指示符），而使先前的 addChainableMethod 在堆栈中可见。</p><p>这看起来似乎有些复杂，所以让我们回顾一下 Chai 内部发生的情况，我们想从堆栈中删除无用的帧：</p><ul><li>当运行断言时，我们将其自己的方法设置为删除堆栈中下一帧的参考</li><li>断言运行，如果失败，我们将在存储引用后删除所有内部框架</li><li>如果我们嵌套了断言，则仍必须使用当前断言包装器方法作为删除堆栈中下一帧的参考点，因此我们将当前的 ssfi（启动栈功能指示器）传递给我们正在创建的断言，以便可以保留它</li></ul><p>我也强烈建议您阅读@meeber 的评论，以了解它。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;今天将讨论错误和堆栈跟踪以及如何处理它们。&lt;/p&gt;
&lt;p&gt;有时人们不会关注这些细节，但是，如果您正在编写与测试或错误相关的任何库，那么这些知识无疑会很有用。
    
    </summary>
    
      <category term="前端" scheme="https://skhon.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="node" scheme="https://skhon.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>jmeter压测</title>
    <link href="https://skhon.github.io/2020/02/25/jmeter-test/"/>
    <id>https://skhon.github.io/2020/02/25/jmeter-test/</id>
    <published>2020-02-25T03:25:24.000Z</published>
    <updated>2020-02-26T03:54:50.638Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>这两天我负责的一个 node 中间层框架 hobber，在业务方的那边的项目压测中，当 qps 达到 1500 左右时，出现大量 504。由于压测线上服务在半夜，当时我也不在现场，所以，我决定自己压一下，目的有两个，一个是压我们自己的服<a id="more"></a>务，看 hobber 是不是能够压到当初承诺的 qps 2500，另一个是想复现一下那天业务方压测出现的 504 问题。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>我用的是 jmeter，<a href="http://jmeter.apache.org/download_jmeter.cgi" target="_blank" rel="noopener">下载地址</a></p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>进入 jmeter 目录下对 bin 文件，执行命令：sh jmeter</p><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p>jmeter 压测的时候，一般不用图像化工具压，一般是执行脚本压，如果图像化工具直接压，太耗性能了，所以机器对资源尽量留给发压力。<br>但是脚本的话，一般是通过图形化界面配，然后把脚本导出来。</p><ol><li>创建线程组<br>在“测试计划”上右键 【添加】–&gt;【Threads(Users)】–&gt;【线程组】。<br><img src="/images/jmeter/1.png" alt></li></ol><p>设置线程数和循环次数。我这里设置线程数为 500，循环一次。<br><img src="/images/jmeter/2.png" alt></p><ol start="2"><li>配置元件<br>在我们刚刚创建的线程组上右键 【添加】–&gt;【配置元件】–&gt;【HTTP 请求默认值】。<br><img src="/images/jmeter/3.png" alt><br>配置我们需要进行测试的程序协议、地址和端口:<br><img src="/images/jmeter/4.png" alt><br><code>当所有的接口测试的访问域名和端口都一样时，可以使用该元件，一旦服务器地址变更，只需要修改请求默认值即可。</code></li><li><p>构造 HTTP 请求<br>在“线程组”右键 【添加-】-&gt;【samlper】–&gt;【HTTP 请求】设置我们需要测试的 API 的请求路径和数据。我这里是用的 json<br><img src="/images/jmeter/5.png" alt></p></li><li><p>添加 HTTP 请求头<br>在我们刚刚创建的线程组上右键 【添加】–&gt;【配置元件】–&gt;【HTTP 信息头管理器】。</p></li></ol><p>因为我要传输的数据为 json，所以设置一个 Content-Type:application/json<br><img src="/images/jmeter/6.png" alt></p><ol start="5"><li>添加断言<br>在我们刚刚创建的线程组上右键 【添加】–&gt;【断言】–&gt;【响应断言】。</li></ol><p>根据响应的数据来判断请求是否正常。我在这里只判断的响应代码是否为 200。还可以配置错误信息<br><img src="/images/jmeter/7.png" alt></p><ol start="6"><li>添加察看结果树<br>在我们刚刚创建的线程组上右键 【添加】–&gt;【监听器】–&gt;【察看结果树】。</li></ol><p>直接添加，然后点击运行按钮就可以看到结果了。<br><img src="/images/jmeter/8.png" alt></p><ol start="7"><li>添加 Summary Report<br>在我们刚刚创建的线程组上右键 【添加】–&gt;【监听器】–&gt;【Summary Report】。</li></ol><p>直接添加，然后点击运行按钮就可以看到结果了。<br><img src="/images/jmeter/9.png" alt></p><ol start="8"><li>测试计划创建完成<br>文件 -&gt; 保存测试计划</li></ol><h2 id="执行测试计划"><a href="#执行测试计划" class="headerlink" title="执行测试计划"></a>执行测试计划</h2><p>前面我们说过，执行测试计划不能用 GUI，需要用命令行来执行。<br><img src="/images/jmeter/10.png" alt></p><p>我这里执行的命令为：</p><p>jmeter -n -t testplan/RedisLock.jmx -l testplan/result/result.txt -e -o testplan/webreport</p><p>说明：<br>testplan/RedisLock.jmx 为测试计划文件路径<br>testplan/result/result.txt 为测试结果文件路径<br>testplan/webreport 为 web 报告保存路径。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如果发压机端口不够用，可能会出现这样的问题：</p><font color="#DC143C" face="黑体">Non HTTP response code: java.net.NoRouteToHostException/Non HTTP response message: Cannot assign requested address (Address not available)</font><p>解决办法：</p><ol><li>调低端口释放后的等待时间， 默认为 60s， 修改为 15~30s<br>echo 30 &gt; /proc/sys/net/ipv4/tcp_fin_timeout</li><li>修改 tcp/ip 协议配置， 通过配置/proc/sys/net/ipv4/tcp_tw_resue, 默认为 0， 修改为 1， 释放 TIME_WAIT 端口给新连接使用。<br>echo 1 &gt; /proc/sys/net/ipv4/tcp_tw_reuse</li><li>修改 tcp/ip 协议配置，快速回收 socket 资源， 默认为 0， 修改为 1.<br>echo 1 &gt; /proc/sys/net/ipv4/tcp_tw_recycle</li><li>执行：sysctl -p ，使设置立即生效。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;这两天我负责的一个 node 中间层框架 hobber，在业务方的那边的项目压测中，当 qps 达到 1500 左右时，出现大量 504。由于压测线上服务在半夜，当时我也不在现场，所以，我决定自己压一下，目的有两个，一个是压我们自己的服
    
    </summary>
    
      <category term="前端" scheme="https://skhon.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="node" scheme="https://skhon.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>解读node api</title>
    <link href="https://skhon.github.io/2020/01/15/node/"/>
    <id>https://skhon.github.io/2020/01/15/node/</id>
    <published>2020-01-15T03:25:24.000Z</published>
    <updated>2020-02-25T12:09:15.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;api&quot;&gt;&lt;a href=&quot;#api&quot; class=&quot;headerlink&quot; title=&quot;api&quot;&gt;&lt;/a&gt;api&lt;/h2&gt;
      
    
    </summary>
    
      <category term="前端" scheme="https://skhon.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="node" scheme="https://skhon.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>单元测试</title>
    <link href="https://skhon.github.io/2020/01/14/unit-test/"/>
    <id>https://skhon.github.io/2020/01/14/unit-test/</id>
    <published>2020-01-14T03:25:24.000Z</published>
    <updated>2020-02-25T12:09:15.669Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是单元测试"><a href="#什么是单元测试" class="headerlink" title="什么是单元测试"></a>什么是单元测试</h2><p>单元测试也叫做模块测试，就是对一个一个模块，来进行正确性检验对测试工作。如果接触测试的工作，测试人员在测你的项目之前都会写一些测试用例，然后这些测试用例可以覆盖到各种情况，然后用这些测试用例再一一检测你的程序，这是测<a id="more"></a>试功能做的一部分。我们项目做单元测试也就是为了我们的程序能够尽可能的少出 bug。</p><h2 id="node-的单元测试"><a href="#node-的单元测试" class="headerlink" title="node 的单元测试"></a>node 的单元测试</h2><p>单元测试的框架很多，可以看一下各种单元测试框架的对比：<br><img src="/images/test01.png" alt><br>mocha 用的最多，我用的也是 mocha，但是 mocha 没有断言库，那配一个 chai。</p><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><ol><li>先安装 mocha，chai</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i --save-dev mocha</span><br><span class="line">npm i --save-dev chai</span><br></pre></td></tr></table></figure><ol start="2"><li>写 demo</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// modules/add.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test/add.spec.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; expect &#125; = <span class="built_in">require</span>(<span class="string">"chai"</span>);</span><br><span class="line"><span class="keyword">const</span> add = <span class="built_in">require</span>(<span class="string">"../modules/add"</span>);</span><br><span class="line">describe(<span class="string">"测试加法模块"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    it(<span class="string">"1加2,应该为3"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        expect(add(<span class="number">1</span>, <span class="number">2</span>)).to.equal(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//assert.equal(-1, [1, 2, 3].indexOf(-1));</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx mocha add.spec.js</span><br></pre></td></tr></table></figure><p><img src="/images/test02.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是单元测试&quot;&gt;&lt;a href=&quot;#什么是单元测试&quot; class=&quot;headerlink&quot; title=&quot;什么是单元测试&quot;&gt;&lt;/a&gt;什么是单元测试&lt;/h2&gt;&lt;p&gt;单元测试也叫做模块测试，就是对一个一个模块，来进行正确性检验对测试工作。如果接触测试的工作，测试人员在测你的项目之前都会写一些测试用例，然后这些测试用例可以覆盖到各种情况，然后用这些测试用例再一一检测你的程序，这是测
    
    </summary>
    
      <category term="前端" scheme="https://skhon.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="node" scheme="https://skhon.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>node调试</title>
    <link href="https://skhon.github.io/2020/01/09/node-debug/"/>
    <id>https://skhon.github.io/2020/01/09/node-debug/</id>
    <published>2020-01-09T03:25:24.000Z</published>
    <updated>2020-02-25T12:09:15.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="node-调试的几种方法"><a href="#node-调试的几种方法" class="headerlink" title="node 调试的几种方法"></a>node 调试的几种方法</h2><p>在看 hobber 源码的时候，想看下一个请求是如何在 hobber 中跑的，我开始根据自己的理解以及猜测，是在 node_modules 中的包里打 console.log，这种方式感觉太累了，并且对整个 hobber 框架的理解效率不是很高，于是我问了一下 hobber 作者（黄老师）<a id="more"></a>,黄老师给我的答复是，他当时写 hobber 的时候，调试都是 console。。。好吧，我感觉我作为一个刚刚接触 hobber 的新手来说，光 console 好像救不了我。于是就研究了一下 node 的调试方式。</p><h3 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h3><p>网上有很多相关调试 node 的文章，但是笔者感觉最好还是看官网，我认为学习任何一门技术，首要看的资料是官网，因为那个是最权威的。我这里记录一下我用 vscode 调试 node 的一种方式。</p><p>配置一下 launch.json 文件即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。</span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="string">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"node"</span>,</span><br><span class="line">            <span class="string">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"hobber-debug"</span>,</span><br><span class="line">            <span class="string">"program"</span>: <span class="string">"$&#123;workspaceFolder&#125;/server/src/index.ts"</span>,</span><br><span class="line">            <span class="comment">// "preLaunchTask": "tsc: build - tsconfig.json",</span></span><br><span class="line">            <span class="string">"outFiles"</span>: [</span><br><span class="line">                <span class="string">"$&#123;workspaceFolder&#125;/server/dist/*.js"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里贴一下 vscode debug 的官方介绍：<a href="https://code.visualstudio.com/docs/nodejs/nodejs-debugging" target="_blank" rel="noopener">node debug in vscode</a></p><h3 id="inspector"><a href="#inspector" class="headerlink" title="inspector"></a>inspector</h3><p>这个 node 自带的就不要考虑了，太麻烦了。</p><h3 id="Chrome-55-开发工具"><a href="#Chrome-55-开发工具" class="headerlink" title="Chrome(55+) 开发工具"></a>Chrome(55+) 开发工具</h3><blockquote><p>版本：<br>Node.js 6.3+<br>Chrome 55+</p></blockquote><p>Chrome 打开：chrome://inspect<br>启动 node：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node --inspect-brk app.js  <span class="comment">// 在程序开头停止</span></span><br><span class="line">node --inspect app.js      <span class="comment">// 不会在程序开头停止</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;node-调试的几种方法&quot;&gt;&lt;a href=&quot;#node-调试的几种方法&quot; class=&quot;headerlink&quot; title=&quot;node 调试的几种方法&quot;&gt;&lt;/a&gt;node 调试的几种方法&lt;/h2&gt;&lt;p&gt;在看 hobber 源码的时候，想看下一个请求是如何在 hobber 中跑的，我开始根据自己的理解以及猜测，是在 node_modules 中的包里打 console.log，这种方式感觉太累了，并且对整个 hobber 框架的理解效率不是很高，于是我问了一下 hobber 作者（黄老师）
    
    </summary>
    
      <category term="前端" scheme="https://skhon.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="node" scheme="https://skhon.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>谈谈hook</title>
    <link href="https://skhon.github.io/2019/11/03/hook-js/"/>
    <id>https://skhon.github.io/2019/11/03/hook-js/</id>
    <published>2019-11-03T03:25:24.000Z</published>
    <updated>2020-06-04T04:13:21.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-hook"><a href="#什么是-hook" class="headerlink" title="什么是 hook"></a>什么是 hook</h2><p>概括的说：hook 是将一系列要执行的动作注册到一个统一的入口，程序通过调用 hook 来执行注册的动作。而一般执行 hook 的常规做法（并不是所有的 hook 都是这么调用的）是通过匹配的方式来执行。<a id="more"></a><br>我们可以先从匹配机制说起，先举个简单的例子。比如，前端和后端联调的时候，后端在 response 的时候，会给你返回各种状态码，你可以根据不同的状态码来分别进行前端的不同操作。这种逻辑，大多数同学会想到条件语句来实现:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (code === <span class="number">200</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Ok'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (code === <span class="number">500</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Internal server error'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (code === <span class="number">404</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Not found'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以用 switch 来实现。那我们这里可以用 hook 来实现的话，就感觉代码很优雅，并且执行效率也相对快一些。我们可以把所有可能的 code 放在一个 list 中，code 作为 key，对应的内容作为 value，然后来进行匹配。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> codeList = &#123;</span><br><span class="line">  <span class="number">200</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Ok'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">404</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Not founnd'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">500</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Internal server error'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">  codeList[input]();</span><br><span class="line">&#125;</span><br><span class="line">print(<span class="number">200</span>);</span><br></pre></td></tr></table></figure><p>上述程序运行结果为：”Ok”，那输出 Ok 的这个操作就是一个 hook，我们一共有三个 hook，而 print 为一个主流程，我们为这个主流程里面插入的我们注册的操作，就是 hook。再来一张丑图：<br><img src="/images/hook01.png" alt="hook 图解"><br>start-&gt;end 是一个完整的流程，我们需要在这个流程里面插入我们想要自己实现的功能，就可以将这些功能先注册到一个数组中，然后调用的时候，可以 Array[key]这种方式，执行我们的 hook。</p><h2 id="js-中的函数劫持"><a href="#js-中的函数劫持" class="headerlink" title="js 中的函数劫持"></a>js 中的函数劫持</h2><p>劫持的意思，大家都懂，在程序中的劫持，可以理解在一个常规的程序流程中，可以插入一些我们自己想执行的一些操作，进而改变整个过程。举个简单的例子，比如，我想劫持 alert，可以这么做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _alert = alert;</span><br><span class="line"><span class="built_in">window</span>.alert = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hooked!'</span>);</span><br><span class="line">  _alert(s);</span><br><span class="line">&#125;;</span><br><span class="line">alert(<span class="string">'hello world'</span>);</span><br></pre></td></tr></table></figure><p>这个过程可以理解为：先保存原来的 alert，然后重写 alert，这样在执行 alert 的时候，就是执行的重写之后的。那么重写的过程我们可以不暴露出来，那么对于用 alert 的用户来说，好像和以前的执行结果不太一样了。这就是<code>alert 函数被劫持了</code>。<br>我们可以再联想一下 hook 思想，hook 就是在一个完整流程中，插入我们想要实现的功能，那么原本的 alert 就是一个完整的执行流程，我们执行它，就是弹一个对话框，但是上面的例子展示了，在 alert 中添加了一条 console.log(“Hooked!”)这样的语句，这就是 hook 的思想。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-hook&quot;&gt;&lt;a href=&quot;#什么是-hook&quot; class=&quot;headerlink&quot; title=&quot;什么是 hook&quot;&gt;&lt;/a&gt;什么是 hook&lt;/h2&gt;&lt;p&gt;概括的说：hook 是将一系列要执行的动作注册到一个统一的入口，程序通过调用 hook 来执行注册的动作。而一般执行 hook 的常规做法（并不是所有的 hook 都是这么调用的）是通过匹配的方式来执行。
    
    </summary>
    
      <category term="前端" scheme="https://skhon.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://skhon.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
