<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>前端架构之路</title>
  <icon>https://www.gravatar.com/avatar/bafeed710faffad62197c060e0e91fda</icon>
  <subtitle>我宁愿犯错，也不想什么都不做</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://skhon.github.io/"/>
  <updated>2020-01-16T03:35:27.443Z</updated>
  <id>https://skhon.github.io/</id>
  
  <author>
    <name>liujianghong</name>
    <email>ljhtianhong@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>解读node api</title>
    <link href="https://skhon.github.io/2020/01/15/node/"/>
    <id>https://skhon.github.io/2020/01/15/node/</id>
    <published>2020-01-15T03:25:24.000Z</published>
    <updated>2020-01-16T03:35:27.443Z</updated>
    
    <content type="html"><![CDATA[<h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;api&quot;&gt;&lt;a href=&quot;#api&quot; class=&quot;headerlink&quot; title=&quot;api&quot;&gt;&lt;/a&gt;api&lt;/h2&gt;
      
    
    </summary>
    
      <category term="前端" scheme="https://skhon.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="node" scheme="https://skhon.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>单元测试</title>
    <link href="https://skhon.github.io/2020/01/14/unit-test/"/>
    <id>https://skhon.github.io/2020/01/14/unit-test/</id>
    <published>2020-01-14T03:25:24.000Z</published>
    <updated>2020-01-14T11:31:01.484Z</updated>
    
    <content type="html"><![CDATA[<p>## </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;## &lt;/p&gt;

      
    
    </summary>
    
      <category term="前端" scheme="https://skhon.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="node" scheme="https://skhon.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>node调试</title>
    <link href="https://skhon.github.io/2020/01/09/node-debug/"/>
    <id>https://skhon.github.io/2020/01/09/node-debug/</id>
    <published>2020-01-09T03:25:24.000Z</published>
    <updated>2020-01-17T03:53:30.488Z</updated>
    
    <content type="html"><![CDATA[<h2 id="node-调试的几种方法"><a href="#node-调试的几种方法" class="headerlink" title="node 调试的几种方法"></a>node 调试的几种方法</h2><p>在看 hobber 源码的时候，想看下一个请求是如何在 hobber 中跑的，我开始根据自己的理解以及猜测，是在 node_modules 中的包里打 console.log，这种方式感觉太累了，并且对整个 hobber 框架的理解效率不是很高，于是我问了一下 hobber 作者（黄老师）<a id="more"></a>,黄老师给我的答复是，他当时写 hobber 的时候，调试都是 console。。。好吧，我感觉我作为一个刚刚接触 hobber 的新手来说，光 console 好像救不了我。于是就研究了一下 node 的调试方式。</p><h3 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h3><p>网上有很多相关调试 node 的文章，但是笔者感觉最好还是看官网，我认为学习任何一门技术，首要看的资料是官网，因为那个是最权威的。我这里记录一下我用 vscode 调试 node 的一种方式。</p><p>配置一下 launch.json 文件即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。</span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="string">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"node"</span>,</span><br><span class="line">            <span class="string">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"hobber-debug"</span>,</span><br><span class="line">            <span class="string">"program"</span>: <span class="string">"$&#123;workspaceFolder&#125;/server/src/index.ts"</span>,</span><br><span class="line">            <span class="comment">// "preLaunchTask": "tsc: build - tsconfig.json",</span></span><br><span class="line">            <span class="string">"outFiles"</span>: [</span><br><span class="line">                <span class="string">"$&#123;workspaceFolder&#125;/server/dist/*.js"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里贴一下 vscode debug 的官方介绍：<a href="https://code.visualstudio.com/docs/nodejs/nodejs-debugging" target="_blank" rel="noopener">node debug in vscode</a></p><h3 id="inspector"><a href="#inspector" class="headerlink" title="inspector"></a>inspector</h3><p>这个 node 自带的就不要考虑了，太麻烦了。</p><h3 id="Chrome-55-开发工具"><a href="#Chrome-55-开发工具" class="headerlink" title="Chrome(55+) 开发工具"></a>Chrome(55+) 开发工具</h3><blockquote><p>版本：<br>Node.js 6.3+<br>Chrome 55+</p></blockquote><p>Chrome 打开：chrome://inspect<br>启动 node：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node --inspect-brk app.js  <span class="comment">// 在程序开头停止</span></span><br><span class="line">node --inspect app.js      <span class="comment">// 不会在程序开头停止</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;node-调试的几种方法&quot;&gt;&lt;a href=&quot;#node-调试的几种方法&quot; class=&quot;headerlink&quot; title=&quot;node 调试的几种方法&quot;&gt;&lt;/a&gt;node 调试的几种方法&lt;/h2&gt;&lt;p&gt;在看 hobber 源码的时候，想看下一个请求是如何在 hobber 中跑的，我开始根据自己的理解以及猜测，是在 node_modules 中的包里打 console.log，这种方式感觉太累了，并且对整个 hobber 框架的理解效率不是很高，于是我问了一下 hobber 作者（黄老师）
    
    </summary>
    
      <category term="前端" scheme="https://skhon.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="node" scheme="https://skhon.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>谈谈hook</title>
    <link href="https://skhon.github.io/2020/01/03/hook-js/"/>
    <id>https://skhon.github.io/2020/01/03/hook-js/</id>
    <published>2020-01-03T03:25:24.000Z</published>
    <updated>2020-01-17T03:02:19.143Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-hook"><a href="#什么是-hook" class="headerlink" title="什么是 hook"></a>什么是 hook</h2><p>概括的说：hook 是将一系列要执行的动作注册到一个统一的入口，程序通过调用 hook 来执行注册的动作。而一般执行 hook 的常规做法（并不是所有的 hook 都是这么调用的）是通过匹配的方式来执行。<a id="more"></a><br>我们可以先从匹配机制说起，先举个简单的例子。比如，前端和后端联调的时候，后端在 response 的时候，会给你返回各种状态码，你可以根据不同的状态码来分别进行前端的不同操作。这种逻辑，大多数同学会想到条件语句来实现:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (code === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Ok"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (code === <span class="number">500</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Internal server error"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (code === <span class="number">404</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Not found"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以用 switch 来实现。那我们这里可以用 hook 来实现的话，就感觉代码很优雅，并且执行效率也相对快一些。我们可以把所有可能的 code 放在一个 list 中，code 作为 key，对应的内容作为 value，然后来进行匹配。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> codeList = &#123;</span><br><span class="line">    <span class="number">200</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Ok"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">404</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Not founnd"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">500</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Internal server error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    codeList[input]();</span><br><span class="line">&#125;</span><br><span class="line">print(<span class="number">200</span>);</span><br></pre></td></tr></table></figure><p>上述程序运行结果为：”Ok”，那输出 Ok 的这个操作就是一个 hook，我们一共有三个 hook，而 print 为一个主流程，我们为这个主流程里面插入的我们注册的操作，就是 hook。再来一张丑图：<br><img src="/images/hook01.png" alt="hook 图解"><br>start-&gt;end 是一个完整的流程，我们需要在这个流程里面插入我们想要自己实现的功能，就可以将这些功能先注册到一个数组中，然后调用的时候，可以 Array[key]这种方式，执行我们的 hook。</p><h2 id="js-中的函数劫持"><a href="#js-中的函数劫持" class="headerlink" title="js 中的函数劫持"></a>js 中的函数劫持</h2><p>劫持的意思，大家都懂，在程序中的劫持，可以理解在一个常规的程序流程中，可以插入一些我们自己想执行的一些操作，进而改变整个过程。举个简单的例子，比如，我想劫持 alert，可以这么做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _alert = alert;</span><br><span class="line"><span class="built_in">window</span>.alert = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Hooked!"</span>);</span><br><span class="line">    _alert(s);</span><br><span class="line">&#125;;</span><br><span class="line">alert(<span class="string">"hello world"</span>);</span><br></pre></td></tr></table></figure><p>这个过程可以理解为：先保存原来的 alert，然后重写 alert，这样在执行 alert 的时候，就是执行的重写之后的。那么重写的过程我们可以不暴露出来，那么对于用 alert 的用户来说，好像和以前的执行结果不太一样了。这就是<code>alert 函数被劫持了</code>。<br>我们可以再联想一下 hook 思想，hook 就是在一个完整流程中，插入我们想要实现的功能，那么原本的 alert 就是一个完整的执行流程，我们执行它，就是弹一个对话框，但是上面的例子展示了，在 alert 中添加了一条 console.log(“Hooked!”)这样的语句，这就是 hook 的思想。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-hook&quot;&gt;&lt;a href=&quot;#什么是-hook&quot; class=&quot;headerlink&quot; title=&quot;什么是 hook&quot;&gt;&lt;/a&gt;什么是 hook&lt;/h2&gt;&lt;p&gt;概括的说：hook 是将一系列要执行的动作注册到一个统一的入口，程序通过调用 hook 来执行注册的动作。而一般执行 hook 的常规做法（并不是所有的 hook 都是这么调用的）是通过匹配的方式来执行。
    
    </summary>
    
      <category term="前端" scheme="https://skhon.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://skhon.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
