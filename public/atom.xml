<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>前端架构之路</title>
  <icon>https://www.gravatar.com/avatar/bafeed710faffad62197c060e0e91fda</icon>
  <subtitle>我宁愿犯错，也不想什么都不做</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://skhon.github.io/"/>
  <updated>2021-12-17T10:04:10.682Z</updated>
  <id>https://skhon.github.io/</id>
  
  <author>
    <name>liujianghong</name>
    <email>ljhtianhong@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>谈谈我喜欢的候选人</title>
    <link href="https://skhon.github.io/2021/12/17/interview/mymind/"/>
    <id>https://skhon.github.io/2021/12/17/interview/mymind/</id>
    <published>2021-12-17T08:42:03.628Z</published>
    <updated>2021-12-17T10:04:10.682Z</updated>
    
    <content type="html"><![CDATA[<p>其实作为面试官有几年了，在第一家公司2016年的时候，就开始这方面工作了，这几年的面试经历中，遇到的多数候选人普普通通，当然也遇到过优秀的，但是非常少。其实作为面试官，我是非常不赞成抛开简历中的项目，直接各种八股文去考察候选人，这样的面试是片面的，还有一些面试官，也是抛开候选人简历，只问面试官自己会的。我觉得像这些面试官，他本身的技能就不是很扎实，不是合格的面试官，但是有很多时候，公司需要大量招人，就会让一些级别不高的同学也去做面试官，就会导致一些问题。那么接下来我就谈谈，我心目中优秀的候选人，是什么样的。</p><h3 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h3><p>简历很重要，我了解候选人的整体情况，第一印象都来自于候选人的简历。简历如果没有亮点，按照我的经验，多少情况最终的结果都是fail。我们先看看千篇一律的简历，如下：<br><img src="/images/interview/jianli1.png" width="50%"><br>这个候选人，工作4年，其实也不短，专业技能写的很泛泛，面比较广，这些技能都学的怎么样，通过简历还是看不出来，需要面试中沟通。另外再看项目，就是普通的前端项目，也看不到任何的难点和亮点。所以，像这种简历，第一印象都不是很好，如果学校、工作经历都不好的情况下，简历基本过不了。<br>那么什么样的简历是有亮点的呢？可以看一下这个：<br><img src="/images/interview/jianli2.png" width="50%"><br>首先个人优势比较突出，是一个开源项目的主要负责人，并且是vue-router的Contributor，另外在极客帮做过技术分享，这几点就很多人做不到的了。这就是亮点！我们为什么喜欢对开源社区有贡献的候选人呢，因为一般开源社区中比较知名的框架或者技术都是有一定难度的，都是从架构设计到实现，是值得我们很多人去学习的，所以它出名，而对于这些优秀的开源项目有共享的同学，他们对其实现肯定是了解甚至掌握的，而这就是体现出了候选人的实力。<br>一个人的亮点可以是方方面面的，比如曾经写过《xxx》书籍，在公司申请过《xxx》专利，甚至你在leetcode上涮了200道题都是你的亮点，如果你说我就是没有亮点，那我觉得就是懒，行动上和思想上都懒。那为啥优秀的那个人不可以是你呢？</p><h3 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h3><p>我一般在面试中，除了计算机基础之外，基本上都是会按照候选人的简历去聊，由浅入深，探索候选人的深度，比如候选人主要用的技术栈是react，那我会先聊一下react的一些特性，比如生命周期、一些副作用的操作在哪里写比较合适。再往深聊，就会问一些react优化的问题，hooks的使用。如果候选人答的不错，我还会往原理上聊，比如如果要实现一个xxx需求，如何写一个自定义hooks。再往深聊，就会聊到react设计、源码这部分，如果候选人能把所有问题都答的非常好，那就是牛批的候选人。这是深度。另外也会探索一下候选人的广度，比如跳出浏览器会问一些其他的技能，比如nodejs、数据库、运维相关的，如果候选人平时后端需求也写，那可以理解为是一个全栈工程师，这样的候选人有个优势就是面对一些复杂的场景需求时，可以自己搞定，进来也好带，不用特别费劲。如果技术的深度和广度都没问题的话，我可能还会问一些解决方案的思路，比如一些工程化问题，如何分析公共依赖，确定前端页面的回归范围、如何统计相似函数以提升代码质量等。总之我的面试中，可能会问很多原理性问题，如果我们聊的来，那我觉得你就是我喜欢的那种候选人。</p><h3 id="代码能力"><a href="#代码能力" class="headerlink" title="代码能力"></a>代码能力</h3><p>我的面试中，一般都会有代码题，题目不难，都是leetcode中简单题目。考代码能力的主要目的，不是为了考的你不会，而是看你的代码能力过不过关，主要看你的代码速度、代码思路、代码规范等，通过你写代码，大概能了解你的代码能力，甚至你的性格。因为个别候选人，理论知识确实不错，进来写项目需求的时候，巨慢，这种就是代码不过关导致的问题。</p><h3 id="软性技能"><a href="#软性技能" class="headerlink" title="软性技能"></a>软性技能</h3><p>软性技能的话，对于候选人来说，可能比较好答一些，但是也分好坏。这个就是主要观察一些候选人的沟通能力、性格之类的，可能更具候选人的性格，也需要安排不同的工作，比如内向一点都，可能会擅长偏技术攻关之类的工作，因为偏内向的人，一般都有一定的耐力或者耐性。对于乐观开朗一点的候选人，会适合做一些需求联动的工作，因为他擅于和各种人（测试、产品）沟通，也会促进工作更好的完成。<br>另外就是看看他的一些学习渠道，比如喜欢看凯源的一些技术或者框架，那可以看到这样的候选人对技术还是有热情的。喜欢看书、看博客，这样的候选人也是喜欢学习的，像这样的候选人，我也比较青睐。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我觉得以上几个方面做的不错的同学，我觉得就是我喜欢的那类候选人。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;其实作为面试官有几年了，在第一家公司2016年的时候，就开始这方面工作了，这几年的面试经历中，遇到的多数候选人普普通通，当然也遇到过优秀的，但是非常少。其实作为面试官，我是非常不赞成抛开简历中的项目，直接各种八股文去考察候选人，这样的面试是片面的，还有一些面试官，也是抛开候
      
    
    </summary>
    
      <category term="面试" scheme="https://skhon.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Interview" scheme="https://skhon.github.io/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>原型链攻击</title>
    <link href="https://skhon.github.io/2021/12/17/security/prototype/"/>
    <id>https://skhon.github.io/2021/12/17/security/prototype/</id>
    <published>2021-12-17T07:32:15.614Z</published>
    <updated>2021-12-19T04:40:05.026Z</updated>
    
    <content type="html"><![CDATA[<p>安全问题是公司非常重视的问题，但是在我面试过程中，很多候选人只知道xss、csrf这两种，因为多数面经中，只会提到这两种。可以看到，前端工程师在平时的开发中，还是很少考虑安全问题的。由于本人在公司负责工程化建设相关工作，会涉及到项目的安全漏洞检测，所以后续多写一些相关的文章。<br>今天聊的是原型链污染攻击问题，我们先以一个非常简单的程序入手，我们知道在JavaScript中，一个对象有一个<strong>proto</strong>属性，它是指向Object.prototype的，像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;;</span><br><span class="line">console.log(obj.__proto === Object.prototype); // true</span><br></pre></td></tr></table></figure></p><p>有了这个前置知识后，大家可以看下面的程序会输出什么。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;;</span><br><span class="line">obj.__proto__.name = &apos;obj&apos;;</span><br><span class="line">console.log(obj.name); // 这个很明显，是obj</span><br><span class="line"></span><br><span class="line">let newObj = &#123;&#125;;</span><br><span class="line">console.log(newObj.name); // ???</span><br></pre></td></tr></table></figure></p><p>执行后，你会发现，newObj.name也为obj！什么情况，我新定义的newObj对象，居然可以输出name属性？？没错，这就是原型链污染。<strong>原因就是：改obj.<strong>proto</strong>,其实就是改了Object.prototype,而newObj的<strong>proto</strong>也是指向Object.prototype，这样Object的原型对象被偷偷改了，导致后面的对象不知道，这就是原型链污染的实质</strong></p><p>这种漏洞一般会出现在类似merge操作中，而很多工具库就提供merge方法，之前lodash就存在过原型链漏洞问题，后来修复了，如果存在漏洞，有些人就会故意往原型链上merge一些具有危险的属性，给系统带来危机。我们可以看一个简单的merge函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function merge(target, source) &#123;</span><br><span class="line">  for (let key in source) &#123;</span><br><span class="line">    if (key in source &amp;&amp; key in target) &#123;</span><br><span class="line">      merge(target[key], source[key])</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      target[key] = source[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们来验证一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let o1 = &#123;&#125;</span><br><span class="line">let o2 = &#123;a: 1, &quot;__proto__&quot;: &#123;b: 2&#125;&#125;</span><br><span class="line">merge(o1, o2)</span><br><span class="line">console.log(o1.a, o1.b) // 1 2</span><br><span class="line"></span><br><span class="line">o3 = &#123;&#125;</span><br><span class="line">console.log(o3.b) // undefined</span><br></pre></td></tr></table></figure></p><p>我们可以看到这么搞，是没有污染的，原因是o2这么定义，<strong>proto</strong>会直接放在原型链上，不会当作o2的属性，可以这么理解：<br>o2.<strong>proto</strong> ==&gt; { b: 2, <strong>proto</strong>: Object.prototype}，而for in是能够遍历到原型链上的属性，所以会直接在o1中增加属性b为2。加入这么写会是啥样，看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let o1 = &#123;&#125;</span><br><span class="line">let o2 = JSON.parse(&apos;&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;b&quot;: 2&#125;&#125;&apos;)</span><br><span class="line">merge(o1, o2)</span><br><span class="line">console.log(o1.a, o1.b) // 1 2</span><br><span class="line"></span><br><span class="line">o3 = &#123;&#125;</span><br><span class="line">console.log(o3.b) // 2</span><br></pre></td></tr></table></figure></p><p>这么写就污染了，因为这么写，<strong>proto</strong>会当作o2的一个属性，就是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">o2 = &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  __proto__: &#123;</span><br><span class="line">    b: 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这么会让o1.<strong>proto</strong> = {b: 2},而o1的<strong>proto</strong>就是Object.prototype，随意就会导致Object的原型对象被悄悄的改了。</p><p>如何缓解原型链漏洞呢？这里提供了几种方式可参考：</p><blockquote><p>Object.freeze 将缓解几乎所有情况。冻结 Object 阻止添加新的 Prototype。<br>使用模式验证确保 JSON 数据包含预期属性，从而删除 JSON 中出现的 <em>proto</em>。<br>使用映射原语。它在 EcmaScript6 标准中引入，目前在 NodeJS 环境中备受支持。<br>使用 Object.creat(null) 函数创建的Objects 不具有 <em>proto</em> 属性。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;安全问题是公司非常重视的问题，但是在我面试过程中，很多候选人只知道xss、csrf这两种，因为多数面经中，只会提到这两种。可以看到，前端工程师在平时的开发中，还是很少考虑安全问题的。由于本人在公司负责工程化建设相关工作，会涉及到项目的安全漏洞检测，所以后续多写一些相关的文章
      
    
    </summary>
    
      <category term="安全" scheme="https://skhon.github.io/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Security" scheme="https://skhon.github.io/tags/Security/"/>
    
  </entry>
  
  <entry>
    <title>代码覆盖率</title>
    <link href="https://skhon.github.io/2021/12/16/engineering/coverage/"/>
    <id>https://skhon.github.io/2021/12/16/engineering/coverage/</id>
    <published>2021-12-16T12:50:04.517Z</published>
    <updated>2021-12-17T07:33:03.894Z</updated>
    
    <content type="html"><![CDATA[<p>最近为了防止因为漏测导致线上问题，做了一些统计测试覆盖率的工作。这个过程中用到了一个检测代码覆盖率的工具，叫：istanbul。它主要能够从几个维度来分析对应的覆盖率。比如下面几个指标：</p><blockquote><ul><li>行覆盖率（line coverage）：是否每一行都执行了？</li><li>函数覆盖率（function coverage）：是否每个函数都调用了？</li><li>分支覆盖率（branch coverage）：是否每个if代码块都执行了？</li><li>语句覆盖率（statement coverage）：是否每个语句都执行了？</li></ul></blockquote><p>使用起来也比较简单：</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Istanbul 是一个 npm 模块，安装非常简单，就一行命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g istanbul</span><br></pre></td></tr></table></figure></p><h3 id="覆盖率测试"><a href="#覆盖率测试" class="headerlink" title="覆盖率测试"></a>覆盖率测试</h3><p>来看一个例子，怎么使用 Istanbul 。下面是脚本文件 simple.js 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">var b = 1;</span><br><span class="line">if ((a + b) &gt; 2) &#123;</span><br><span class="line">  console.log(&apos;more than two&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 istanbul cover 命令，就能得到覆盖率。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ istanbul cover simple.js</span><br><span class="line"></span><br><span class="line">===== Coverage summary =====</span><br><span class="line">Statements   : 75% ( 3/4 )</span><br><span class="line">Branches     : 50% ( 1/2 )</span><br><span class="line">Functions    : 100% ( 0/0 )</span><br><span class="line">Lines        : 75% ( 3/4 )</span><br><span class="line">=============================</span><br></pre></td></tr></table></figure></p><p>返回结果显示，simple.js 有4个语句（statement），执行了3个；有2个分支（branch），执行了1个；有0个函数，调用了0个；有4行代码，执行了3行。</p><p>这条命令同时还生成了一个 coverage 子目录，其中的 coverage.json 文件包含覆盖率的原始数据，coverage/lcov-report 是可以在浏览器打开的覆盖率报告，其中有详细信息，到底哪些代码没有覆盖到。</p><h3 id="覆盖率门槛"><a href="#覆盖率门槛" class="headerlink" title="覆盖率门槛"></a>覆盖率门槛</h3><p>完美的覆盖率当然是 100%，但是现实中很难达到。需要有一个门槛，衡量覆盖率是否达标。</p><p>istanbul check-coverage 命令用来设置门槛，同时检查当前代码是否达标。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ istanbul check-coverage --statement 90</span><br><span class="line"></span><br><span class="line">ERROR: Coverage for statements (75%) does not meet global threshold (90%)</span><br></pre></td></tr></table></figure><p>上面命令设置语句覆盖率的门槛是 90% ，结果就报错了，因为实际覆盖率只有75%。</p><p>除了百分比门槛，我们还可以设置绝对值门槛，比如只允许有一个语句没有被覆盖到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ istanbul check-coverage --statement -1</span><br></pre></td></tr></table></figure><p>上面命令使用负数，表示绝对值门槛。这样一来，上面的例子就通过了覆盖率测试，不会再报错了。</p><p>百分比门槛和绝对值门槛，可以结合使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ istanbul check-coverage --statement -5 --branch -3 --function 100</span><br></pre></td></tr></table></figure><p>上面命令设置了3个覆盖率门槛：5个语句、3个 if 代码块、100%的函数。注意，这三个门槛是”与”（and）的关系，只要有一个没有达标，就会报错。</p><h3 id="与测试框架的结合"><a href="#与测试框架的结合" class="headerlink" title="与测试框架的结合"></a>与测试框架的结合</h3><p>实际开发时，istanbul 总是与测试框架结合使用，下面以常用的 Mocha 框架为例。</p><p>sqrt.js 是一个计算平方根的脚本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var My = &#123;</span><br><span class="line">  sqrt: function(x) &#123;</span><br><span class="line">    if (x &lt; 0) throw new Error(&quot;负值没有平方根&quot;);</span><br><span class="line">      return Math.exp(Math.log(x)/2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = My;</span><br></pre></td></tr></table></figure><p>它的测试脚本 test.sqrt.js 放在 test 子目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var chai = require(&apos;chai&apos;);</span><br><span class="line">var expect = chai.expect;</span><br><span class="line">var My = require(&apos;../sqrt.js&apos;);</span><br><span class="line"></span><br><span class="line">describe(&quot;sqrt&quot;, function() &#123;</span><br><span class="line"></span><br><span class="line">  it(&quot;4的平方根应该等于2&quot;, function() &#123;</span><br><span class="line">    expect(My.sqrt(4)).to.equal(2);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(&quot;参数为负值时应该报错&quot;, function() &#123;</span><br><span class="line">    expect(function()&#123; My.sqrt(-1); &#125;).to.throw(&quot;负值没有平方根&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后，执行下面的命令得到代码覆盖率。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ istanbul cover _mocha</span><br><span class="line">// or</span><br><span class="line">$ istanbul cover _mocha test/test.sqrt.js</span><br><span class="line"></span><br><span class="line">  sqrt</span><br><span class="line">    ✓ 4的平方根应该等于2 </span><br><span class="line">    ✓ 参数为负值时应该报错 </span><br><span class="line"></span><br><span class="line">  2 passing (7ms)</span><br><span class="line"></span><br><span class="line">===== Coverage summary =====</span><br><span class="line">Statements   : 100% ( 5/5 )</span><br><span class="line">Branches     : 100% ( 2/2 )</span><br><span class="line">Functions    : 100% ( 1/1 )</span><br><span class="line">Lines        : 100% ( 4/4 )</span><br><span class="line">=============================</span><br></pre></td></tr></table></figure><p>上面命令中，istanbul cover 命令后面跟的是 _mocha 命令，前面的下划线是不能省略的。</p><p>因为，mocha 和 _mocha 是两个不同的命令，前者会新建一个进程执行测试，而后者是在当前进程（即 istanbul 所在的进程）执行测试，只有这样， istanbul 才会捕捉到覆盖率数据。其他测试框架也是如此，必须在同一个进程执行测试。</p><p>如果要向 mocha 传入参数，可以写成下面的样子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ istanbul cover _mocha -- tests/test.sqrt.js -R spec</span><br></pre></td></tr></table></figure></p><p>上面命令中，两根连词线后面的部分，都会被当作参数传入 Mocha 。如果不加那两根连词线，它们就会被当作 istanbul 的参数（参考链接1，2）。</p><p>如果想在浏览器运行 Istanbul ，可以参考这篇文章。</p><p>五、忽略某些代码<br>istanbul 提供注释语法，允许某些代码不计入覆盖率。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var object = parameter || /* istanbul ignore next */ &#123;&#125;;</span><br></pre></td></tr></table></figure><p>上面代码是为 object 指定默认值（一个空对象）。如果由于种种原因，没有为 object 为空对象的情况写测试，可以用注释，不将这种情况计入覆盖率。注意，注释要写在”或”运算符的后面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* istanbul ignore if  */</span><br><span class="line">if (hardToReproduceError)) &#123;</span><br><span class="line">    return callback(hardToReproduceError);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的 if 语句块，在计算覆盖率的时候会被忽略。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近为了防止因为漏测导致线上问题，做了一些统计测试覆盖率的工作。这个过程中用到了一个检测代码覆盖率的工具，叫：istanbul。它主要能够从几个维度来分析对应的覆盖率。比如下面几个指标：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;行覆盖率（line coverag
      
    
    </summary>
    
      <category term="工程化建设" scheme="https://skhon.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%BB%BA%E8%AE%BE/"/>
    
    
      <category term="Engineering" scheme="https://skhon.github.io/tags/Engineering/"/>
    
  </entry>
  
  <entry>
    <title>搭一个小窝</title>
    <link href="https://skhon.github.io/2021/07/15/my-heart/index/"/>
    <id>https://skhon.github.io/2021/07/15/my-heart/index/</id>
    <published>2021-07-15T12:36:19.443Z</published>
    <updated>2021-12-16T12:19:27.208Z</updated>
    
    <content type="html"><![CDATA[<p>加入字节跳动已经半年多了，后续多做一些技术积累。所以在这里搭建一个小窝，记录一些自己的思想，可能是技术，也可能是扯淡。<a id="more"></a>为的就是以后可以再回忆回忆这段时光。哪怕以后不在互联网工作了，有时间也能再看看曾经走过的这段路程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;加入字节跳动已经半年多了，后续多做一些技术积累。所以在这里搭建一个小窝，记录一些自己的思想，可能是技术，也可能是扯淡。
    
    </summary>
    
      <category term="杂谈" scheme="https://skhon.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="Talking to oneself" scheme="https://skhon.github.io/tags/Talking-to-oneself/"/>
    
  </entry>
  
</feed>
