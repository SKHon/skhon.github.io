<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[jmeter压测]]></title>
      <url>https://skhon.github.io/2020/01/15/jmeter-test/</url>
      <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>这两天我负责的一个 node 中间层框架 hobber，在业务方的那边的项目压测中，当 qps 达到 1500 左右时，出现大量 504。由于压测线上服务在半夜，当时我也不在现场，所以，我决定自己压一下，目的有两个，一个是压我们自己的服<a id="more"></a>务，看 hobber 是不是能够压到当初承诺的 qps 2500，另一个是想复现一下那天业务方压测出现的 504 问题。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>我用的是 jmeter，<a href="http://jmeter.apache.org/download_jmeter.cgi" target="_blank" rel="noopener">下载地址</a></p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>进入 jmeter 目录下对 bin 文件，执行命令：sh jmeter</p>
<h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p>jmeter 压测的时候，一般不用图像化工具压，一般是执行脚本压，如果图像化工具直接压，太耗性能了，所以机器对资源尽量留给发压力。<br>但是脚本的话，一般是通过图形化界面配，然后把脚本导出来。</p>
<ol>
<li>创建线程组<br>在“测试计划”上右键 【添加】–&gt;【Threads(Users)】–&gt;【线程组】。<br><img src="/images/jmeter/1.png" alt></li>
</ol>
<p>设置线程数和循环次数。我这里设置线程数为 500，循环一次。<br><img src="/images/jmeter/2.png" alt></p>
<ol start="2">
<li>配置元件<br>在我们刚刚创建的线程组上右键 【添加】–&gt;【配置元件】–&gt;【HTTP 请求默认值】。<br><img src="/images/jmeter/3.png" alt><br>配置我们需要进行测试的程序协议、地址和端口:<br><img src="/images/jmeter/4.png" alt><br><code>当所有的接口测试的访问域名和端口都一样时，可以使用该元件，一旦服务器地址变更，只需要修改请求默认值即可。</code></li>
<li><p>构造 HTTP 请求<br>在“线程组”右键 【添加-】-&gt;【samlper】–&gt;【HTTP 请求】设置我们需要测试的 API 的请求路径和数据。我这里是用的 json<br><img src="/images/jmeter/5.png" alt></p>
</li>
<li><p>添加 HTTP 请求头<br>在我们刚刚创建的线程组上右键 【添加】–&gt;【配置元件】–&gt;【HTTP 信息头管理器】。</p>
</li>
</ol>
<p>因为我要传输的数据为 json，所以设置一个 Content-Type:application/json<br><img src="/images/jmeter/6.png" alt></p>
<ol start="5">
<li>添加断言<br>在我们刚刚创建的线程组上右键 【添加】–&gt;【断言】–&gt;【响应断言】。</li>
</ol>
<p>根据响应的数据来判断请求是否正常。我在这里只判断的响应代码是否为 200。还可以配置错误信息<br><img src="/images/jmeter/7.png" alt></p>
<ol start="6">
<li>添加察看结果树<br>在我们刚刚创建的线程组上右键 【添加】–&gt;【监听器】–&gt;【察看结果树】。</li>
</ol>
<p>直接添加，然后点击运行按钮就可以看到结果了。<br><img src="/images/jmeter/8.png" alt></p>
<ol start="7">
<li>添加 Summary Report<br>在我们刚刚创建的线程组上右键 【添加】–&gt;【监听器】–&gt;【Summary Report】。</li>
</ol>
<p>直接添加，然后点击运行按钮就可以看到结果了。<br><img src="/images/jmeter/9.png" alt></p>
<ol start="8">
<li>测试计划创建完成<br>文件 -&gt; 保存测试计划</li>
</ol>
<h2 id="执行测试计划"><a href="#执行测试计划" class="headerlink" title="执行测试计划"></a>执行测试计划</h2><p>前面我们说过，执行测试计划不能用 GUI，需要用命令行来执行。<br><img src="/images/jmeter/10.png" alt></p>
<p>我这里执行的命令为：</p>
<p>jmeter -n -t testplan/RedisLock.jmx -l testplan/result/result.txt -e -o testplan/webreport</p>
<p>说明：<br>testplan/RedisLock.jmx 为测试计划文件路径<br>testplan/result/result.txt 为测试结果文件路径<br>testplan/webreport 为 web 报告保存路径。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如果发压机端口不够用，可能会出现这样的问题：</p>
<font color="#DC143C" face="黑体">Non HTTP response code: java.net.NoRouteToHostException/Non HTTP response message: Cannot assign requested address (Address not available)</font>

<p>解决办法：</p>
<ol>
<li>调低端口释放后的等待时间， 默认为 60s， 修改为 15~30s<br>echo 30 &gt; /proc/sys/net/ipv4/tcp_fin_timeout</li>
<li>修改 tcp/ip 协议配置， 通过配置/proc/sys/net/ipv4/tcp_tw_resue, 默认为 0， 修改为 1， 释放 TIME_WAIT 端口给新连接使用。<br>echo 1 &gt; /proc/sys/net/ipv4/tcp_tw_reuse</li>
<li>修改 tcp/ip 协议配置，快速回收 socket 资源， 默认为 0， 修改为 1.<br>echo 1 &gt; /proc/sys/net/ipv4/tcp_tw_recycle</li>
<li>执行：sysctl -p ，使设置立即生效。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> node </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[解读node api]]></title>
      <url>https://skhon.github.io/2020/01/15/node/</url>
      <content type="html"><![CDATA[<h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2>]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> node </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[单元测试]]></title>
      <url>https://skhon.github.io/2020/01/14/unit-test/</url>
      <content type="html"><![CDATA[<h2 id="什么是单元测试"><a href="#什么是单元测试" class="headerlink" title="什么是单元测试"></a>什么是单元测试</h2><p>单元测试也叫做模块测试，就是对一个一个模块，来进行正确性检验对测试工作。如果接触测试的工作，测试人员在测你的项目之前都会写一些测试用例，然后这些测试用例可以覆盖到各种情况，然后用这些测试用例再一一检测你的程序，这是测<a id="more"></a>试功能做的一部分。我们项目做单元测试也就是为了我们的程序能够尽可能的少出 bug。</p>
<h2 id="node-的单元测试"><a href="#node-的单元测试" class="headerlink" title="node 的单元测试"></a>node 的单元测试</h2><p>单元测试的框架很多，可以看一下各种单元测试框架的对比：<br><img src="/images/test01.png" alt><br>mocha 用的最多，我用的也是 mocha，但是 mocha 没有断言库，那配一个 chai。</p>
<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><ol>
<li>先安装 mocha，chai</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i --save-dev mocha</span><br><span class="line">npm i --save-dev chai</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>写 demo</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// modules/add.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test/add.spec.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; expect &#125; = <span class="built_in">require</span>(<span class="string">"chai"</span>);</span><br><span class="line"><span class="keyword">const</span> add = <span class="built_in">require</span>(<span class="string">"../modules/add"</span>);</span><br><span class="line">describe(<span class="string">"测试加法模块"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    it(<span class="string">"1加2,应该为3"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        expect(add(<span class="number">1</span>, <span class="number">2</span>)).to.equal(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//assert.equal(-1, [1, 2, 3].indexOf(-1));</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx mocha add.spec.js</span><br></pre></td></tr></table></figure>
<p><img src="/images/test02.png" alt></p>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> node </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[node调试]]></title>
      <url>https://skhon.github.io/2020/01/09/node-debug/</url>
      <content type="html"><![CDATA[<h2 id="node-调试的几种方法"><a href="#node-调试的几种方法" class="headerlink" title="node 调试的几种方法"></a>node 调试的几种方法</h2><p>在看 hobber 源码的时候，想看下一个请求是如何在 hobber 中跑的，我开始根据自己的理解以及猜测，是在 node_modules 中的包里打 console.log，这种方式感觉太累了，并且对整个 hobber 框架的理解效率不是很高，于是我问了一下 hobber 作者（黄老师）<a id="more"></a>,黄老师给我的答复是，他当时写 hobber 的时候，调试都是 console。。。好吧，我感觉我作为一个刚刚接触 hobber 的新手来说，光 console 好像救不了我。于是就研究了一下 node 的调试方式。</p>
<h3 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h3><p>网上有很多相关调试 node 的文章，但是笔者感觉最好还是看官网，我认为学习任何一门技术，首要看的资料是官网，因为那个是最权威的。我这里记录一下我用 vscode 调试 node 的一种方式。</p>
<p>配置一下 launch.json 文件即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。</span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="string">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"node"</span>,</span><br><span class="line">            <span class="string">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"hobber-debug"</span>,</span><br><span class="line">            <span class="string">"program"</span>: <span class="string">"$&#123;workspaceFolder&#125;/server/src/index.ts"</span>,</span><br><span class="line">            <span class="comment">// "preLaunchTask": "tsc: build - tsconfig.json",</span></span><br><span class="line">            <span class="string">"outFiles"</span>: [</span><br><span class="line">                <span class="string">"$&#123;workspaceFolder&#125;/server/dist/*.js"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里贴一下 vscode debug 的官方介绍：<a href="https://code.visualstudio.com/docs/nodejs/nodejs-debugging" target="_blank" rel="noopener">node debug in vscode</a></p>
<h3 id="inspector"><a href="#inspector" class="headerlink" title="inspector"></a>inspector</h3><p>这个 node 自带的就不要考虑了，太麻烦了。</p>
<h3 id="Chrome-55-开发工具"><a href="#Chrome-55-开发工具" class="headerlink" title="Chrome(55+) 开发工具"></a>Chrome(55+) 开发工具</h3><blockquote>
<p>版本：<br>Node.js 6.3+<br>Chrome 55+</p>
</blockquote>
<p>Chrome 打开：chrome://inspect<br>启动 node：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node --inspect-brk app.js  <span class="comment">// 在程序开头停止</span></span><br><span class="line">node --inspect app.js      <span class="comment">// 不会在程序开头停止</span></span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> node </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[谈谈hook]]></title>
      <url>https://skhon.github.io/2020/01/03/hook-js/</url>
      <content type="html"><![CDATA[<h2 id="什么是-hook"><a href="#什么是-hook" class="headerlink" title="什么是 hook"></a>什么是 hook</h2><p>概括的说：hook 是将一系列要执行的动作注册到一个统一的入口，程序通过调用 hook 来执行注册的动作。而一般执行 hook 的常规做法（并不是所有的 hook 都是这么调用的）是通过匹配的方式来执行。<a id="more"></a><br>我们可以先从匹配机制说起，先举个简单的例子。比如，前端和后端联调的时候，后端在 response 的时候，会给你返回各种状态码，你可以根据不同的状态码来分别进行前端的不同操作。这种逻辑，大多数同学会想到条件语句来实现:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (code === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Ok"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (code === <span class="number">500</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Internal server error"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (code === <span class="number">404</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Not found"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然也可以用 switch 来实现。那我们这里可以用 hook 来实现的话，就感觉代码很优雅，并且执行效率也相对快一些。我们可以把所有可能的 code 放在一个 list 中，code 作为 key，对应的内容作为 value，然后来进行匹配。代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> codeList = &#123;</span><br><span class="line">    <span class="number">200</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Ok"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">404</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Not founnd"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">500</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Internal server error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    codeList[input]();</span><br><span class="line">&#125;</span><br><span class="line">print(<span class="number">200</span>);</span><br></pre></td></tr></table></figure>
<p>上述程序运行结果为：”Ok”，那输出 Ok 的这个操作就是一个 hook，我们一共有三个 hook，而 print 为一个主流程，我们为这个主流程里面插入的我们注册的操作，就是 hook。再来一张丑图：<br><img src="/images/hook01.png" alt="hook 图解"><br>start-&gt;end 是一个完整的流程，我们需要在这个流程里面插入我们想要自己实现的功能，就可以将这些功能先注册到一个数组中，然后调用的时候，可以 Array[key]这种方式，执行我们的 hook。</p>
<h2 id="js-中的函数劫持"><a href="#js-中的函数劫持" class="headerlink" title="js 中的函数劫持"></a>js 中的函数劫持</h2><p>劫持的意思，大家都懂，在程序中的劫持，可以理解在一个常规的程序流程中，可以插入一些我们自己想执行的一些操作，进而改变整个过程。举个简单的例子，比如，我想劫持 alert，可以这么做：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _alert = alert;</span><br><span class="line"><span class="built_in">window</span>.alert = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Hooked!"</span>);</span><br><span class="line">    _alert(s);</span><br><span class="line">&#125;;</span><br><span class="line">alert(<span class="string">"hello world"</span>);</span><br></pre></td></tr></table></figure>
<p>这个过程可以理解为：先保存原来的 alert，然后重写 alert，这样在执行 alert 的时候，就是执行的重写之后的。那么重写的过程我们可以不暴露出来，那么对于用 alert 的用户来说，好像和以前的执行结果不太一样了。这就是<code>alert 函数被劫持了</code>。<br>我们可以再联想一下 hook 思想，hook 就是在一个完整流程中，插入我们想要实现的功能，那么原本的 alert 就是一个完整的执行流程，我们执行它，就是弹一个对话框，但是上面的例子展示了，在 alert 中添加了一条 console.log(“Hooked!”)这样的语句，这就是 hook 的思想。</p>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
