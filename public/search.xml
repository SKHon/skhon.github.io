<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[整理一下正则]]></title>
      <url>https://skhon.github.io/2020/03/21/regexp/</url>
      <content type="html"><![CDATA[<h2 id="字面量字符和元字符"><a href="#字面量字符和元字符" class="headerlink" title="字面量字符和元字符"></a>字面量字符和元字符</h2><p><code>字面量字符</code>： 写的啥就匹配啥。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dog/.test(&apos;old dog&apos;) // true</span><br></pre></td></tr></table></figure></p>
<p><code>点字符(.)</code>：匹配一个除回车（\r）、换行(\n) 、行分隔符（\u2028）和段分隔符（\u2029）以外的所有字符<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/c.t/.test(&apos;cst&apos;) // true</span><br><span class="line">/c.t/.test(&apos;c\nt&apos;) // false</span><br></pre></td></tr></table></figure></p>
<p><code>位置字符(^ 和 $)</code>：^ 表示字符串的开始位置，$ 表示字符串的结束位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/^test/.test(&apos;test123&apos;) // true</span><br><span class="line">/test$/.test(&apos;new test&apos;) // true</span><br><span class="line">/^test$/.test(&apos;test&apos;) // true</span><br><span class="line">/^test$/.test(&apos;test test&apos;) // false</span><br></pre></td></tr></table></figure></p>
<p><code>选择符（|）</code>:表示“或关系”（OR），即cat|dog表示匹配cat或dog。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 正则表达式指定必须匹配11或22。</span><br><span class="line">/11|22/.test(&apos;911&apos;) // true</span><br><span class="line"></span><br><span class="line">/a(1|2)b/.test(&apos;a1b&apos;) // true</span><br></pre></td></tr></table></figure></p>
<h2 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h2><p>需要反斜杠转义的，一共有12个字符：^、.、[、$、(、)、|、*、+、?、{和\。需要特别注意的是，如果使用RegExp方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。</p>
<h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><p>\cX     表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符。<br>[\b]    匹配退格键(U+0008)，不要与\b混淆。<br>\n      匹配换行键。<br>\r      匹配回车键。<br>\t      匹配制表符 tab（U+0009）。<br>\v      匹配垂直制表符（U+000B）。<br>\f      匹配换页符（U+000C）。<br>\0      匹配null字符（U+0000）。<br>\xhh    匹配一个以两位十六进制数（\x00-\xFF）表示的字符。<br>\uhhhh  匹配一个以四位十六进制数（\u0000-\uFFFF）表示的 Unicode 字符。</p>
<h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类 []"></a>字符类 []</h2><p>字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[xyz] 表示x、y、z之中任选一个匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/[abc]/.test(&apos;hello world&apos;) // false </span><br><span class="line">/[abc]/.test(&apos;apple&apos;) // true</span><br></pre></td></tr></table></figure>
<h3 id="脱字符"><a href="#脱字符" class="headerlink" title="脱字符 ^"></a>脱字符 ^</h3><p>如果方括号内的第一个字符是[^]，则表示除了字符类之中的字符，其他字符都可以匹配。比如，[^xyz]表示除了x、y、z之外都可以匹配。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/[^abc]/.test(&apos;hello world&apos;) // true</span><br><span class="line">/[^abc]/.test(&apos;bbc&apos;) // false</span><br></pre></td></tr></table></figure></p>
<p>如果方括号内没有其他字符，即只有[^]，就表示匹配一切字符，其中包括换行符。相比之下，点号作为元字符（.）是不包括换行符的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;Please yes\nmake my day!&apos;;</span><br><span class="line"></span><br><span class="line">s.match(/yes.*day/) // null</span><br><span class="line">s.match(/yes[^]*day/) // [ &apos;yes\nmake my day&apos;]</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在[]中，^只有在第一位才标示非，否则就是字面量<br>在[]中，.就是字面量</p>
</blockquote>
<h3 id="连字符"><a href="#连字符" class="headerlink" title="连字符 -"></a>连字符 -</h3><p>某些情况下，对于连续序列的字符，连字符（-）用来提供简写形式，表示字符的连续范围。比如，[abc]可以写成[a-c]，[0123456789]可以写成[0-9]，同理[A-Z]表示26个大写字母。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/a-z/.test(&apos;b&apos;) // false</span><br><span class="line">/[a-z]/.test(&apos;b&apos;) // true</span><br></pre></td></tr></table></figure></p>
<h2 id="预定义模式"><a href="#预定义模式" class="headerlink" title="预定义模式"></a>预定义模式</h2><p>\d 匹配0-9之间的任一数字，相当于[0-9]。<br>\D 匹配所有0-9以外的字符，相当于[^0-9]。<br>\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。<br>\W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。<br>\s 匹配空格（包括换行符、制表符、空格符等），相等于[ \t\r\n\v\f]。<br>\S 匹配非空格的字符，相当于[^ \t\r\n\v\f]。<br>\b 匹配词的边界。<br>\B 匹配非词边界，即在词的内部。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// \s 的例子</span><br><span class="line">/\s\w*/.exec(&apos;hello world&apos;) // [&quot; world&quot;]</span><br><span class="line"></span><br><span class="line">// \b 的例子</span><br><span class="line">/\bworld/.test(&apos;hello world&apos;) // true</span><br><span class="line">/\bworld/.test(&apos;hello-world&apos;) // true</span><br><span class="line">/\bworld/.test(&apos;helloworld&apos;) // false</span><br><span class="line"></span><br><span class="line">// \B 的例子</span><br><span class="line">/\Bworld/.test(&apos;hello-world&apos;) // false</span><br><span class="line">/\Bworld/.test(&apos;helloworld&apos;) // true</span><br></pre></td></tr></table></figure>
<h2 id="重复类"><a href="#重复类" class="headerlink" title="重复类 {}"></a>重复类 {}</h2><p>模式的精确匹配次数，使用大括号（{}）表示。{n}表示恰好重复n次，{n,}表示至少重复n次，{n,m}表示重复不少于n次，不多于m次。</p>
<h3 id="量词符"><a href="#量词符" class="headerlink" title="量词符"></a>量词符</h3><p>? 问号表示某个模式出现0次或1次，等同于{0, 1}。<br>* 星号表示某个模式出现0次或多次，等同于{0,}。<br>+ 加号表示某个模式出现1次或多次，等同于{1,}。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// t 出现0次或1次</span><br><span class="line">/t?est/.test(&apos;test&apos;) // true</span><br><span class="line">/t?est/.test(&apos;est&apos;) // true</span><br><span class="line"></span><br><span class="line">// t 出现1次或多次</span><br><span class="line">/t+est/.test(&apos;test&apos;) // true</span><br><span class="line">/t+est/.test(&apos;ttest&apos;) // true</span><br><span class="line">/t+est/.test(&apos;est&apos;) // false</span><br><span class="line"></span><br><span class="line">// t 出现0次或多次</span><br><span class="line">/t*est/.test(&apos;test&apos;) // true</span><br><span class="line">/t*est/.test(&apos;ttest&apos;) // true</span><br><span class="line">/t*est/.test(&apos;tttest&apos;) // true</span><br><span class="line">/t*est/.test(&apos;est&apos;) // true</span><br></pre></td></tr></table></figure>
<h2 id="贪婪模式"><a href="#贪婪模式" class="headerlink" title="贪婪模式"></a>贪婪模式</h2><p>上一小节的三个量词符，默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;aaa&apos;;</span><br><span class="line">s.match(/a+/) // [&quot;aaa&quot;]</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，模式是/a+/，表示匹配1个a或多个a，那么到底会匹配几个a呢？因为默认是贪婪模式，会一直匹配到字符a不出现为止，所以匹配结果是3个a。</p>
<p>如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;aaa&apos;;</span><br><span class="line">s.match(/a+?/) // [&quot;a&quot;]</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>*?：表示某个模式出现0次或多次，匹配时采用非贪婪模式。<br>+?：表示某个模式出现1次或多次，匹配时采用非贪婪模式。</p>
</blockquote>
<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><h3 id="g修饰符"><a href="#g修饰符" class="headerlink" title="g修饰符"></a>g修饰符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var regex = /b/;</span><br><span class="line">var str = &apos;abba&apos;;</span><br><span class="line"></span><br><span class="line">regex.test(str); // true</span><br><span class="line">regex.test(str); // true</span><br><span class="line">regex.test(str); // true</span><br></pre></td></tr></table></figure>
<p>上面代码中，正则模式不含g修饰符，每次都是从字符串头部开始匹配。所以，连续做了三次匹配，都返回true。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var regex = /b/g;</span><br><span class="line">var str = &apos;abba&apos;;</span><br><span class="line"></span><br><span class="line">regex.test(str); // true</span><br><span class="line">regex.test(str); // true</span><br><span class="line">regex.test(str); // false</span><br></pre></td></tr></table></figure>
<p>上面代码中，正则模式含有g修饰符，每次都是从上一次匹配成功处，开始向后匹配。因为字符串abba只有两个b，所以前两次匹配结果为true，第三次匹配结果为false。</p>
<h3 id="i-修饰符"><a href="#i-修饰符" class="headerlink" title="i 修饰符"></a>i 修饰符</h3><p>默认情况下，正则对象区分字母的大小写，加上i修饰符以后表示忽略大小写（ignorecase）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/abc/.test(&apos;ABC&apos;) // false</span><br><span class="line">/abc/i.test(&apos;ABC&apos;) // true</span><br></pre></td></tr></table></figure></p>
<h3 id="m-修饰符"><a href="#m-修饰符" class="headerlink" title="m 修饰符"></a>m 修饰符</h3><p>m修饰符表示多行模式（multiline），会修改^和$的行为。默认情况下（即不加m修饰符时），^和$匹配字符串的开始处和结尾处，加上m修饰符以后，^和$还会匹配行首和行尾，即^和$会识别换行符（\n）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/world$/.test(&apos;hello world\n&apos;) // false</span><br><span class="line">/world$/m.test(&apos;hello world\n&apos;) // true</span><br></pre></td></tr></table></figure></p>
<h2 id="组匹配"><a href="#组匹配" class="headerlink" title="组匹配 ()"></a>组匹配 ()</h2><p>括号有两个功能，分别是分组和引用</p>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>量词控制之前元素的出现次数，而这个元素可能是一个字符，也可能是一个字符组，也可以是一个表达式</p>
<p>如果把一个表达式用括号包围起来，这个元素就是括号里的表达式，被称为子表达式</p>
<p>如果希望字符串’ab’重复出现2次，应该写为(ab){2}，而如果写为ab{2}，则{2}只限定b<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(/(ab)&#123;2&#125;/.test(&apos;abab&apos;)); //true</span><br><span class="line">console.log(/(ab)&#123;2&#125;/.test(&apos;abb&apos;)); //false</span><br><span class="line">console.log(/ab&#123;2&#125;/.test(&apos;abab&apos;)); //false</span><br><span class="line">console.log(/ab&#123;2&#125;/.test(&apos;abb&apos;)); //true</span><br></pre></td></tr></table></figure></p>
<h3 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h3><p>括号不仅可以对元素进行分组，还会保存每个分组匹配的文本，等到匹配完成后，引用捕获的内容。因为捕获了文本，这种功能叫捕获分组<br>比如，要匹配诸如2016-06-23这样的日期字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span><br><span class="line"></span><br><span class="line">console.log(/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/.test(&apos;2016-06-23&apos;));//true</span><br><span class="line">console.log(RegExp.$1);//&apos;2016&apos;</span><br><span class="line">console.log(RegExp.$2);//&apos;06&apos;</span><br><span class="line">console.log(RegExp.$3);//&apos;23&apos;</span><br><span class="line">console.log(RegExp.$4);//&apos;&apos;</span><br></pre></td></tr></table></figure></p>
<h3 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h3><p>反向引用允许在正则表达式内部引用之前捕获分组匹配的文本，形式是\num，num表示所引用分组的编号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//重复字母</span><br><span class="line">/([a-z])\1/</span><br><span class="line">console.log(/([a-z])\1/.test(&apos;aa&apos;));//true</span><br><span class="line">console.log(/([a-z])\1/.test(&apos;ab&apos;));//false</span><br></pre></td></tr></table></figure></p>
<h3 id="非捕获"><a href="#非捕获" class="headerlink" title="非捕获"></a>非捕获</h3><p>除了捕获分组，正则表达式还提供了非捕获分组(non-capturing group)，以(?:)的形式表示，它只用于限定作用范围，而不捕获任何文本<br>比如，要匹配abcabc这个字符，一般地，可以写为(abc){2}，但由于并不需要捕获文本，只是限定了量词的作用范围，所以应该写为(?:abc){2}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(/(abc)&#123;2&#125;/.test(&apos;abcabc&apos;));//true</span><br><span class="line">console.log(/(?:abc)&#123;2&#125;/.test(&apos;abcabc&apos;));//true</span><br></pre></td></tr></table></figure></p>
<p>由于非捕获分组不捕获文本，对应地，也就没有捕获组编号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(/(abc)&#123;2&#125;/.test(&apos;abcabc&apos;));//true</span><br><span class="line">console.log(RegExp.$1);//&apos;abc&apos;</span><br><span class="line">console.log(/(?:abc)&#123;2&#125;/.test(&apos;abcabc&apos;));//true</span><br><span class="line">console.log(RegExp.$1);//&apos;&apos;</span><br></pre></td></tr></table></figure></p>
<p>非捕获分组也不可以使用反向引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/(?:123)\1/.test(&apos;123123&apos;);//false</span><br><span class="line">/(123)\1/.test(&apos;123123&apos;);//true</span><br></pre></td></tr></table></figure></p>
<p>捕获分组和非捕获分组可以在一个正则表达式中同时出现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(/(\d)(\d)(?:\d)(\d)(\d)/.exec(&apos;12345&apos;));//[&quot;12345&quot;, &quot;1&quot;, &quot;2&quot;, &quot;4&quot;, &quot;5&quot;]</span><br></pre></td></tr></table></figure></p>
<h3 id="先行断言"><a href="#先行断言" class="headerlink" title="先行断言"></a>先行断言</h3><p>x(?=y)称为先行断言（Positive look-ahead），x只有在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成/\d+(?=%)/。“先行断言”中，括号里的部分是不会返回的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var m = &apos;abc&apos;.match(/b(?=c)/);</span><br><span class="line">m // [&quot;b&quot;]</span><br></pre></td></tr></table></figure></p>
<h3 id="先行否定断言"><a href="#先行否定断言" class="headerlink" title="先行否定断言"></a>先行否定断言</h3><p>x(?!y)称为先行否定断言（Negative look-ahead），x只有不在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成/\d+(?!%)/。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/\d+(?!\.)/.exec(&apos;3.14&apos;)</span><br><span class="line">// [&quot;14&quot;]</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[整理一下hobber]]></title>
      <url>https://skhon.github.io/2020/03/04/hobber/</url>
      <content type="html"><![CDATA[<h2 id="安装-hobber"><a href="#安装-hobber" class="headerlink" title="安装 hobber"></a>安装 hobber</h2><ol>
<li>全局安装 hobber-cli</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install @ke/hobber-cli -g --registry=http://registry.npmjs.lianjia.com:7001</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<blockquote>
<p>note: hobber-cli 官网：<a href="http://registry.npmjs.lianjia.com/package/@ke/hobber-cli" target="_blank" rel="noopener">http://registry.npmjs.lianjia.com/package/@ke/hobber-cli</a></p>
</blockquote>
<ol start="2">
<li>利用 hobber-cli 创建一个 hobber 项目</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hobber new hobber-test</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>安装依赖</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd hobber-test</span><br><span class="line">$ npm i --registry=http://registry.npmjs.lianjia.com:7001</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>本地启动</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run dev</span><br></pre></td></tr></table></figure>
<h2 id="调试-hobber"><a href="#调试-hobber" class="headerlink" title="调试 hobber"></a>调试 hobber</h2><p>目前这里有两种调试方法：</p>
<ol>
<li><p>可以通过自己打日志 console</p>
</li>
<li><p>可以配置 vscode，来进行调试</p>
</li>
</ol>
<p>launch.json 配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // 使用 IntelliSense 了解相关属性。</span><br><span class="line">  // 悬停以查看现有属性的描述。</span><br><span class="line">  // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span><br><span class="line">  &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">  &quot;configurations&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;node&quot;,</span><br><span class="line">      &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;debug&quot;,</span><br><span class="line">      &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/src/index.ts&quot;,</span><br><span class="line">      &quot;outFiles&quot;: [&quot;$&#123;workspaceFolder&#125;/**/*.js&quot;],</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="hobber-使用"><a href="#hobber-使用" class="headerlink" title="hobber 使用"></a>hobber 使用</h2><h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><ul>
<li>创建一个 action</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hobber action /project/list</span><br></pre></td></tr></table></figure>
<ul>
<li>配置是否需要登录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line"></span><br><span class="line">  // 是否页面需要登陆 默认需要登陆</span><br><span class="line">  // 具体逻辑在 configs/action 的 beforeHandler 中体现</span><br><span class="line">  needLogin: false,</span><br><span class="line"></span><br><span class="line">  async handler(ctx: Context) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#125; as ActionConfig</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> node </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript Errors and Stack Traces]]></title>
      <url>https://skhon.github.io/2020/02/26/js-stack-trace/</url>
      <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>今天将讨论错误和堆栈跟踪以及如何处理它们。</p>
<p>有时人们不会关注这些细节，但是，如果您正在编写与测试或错误相关的任何库，那么这些知识无疑会很有用。<a id="more"></a> 例如，本周在 Chai，我们有一个很棒的 Pull Request，它极大地改善了我们处理堆栈跟踪的方式，以便用户在断言失败时获得更多信息。</p>
<p>通过操作堆栈跟踪，您可以清理无用的数据并集中精力处理重要的事情。 同样，在了解错误的确切含义及其属性后，您会更加自信地利用它。</p>
<p>这篇博客文章在开始时似乎太明显了，但是当我们开始操作堆栈跟踪时，它变得非常复杂，因此在移至该部分之前，请确保您对以前的内容有充分的了解。</p>
<h2 id="调用堆栈如何工作"><a href="#调用堆栈如何工作" class="headerlink" title="调用堆栈如何工作"></a>调用堆栈如何工作</h2><p>在讨论错误之前，我们必须了解调用堆栈的工作方式。 这确实很简单，但是在继续之前必须知道这一点。 如果您已经知道这一点，请随时跳过此部分。</p>
<p>每当有一个函数调用时，它就会被推到栈顶。 完成运行后，将其从堆栈顶部移除。</p>
<p>关于此数据结构的有趣之处在于，最后输入的将是第一个输出的数据。 这称为 LIFO（后进先出）属性。</p>
<p>这意味着，例如，当从函数 x 内部调用函数 y 时，我们将具有依次包含 x 和 y 的堆栈。</p>
<p>让我再举一个例子，假设您有以下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"c"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"b"</span>);</span><br><span class="line">  c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"a"</span>);</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a();</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，当运行 a 时，它将被添加到我们堆栈的顶部。 然后，当 b 从 a 内部被调用时，它被推入堆栈的顶部。 从 b 调用 c 时，也是如此。</p>
<p>运行 c 时，我们的堆栈跟踪将按此顺序包含 a，b 和 c。</p>
<p>一旦 c 完成运行，它就会从堆栈顶部移走，然后控制流回到 b。 当 b 完成时，它也将从堆栈中删除，现在我们将控件放回 a。 最后，当完成运行时，它也会从堆栈中删除。</p>
<p>为了更好地演示此行为，我们将使用 console.trace（），它将当前的堆栈跟踪信息打印到控制台。 同样，您通常应该从上至下读取堆栈跟踪。 将每行视为从其下一行内部调用的内容。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"c"</span>);</span><br><span class="line">  <span class="built_in">console</span>.trace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"b"</span>);</span><br><span class="line">  c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"a"</span>);</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a();</span><br></pre></td></tr></table></figure>
<p>在 Node REPL 服务器中运行此命令时，我们会得到以下信息：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Trace</span><br><span class="line">    at c (repl:<span class="number">3</span>:<span class="number">9</span>)</span><br><span class="line">    at b (repl:<span class="number">3</span>:<span class="number">1</span>)</span><br><span class="line">    at a (repl:<span class="number">3</span>:<span class="number">1</span>)</span><br><span class="line">    at repl:<span class="number">1</span>:<span class="number">1</span> <span class="comment">// &lt;-- For now feel free to ignore anything below this point, these are Node's internals</span></span><br><span class="line">    at realRunInThisContextScript (vm.js:<span class="number">22</span>:<span class="number">35</span>)</span><br><span class="line">    at sigintHandlersWrap (vm.js:<span class="number">98</span>:<span class="number">12</span>)</span><br><span class="line">    at ContextifyScript.Script.runInThisContext (vm.js:<span class="number">24</span>:<span class="number">12</span>)</span><br><span class="line">    at REPLServer.defaultEval (repl.js:<span class="number">313</span>:<span class="number">29</span>)</span><br><span class="line">    at bound (domain.js:<span class="number">280</span>:<span class="number">14</span>)</span><br><span class="line">    at REPLServer.runBound [<span class="keyword">as</span> <span class="built_in">eval</span>] (domain.js:<span class="number">293</span>:<span class="number">12</span>)</span><br></pre></td></tr></table></figure>
<p>正如我们在这里看到的，当从 c 内部打印堆栈时，我们有 a，b 和 c。</p>
<p>现在，如果在 c 完成运行之后从 b 内部打印堆栈跟踪，我们将能够看到它已从堆栈顶部删除，因此我们只有 a 和 b。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"c"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"b"</span>);</span><br><span class="line">  c();</span><br><span class="line">  <span class="built_in">console</span>.trace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"a"</span>);</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a();</span><br></pre></td></tr></table></figure>
<p>如您所见，我们的堆栈中不再有 c，因为它已经完成运行并已弹出。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Trace</span><br><span class="line">    at b (repl:<span class="number">4</span>:<span class="number">9</span>)</span><br><span class="line">    at a (repl:<span class="number">3</span>:<span class="number">1</span>)</span><br><span class="line">    at repl:<span class="number">1</span>:<span class="number">1</span>  <span class="comment">// &lt;-- For now feel free to ignore anything below this point, these are Node's internals</span></span><br><span class="line">    at realRunInThisContextScript (vm.js:<span class="number">22</span>:<span class="number">35</span>)</span><br><span class="line">    at sigintHandlersWrap (vm.js:<span class="number">98</span>:<span class="number">12</span>)</span><br><span class="line">    at ContextifyScript.Script.runInThisContext (vm.js:<span class="number">24</span>:<span class="number">12</span>)</span><br><span class="line">    at REPLServer.defaultEval (repl.js:<span class="number">313</span>:<span class="number">29</span>)</span><br><span class="line">    at bound (domain.js:<span class="number">280</span>:<span class="number">14</span>)</span><br><span class="line">    at REPLServer.runBound [<span class="keyword">as</span> <span class="built_in">eval</span>] (domain.js:<span class="number">293</span>:<span class="number">12</span>)</span><br><span class="line">    at REPLServer.onLine (repl.js:<span class="number">513</span>:<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>简而言之：您调用事物，它们就会被推到栈顶。 当他们完成运行时，它们会弹出。 就那么简单。</p>
<h2 id="错误对象和错误处理"><a href="#错误对象和错误处理" class="headerlink" title="错误对象和错误处理"></a>错误对象和错误处理</h2><p>当发生错误时，通常会抛出一个 Error 对象。 错误对象也可以用作想要扩展它并创建自己的错误的用户的原型。</p>
<p>Error.prototype 对象通常具有以下属性：</p>
<ul>
<li>constructor - The constructor function responsible for this instance’s prototype.</li>
<li>message - An error message.</li>
<li>name - The error’s name.</li>
</ul>
<p>这些是标准属性，有时每个环境都有其自己的特定属性。 在某些环境中，例如 Node，Firefox，Chrome，Edge，IE 10 +，Opera 和 Safari 6+，我们甚至拥有 stack 属性，其中包含错误的堆栈跟踪。 错误的堆栈跟踪包含所有堆栈帧，直到其自己的构造函数为止。</p>
<p>如果您想阅读有关 Error 对象的特定属性的更多信息，我强烈建议您阅读有关 MDN 的文章。</p>
<p>要抛出错误，必须使用 throw 关键字。 为了捕获引发的错误，必须将可能引发错误的代码包装到 try 块中，然后再放入 catch 块。 Catch 还接受一个参数，即抛出的错误。</p>
<p>正如 Java 中所发生的那样，JavaScript 还允许您在 try / catch 块之后运行一个 finally 块，而不管您的 try 块是否抛出错误。 处理完毕后，最好使用最后清理的东西，无论您的操作是否有效。</p>
<p>到目前为止，对于大多数人来说，一切都是显而易见的，所以让我们来谈谈一些不重要的细节。</p>
<p>您可以使用 try 块，但不要在 catch 后面，但是必须在它们后面紧跟着。 这意味着我们可以使用三种不同形式的 try 语句：</p>
<ul>
<li>try…catch</li>
<li>try…finally</li>
<li>try…catch…finally</li>
</ul>
<p>try 语句可以嵌套在其他 try 语句中，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Nested error."</span>); <span class="comment">// The error thrown here will be caught by its own `catch` clause</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (nestedErr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Nested catch"</span>); <span class="comment">// This runs</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"This will not run."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您还可以将 try 语句嵌套到 catch 和 finally 块中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"First error"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"First catch running"</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Second error"</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (nestedErr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Second catch running."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"The try block is running..."</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Error inside finally."</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Caught an error inside the finally block."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请务必注意，您还可以抛出不是 Error 对象的值，这一点也很重要。 尽管这看起来很酷，但实际上并没有那么好，尤其是对于那些使用必须处理其他人的代码的库的开发人员而言，因为那时没有标准，而且您永远都不知道用户会期望什么。 您不能仅仅因为它们选择不这样做而仅仅抛出一个字符串或一个数字就相信它们会引发 Error 对象。 如果您需要处理堆栈跟踪和其他有意义的元数据，这也将变得更加困难。</p>
<p>假设您有以下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runWithoutThrowing</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    func();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"There was an error, but I will not throw it."</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"The error's message was: "</span> + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcThatThrowsError</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"I am a TypeError."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runWithoutThrowing(funcThatThrowsError);</span><br></pre></td></tr></table></figure>
<p>如果您的用户正在传递将 Error 对象抛出到您的 runWithoutThrowing 函数的函数，这将非常有用。 但是，如果它们最终抛出一个 String，那么您可能会遇到麻烦：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runWithoutThrowing</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    func();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"There was an error, but I will not throw it."</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"The error's message was: "</span> + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcThatThrowsString</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">"I am a String."</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runWithoutThrowing(funcThatThrowsString);</span><br></pre></td></tr></table></figure>
<p>现在，您的第二个 console.log 将显示错误消息未定义。 现在这似乎并不重要，但是如果您需要确保某个 Error 对象上存在某些属性或以另一种方式处理特定于 Error 的属性（例如 Chai 的 throws 断言确实需要），则您需要做更多的工作来确保它可以工作 对。</p>
<p>另外，当抛出不是 Error 对象的值时，您将无权访问其他重要数据，例如堆栈，这是 Error 对象在某些环境中具有的属性。</p>
<p>错误也可以用作任何其他对象，您不一定需要将其引发，这就是为什么它们多次被用作回调函数的第一个参数的原因，例如 fs.readdir 函数就是这种情况。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line">fs.readdir(<span class="string">"/example/i-do-not-exist"</span>, <span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">err, dirs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err <span class="keyword">instanceof</span> <span class="built_in">Error</span>) &#123;</span><br><span class="line">    <span class="comment">// `readdir` will throw an error because that directory does not exist</span></span><br><span class="line">    <span class="comment">// We will now be able to use the error object passed by it in our callback function</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Error Message: "</span> + err.message);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"See? We can use Errors without using try statements."</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(dirs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>最后但并非最不重要的一点是，在拒绝承诺时也可以使用 Error 对象。 这使得处理承诺拒绝更容易：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"The promise was rejected."</span>));</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"I am an error."</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err <span class="keyword">instanceof</span> <span class="built_in">Error</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"The promise was rejected with an error."</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"Error Message: "</span> + err.message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="操纵堆栈跟踪"><a href="#操纵堆栈跟踪" class="headerlink" title="操纵堆栈跟踪"></a>操纵堆栈跟踪</h2><p>现在，您一直在等待的部分：如何操作堆栈跟踪。</p>
<p>本章专门针对支持 Error.captureStackTrace 的环境（例如 NodeJS）。</p>
<p>Error.captureStackTrace 函数将一个对象作为第一个参数，并可选地将一个函数作为第二个参数。 捕获堆栈跟踪的作用是（显然）捕获当前堆栈跟踪，并在目标对象中创建一个堆栈属性来存储它。 如果提供了第二个参数，则传递的函数将被视为调用堆栈的终点，因此，堆栈跟踪将仅显示在调用此函数之前发生的调用。</p>
<p>让我们使用一些示例来更清楚地说明这一点。 首先，我们将捕获当前的堆栈跟踪并将其存储在一个公共对象中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Here we will store the current stack trace into myObj</span></span><br><span class="line">  <span class="built_in">Error</span>.captureStackTrace(myObj);</span><br><span class="line">  c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// First we will call these functions</span></span><br><span class="line">a();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now let's see what is the stack trace stored into myObj.stack</span></span><br><span class="line"><span class="built_in">console</span>.log(myObj.stack);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This will print the following stack to the console:</span></span><br><span class="line"><span class="comment">//    at b (repl:3:7) &lt;-- Since it was called inside B, the B call is the last entry in the stack</span></span><br><span class="line"><span class="comment">//    at a (repl:2:1)</span></span><br><span class="line"><span class="comment">//    at repl:1:1 &lt;-- Node internals below this line</span></span><br><span class="line"><span class="comment">//    at realRunInThisContextScript (vm.js:22:35)</span></span><br><span class="line"><span class="comment">//    at sigintHandlersWrap (vm.js:98:12)</span></span><br><span class="line"><span class="comment">//    at ContextifyScript.Script.runInThisContext (vm.js:24:12)</span></span><br><span class="line"><span class="comment">//    at REPLServer.defaultEval (repl.js:313:29)</span></span><br><span class="line"><span class="comment">//    at bound (domain.js:280:14)</span></span><br><span class="line"><span class="comment">//    at REPLServer.runBound [as eval] (domain.js:293:12)</span></span><br><span class="line"><span class="comment">//    at REPLServer.onLine (repl.js:513:10)</span></span><br></pre></td></tr></table></figure>
<p>您可以在上面的示例中注意到，我们首先调用 a（将其推入堆栈），然后从 a 内部调用 b（将其推入 a 顶部）。 然后，在 b 内部，我们捕获了当前的堆栈跟踪并将其存储到 myObj 中。 这就是为什么我们在打印到控制台的堆栈中只得到 a 然后再得到 b 的原因。</p>
<p>现在，将一个函数作为第二个参数传递给 Error.captureStackTrace 函数，看看会发生什么：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Here we will store the current stack trace into myObj</span></span><br><span class="line">  <span class="comment">// This time we will hide all the frames after `b` and `b` itself</span></span><br><span class="line">  <span class="built_in">Error</span>.captureStackTrace(myObj, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  d();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// First we will call these functions</span></span><br><span class="line">a();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now let's see what is the stack trace stored into myObj.stack</span></span><br><span class="line"><span class="built_in">console</span>.log(myObj.stack);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This will print the following stack to the console:</span></span><br><span class="line"><span class="comment">//    at a (repl:2:1) &lt;-- As you can see here we only get frames before `b` was called</span></span><br><span class="line"><span class="comment">//    at repl:1:1 &lt;-- Node internals below this line</span></span><br><span class="line"><span class="comment">//    at realRunInThisContextScript (vm.js:22:35)</span></span><br><span class="line"><span class="comment">//    at sigintHandlersWrap (vm.js:98:12)</span></span><br><span class="line"><span class="comment">//    at ContextifyScript.Script.runInThisContext (vm.js:24:12)</span></span><br><span class="line"><span class="comment">//    at REPLServer.defaultEval (repl.js:313:29)</span></span><br><span class="line"><span class="comment">//    at bound (domain.js:280:14)</span></span><br><span class="line"><span class="comment">//    at REPLServer.runBound [as eval] (domain.js:293:12)</span></span><br><span class="line"><span class="comment">//    at REPLServer.onLine (repl.js:513:10)</span></span><br><span class="line"><span class="comment">//    at emitOne (events.js:101:20)</span></span><br></pre></td></tr></table></figure>
<p>当我们将 b 传递给 Error.captureStackTraceFunction 时，它会将 b 自身及其上方的所有帧都隐藏起来。 这就是为什么我们在堆栈跟踪中仅包含一个的原因。</p>
<p>现在您可能会问自己：“为什么这样做有用？”。 这很有用，因为您可以使用它来隐藏与用户无关的内部实现细节。 例如，在 Chai 中，我们使用它来避免向用户显示与我们自己实现检查和断言的方式无关的细节。</p>
<h2 id="现实世界中的堆栈跟踪操作"><a href="#现实世界中的堆栈跟踪操作" class="headerlink" title="现实世界中的堆栈跟踪操作"></a>现实世界中的堆栈跟踪操作</h2><p>正如我在上一节中提到的，Chai 使用堆栈操纵技术使堆栈跟踪与我们的用户更加相关。 这是我们的方法。</p>
<p>首先，让我们看一下断言失败时抛出的 AssertionError 构造函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `ssfi` stands for "start stack function". It is the reference to the</span></span><br><span class="line"><span class="comment">// starting point for removing irrelevant frames from the stack trace</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AssertionError</span>(<span class="params">message, _props, ssf</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> extend = exclude(<span class="string">"name"</span>, <span class="string">"message"</span>, <span class="string">"stack"</span>, <span class="string">"constructor"</span>, <span class="string">"toJSON"</span>),</span><br><span class="line">    props = extend(_props || &#123;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Default values</span></span><br><span class="line">  <span class="keyword">this</span>.message = message || <span class="string">"Unspecified AssertionError"</span>;</span><br><span class="line">  <span class="keyword">this</span>.showDiff = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy from properties</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">    <span class="keyword">this</span>[key] = props[key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Here is what is relevant for us:</span></span><br><span class="line">  <span class="comment">// If a start stack function was provided we capture the current stack trace and pass</span></span><br><span class="line">  <span class="comment">// it to the `captureStackTrace` function so we can remove frames that come after it</span></span><br><span class="line">  ssf = ssf || <span class="built_in">arguments</span>.callee;</span><br><span class="line">  <span class="keyword">if</span> (ssf &amp;&amp; <span class="built_in">Error</span>.captureStackTrace) &#123;</span><br><span class="line">    <span class="built_in">Error</span>.captureStackTrace(<span class="keyword">this</span>, ssf);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// If no start stack function was provided we just use the original stack property</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">this</span>.stack = e.stack;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，我们使用 Error.captureStackTrace 捕获堆栈跟踪并将其存储到我们正在构建的 AssertionError 实例中（如果存在），我们将向其传递一个起始堆栈函数，以从中删除无关帧 堆栈跟踪，仅显示 Chai 的内部实现细节，最终使堆栈“变脏”。</p>
<p>现在，让我们看一下@meeber 在此出色的 PR 中编写的最新代码。</p>
<p>在查看下面的代码之前，我必须告诉您 addChainableMethod 的作用。 它将传递给它的可链接方法添加到断言中，并且还使用包装断言的方法标记断言本身。 它以名称 ssfi（代表启动堆栈功能指示器）存储。 这基本上意味着当前断言将是堆栈中的最后一帧，因此我们将在堆栈中不再显示 Chai 的其他内部方法。 我避免为此添加完整的代码，因为它可以完成很多事情并且有点棘手，但是如果您想阅读它，请转到此处的链接。</p>
<p>在下面的代码段中，我们具有 lengthOf 断言的逻辑，该逻辑检查对象是否具有特定长度。 我们希望我们的用户像这样使用它：expect([‘foo’，’bar’]).to.have.lengthOf(2)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assertLength</span>(<span class="params">n, msg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (msg) flag(<span class="keyword">this</span>, <span class="string">"message"</span>, msg);</span><br><span class="line">  <span class="keyword">var</span> obj = flag(<span class="keyword">this</span>, <span class="string">"object"</span>),</span><br><span class="line">    ssfi = flag(<span class="keyword">this</span>, <span class="string">"ssfi"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pay close attention to this line</span></span><br><span class="line">  <span class="keyword">new</span> Assertion(obj, msg, ssfi, <span class="literal">true</span>).to.have.property(<span class="string">"length"</span>);</span><br><span class="line">  <span class="keyword">var</span> len = obj.length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This line is also relevant</span></span><br><span class="line">  <span class="keyword">this</span>.assert(</span><br><span class="line">    len == n,</span><br><span class="line">    <span class="string">"expected #&#123;this&#125; to have a length of #&#123;exp&#125; but got #&#123;act&#125;"</span>,</span><br><span class="line">    <span class="string">"expected #&#123;this&#125; to not have a length of #&#123;act&#125;"</span>,</span><br><span class="line">    n,</span><br><span class="line">    len</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Assertion.addChainableMethod(<span class="string">"lengthOf"</span>, assertLength, assertLengthChain);</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我突出显示了当前与我们相关的行。 让我们从对 this.assert 的调用开始。</p>
<p>这是 this.assert 方法的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Assertion.prototype.assert = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  expr,</span></span></span><br><span class="line"><span class="function"><span class="params">  msg,</span></span></span><br><span class="line"><span class="function"><span class="params">  negateMsg,</span></span></span><br><span class="line"><span class="function"><span class="params">  expected,</span></span></span><br><span class="line"><span class="function"><span class="params">  _actual,</span></span></span><br><span class="line"><span class="function"><span class="params">  showDiff</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ok = util.test(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span> !== showDiff) showDiff = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">undefined</span> === expected &amp;&amp; <span class="literal">undefined</span> === _actual) showDiff = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span> !== config.showDiff) showDiff = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">    msg = util.getMessage(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">var</span> actual = util.getActual(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is the relevant line for us</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(</span><br><span class="line">      msg,</span><br><span class="line">      &#123;</span><br><span class="line">        actual: actual,</span><br><span class="line">        expected: expected,</span><br><span class="line">        showDiff: showDiff</span><br><span class="line">      &#125;,</span><br><span class="line">      config.includeStack ? <span class="keyword">this</span>.assert : flag(<span class="keyword">this</span>, <span class="string">"ssfi"</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>基本上，assert 方法负责检查 assert 布尔表达式是否通过。 如果没有，我们必须实例化一个 AssertionError。 请注意，在实例化此新的 AssertionError 时，我们还向其传递了堆栈跟踪功能指示器（ssfi）。 如果打开了配置标记 includeStack，我们通过将 this.assert 本身传递给用户，向用户显示整个堆栈跟踪，这实际上是堆栈中的最后一帧。 但是，如果关闭了 includeStack 配置标志，我们必须从堆栈跟踪中隐藏更多内部实现细节，因此我们将使用存储在 ssfi 标志中的内容。</p>
<p>现在，让我们谈谈与我们相关的另一条线：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Assertion(obj, msg, ssfi, <span class="literal">true</span>).to.have.property(<span class="string">"length"</span>);</span><br></pre></td></tr></table></figure>
<p>如您所见，在创建嵌套断言时，我们将传递从 ssfi 标志获得的内容。 这意味着在创建新的断言时，它将使用此函数作为从堆栈跟踪中删除无用帧的起点。 顺便说一下，这是 Assertion 构造函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Assertion</span>(<span class="params">obj, msg, ssfi, lockSsfi</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// This is the line that matters to us</span></span><br><span class="line">  flag(<span class="keyword">this</span>, <span class="string">"ssfi"</span>, ssfi || Assertion);</span><br><span class="line">  flag(<span class="keyword">this</span>, <span class="string">"lockSsfi"</span>, lockSsfi);</span><br><span class="line">  flag(<span class="keyword">this</span>, <span class="string">"object"</span>, obj);</span><br><span class="line">  flag(<span class="keyword">this</span>, <span class="string">"message"</span>, msg);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> util.proxify(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以从我对 addChainableMethod 的描述中记住，它使用自己的 wrapper 方法设置 ssfi 标志，这意味着这是堆栈跟踪中的最低内部框架，因此我们可以删除其上方的所有框架。</p>
<p>通过将 ssfi 传递给嵌套断言，该断言仅检查我们的对象是否具有属性长度，从而避免了重置框架（该框架将用作起点指示符），而使先前的 addChainableMethod 在堆栈中可见。</p>
<p>这看起来似乎有些复杂，所以让我们回顾一下 Chai 内部发生的情况，我们想从堆栈中删除无用的帧：</p>
<ul>
<li>当运行断言时，我们将其自己的方法设置为删除堆栈中下一帧的参考</li>
<li>断言运行，如果失败，我们将在存储引用后删除所有内部框架</li>
<li>如果我们嵌套了断言，则仍必须使用当前断言包装器方法作为删除堆栈中下一帧的参考点，因此我们将当前的 ssfi（启动栈功能指示器）传递给我们正在创建的断言，以便可以保留它</li>
</ul>
<p>我也强烈建议您阅读@meeber 的评论，以了解它。</p>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> node </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jmeter压测]]></title>
      <url>https://skhon.github.io/2020/02/25/jmeter-test/</url>
      <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>这两天我负责的一个 node 中间层框架 hobber，在业务方的那边的项目压测中，当 qps 达到 1500 左右时，出现大量 504。由于压测线上服务在半夜，当时我也不在现场，所以，我决定自己压一下，目的有两个，一个是压我们自己的服<a id="more"></a>务，看 hobber 是不是能够压到当初承诺的 qps 2500，另一个是想复现一下那天业务方压测出现的 504 问题。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>我用的是 jmeter，<a href="http://jmeter.apache.org/download_jmeter.cgi" target="_blank" rel="noopener">下载地址</a></p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>进入 jmeter 目录下对 bin 文件，执行命令：sh jmeter</p>
<h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p>jmeter 压测的时候，一般不用图像化工具压，一般是执行脚本压，如果图像化工具直接压，太耗性能了，所以机器对资源尽量留给发压力。<br>但是脚本的话，一般是通过图形化界面配，然后把脚本导出来。</p>
<ol>
<li>创建线程组<br>在“测试计划”上右键 【添加】–&gt;【Threads(Users)】–&gt;【线程组】。<br><img src="/images/jmeter/1.png" alt></li>
</ol>
<p>设置线程数和循环次数。我这里设置线程数为 500，循环一次。<br><img src="/images/jmeter/2.png" alt></p>
<ol start="2">
<li>配置元件<br>在我们刚刚创建的线程组上右键 【添加】–&gt;【配置元件】–&gt;【HTTP 请求默认值】。<br><img src="/images/jmeter/3.png" alt><br>配置我们需要进行测试的程序协议、地址和端口:<br><img src="/images/jmeter/4.png" alt><br><code>当所有的接口测试的访问域名和端口都一样时，可以使用该元件，一旦服务器地址变更，只需要修改请求默认值即可。</code></li>
<li><p>构造 HTTP 请求<br>在“线程组”右键 【添加-】-&gt;【samlper】–&gt;【HTTP 请求】设置我们需要测试的 API 的请求路径和数据。我这里是用的 json<br><img src="/images/jmeter/5.png" alt></p>
</li>
<li><p>添加 HTTP 请求头<br>在我们刚刚创建的线程组上右键 【添加】–&gt;【配置元件】–&gt;【HTTP 信息头管理器】。</p>
</li>
</ol>
<p>因为我要传输的数据为 json，所以设置一个 Content-Type:application/json<br><img src="/images/jmeter/6.png" alt></p>
<ol start="5">
<li>添加断言<br>在我们刚刚创建的线程组上右键 【添加】–&gt;【断言】–&gt;【响应断言】。</li>
</ol>
<p>根据响应的数据来判断请求是否正常。我在这里只判断的响应代码是否为 200。还可以配置错误信息<br><img src="/images/jmeter/7.png" alt></p>
<ol start="6">
<li>添加察看结果树<br>在我们刚刚创建的线程组上右键 【添加】–&gt;【监听器】–&gt;【察看结果树】。</li>
</ol>
<p>直接添加，然后点击运行按钮就可以看到结果了。<br><img src="/images/jmeter/8.png" alt></p>
<ol start="7">
<li>添加 Summary Report<br>在我们刚刚创建的线程组上右键 【添加】–&gt;【监听器】–&gt;【Summary Report】。</li>
</ol>
<p>直接添加，然后点击运行按钮就可以看到结果了。<br><img src="/images/jmeter/9.png" alt></p>
<ol start="8">
<li>测试计划创建完成<br>文件 -&gt; 保存测试计划</li>
</ol>
<h2 id="执行测试计划"><a href="#执行测试计划" class="headerlink" title="执行测试计划"></a>执行测试计划</h2><p>前面我们说过，执行测试计划不能用 GUI，需要用命令行来执行。<br><img src="/images/jmeter/10.png" alt></p>
<p>我这里执行的命令为：</p>
<p>jmeter -n -t testplan/RedisLock.jmx -l testplan/result/result.txt -e -o testplan/webreport</p>
<p>说明：<br>testplan/RedisLock.jmx 为测试计划文件路径<br>testplan/result/result.txt 为测试结果文件路径<br>testplan/webreport 为 web 报告保存路径。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如果发压机端口不够用，可能会出现这样的问题：</p>
<font color="#DC143C" face="黑体">Non HTTP response code: java.net.NoRouteToHostException/Non HTTP response message: Cannot assign requested address (Address not available)</font>

<p>解决办法：</p>
<ol>
<li>调低端口释放后的等待时间， 默认为 60s， 修改为 15~30s<br>echo 30 &gt; /proc/sys/net/ipv4/tcp_fin_timeout</li>
<li>修改 tcp/ip 协议配置， 通过配置/proc/sys/net/ipv4/tcp_tw_resue, 默认为 0， 修改为 1， 释放 TIME_WAIT 端口给新连接使用。<br>echo 1 &gt; /proc/sys/net/ipv4/tcp_tw_reuse</li>
<li>修改 tcp/ip 协议配置，快速回收 socket 资源， 默认为 0， 修改为 1.<br>echo 1 &gt; /proc/sys/net/ipv4/tcp_tw_recycle</li>
<li>执行：sysctl -p ，使设置立即生效。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> node </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[解读node api]]></title>
      <url>https://skhon.github.io/2020/01/15/node/</url>
      <content type="html"><![CDATA[<h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2>]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> node </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[单元测试]]></title>
      <url>https://skhon.github.io/2020/01/14/unit-test/</url>
      <content type="html"><![CDATA[<h2 id="什么是单元测试"><a href="#什么是单元测试" class="headerlink" title="什么是单元测试"></a>什么是单元测试</h2><p>单元测试也叫做模块测试，就是对一个一个模块，来进行正确性检验对测试工作。如果接触测试的工作，测试人员在测你的项目之前都会写一些测试用例，然后这些测试用例可以覆盖到各种情况，然后用这些测试用例再一一检测你的程序，这是测<a id="more"></a>试功能做的一部分。我们项目做单元测试也就是为了我们的程序能够尽可能的少出 bug。</p>
<h2 id="node-的单元测试"><a href="#node-的单元测试" class="headerlink" title="node 的单元测试"></a>node 的单元测试</h2><p>单元测试的框架很多，可以看一下各种单元测试框架的对比：<br><img src="/images/test01.png" alt><br>mocha 用的最多，我用的也是 mocha，但是 mocha 没有断言库，那配一个 chai。</p>
<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><ol>
<li>先安装 mocha，chai</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i --save-dev mocha</span><br><span class="line">npm i --save-dev chai</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>写 demo</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// modules/add.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test/add.spec.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; expect &#125; = <span class="built_in">require</span>(<span class="string">"chai"</span>);</span><br><span class="line"><span class="keyword">const</span> add = <span class="built_in">require</span>(<span class="string">"../modules/add"</span>);</span><br><span class="line">describe(<span class="string">"测试加法模块"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    it(<span class="string">"1加2,应该为3"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        expect(add(<span class="number">1</span>, <span class="number">2</span>)).to.equal(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//assert.equal(-1, [1, 2, 3].indexOf(-1));</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx mocha add.spec.js</span><br></pre></td></tr></table></figure>
<p><img src="/images/test02.png" alt></p>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> node </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[node调试]]></title>
      <url>https://skhon.github.io/2020/01/09/node-debug/</url>
      <content type="html"><![CDATA[<h2 id="node-调试的几种方法"><a href="#node-调试的几种方法" class="headerlink" title="node 调试的几种方法"></a>node 调试的几种方法</h2><p>在看 hobber 源码的时候，想看下一个请求是如何在 hobber 中跑的，我开始根据自己的理解以及猜测，是在 node_modules 中的包里打 console.log，这种方式感觉太累了，并且对整个 hobber 框架的理解效率不是很高，于是我问了一下 hobber 作者（黄老师）<a id="more"></a>,黄老师给我的答复是，他当时写 hobber 的时候，调试都是 console。。。好吧，我感觉我作为一个刚刚接触 hobber 的新手来说，光 console 好像救不了我。于是就研究了一下 node 的调试方式。</p>
<h3 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h3><p>网上有很多相关调试 node 的文章，但是笔者感觉最好还是看官网，我认为学习任何一门技术，首要看的资料是官网，因为那个是最权威的。我这里记录一下我用 vscode 调试 node 的一种方式。</p>
<p>配置一下 launch.json 文件即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。</span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="string">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"node"</span>,</span><br><span class="line">            <span class="string">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"hobber-debug"</span>,</span><br><span class="line">            <span class="string">"program"</span>: <span class="string">"$&#123;workspaceFolder&#125;/server/src/index.ts"</span>,</span><br><span class="line">            <span class="comment">// "preLaunchTask": "tsc: build - tsconfig.json",</span></span><br><span class="line">            <span class="string">"outFiles"</span>: [</span><br><span class="line">                <span class="string">"$&#123;workspaceFolder&#125;/server/dist/*.js"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里贴一下 vscode debug 的官方介绍：<a href="https://code.visualstudio.com/docs/nodejs/nodejs-debugging" target="_blank" rel="noopener">node debug in vscode</a></p>
<h3 id="inspector"><a href="#inspector" class="headerlink" title="inspector"></a>inspector</h3><p>这个 node 自带的就不要考虑了，太麻烦了。</p>
<h3 id="Chrome-55-开发工具"><a href="#Chrome-55-开发工具" class="headerlink" title="Chrome(55+) 开发工具"></a>Chrome(55+) 开发工具</h3><blockquote>
<p>版本：<br>Node.js 6.3+<br>Chrome 55+</p>
</blockquote>
<p>Chrome 打开：chrome://inspect<br>启动 node：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node --inspect-brk app.js  <span class="comment">// 在程序开头停止</span></span><br><span class="line">node --inspect app.js      <span class="comment">// 不会在程序开头停止</span></span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> node </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[谈谈hook]]></title>
      <url>https://skhon.github.io/2020/01/03/hook-js/</url>
      <content type="html"><![CDATA[<h2 id="什么是-hook"><a href="#什么是-hook" class="headerlink" title="什么是 hook"></a>什么是 hook</h2><p>概括的说：hook 是将一系列要执行的动作注册到一个统一的入口，程序通过调用 hook 来执行注册的动作。而一般执行 hook 的常规做法（并不是所有的 hook 都是这么调用的）是通过匹配的方式来执行。<a id="more"></a><br>我们可以先从匹配机制说起，先举个简单的例子。比如，前端和后端联调的时候，后端在 response 的时候，会给你返回各种状态码，你可以根据不同的状态码来分别进行前端的不同操作。这种逻辑，大多数同学会想到条件语句来实现:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (code === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Ok"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (code === <span class="number">500</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Internal server error"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (code === <span class="number">404</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Not found"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然也可以用 switch 来实现。那我们这里可以用 hook 来实现的话，就感觉代码很优雅，并且执行效率也相对快一些。我们可以把所有可能的 code 放在一个 list 中，code 作为 key，对应的内容作为 value，然后来进行匹配。代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> codeList = &#123;</span><br><span class="line">    <span class="number">200</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Ok"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">404</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Not founnd"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">500</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Internal server error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    codeList[input]();</span><br><span class="line">&#125;</span><br><span class="line">print(<span class="number">200</span>);</span><br></pre></td></tr></table></figure>
<p>上述程序运行结果为：”Ok”，那输出 Ok 的这个操作就是一个 hook，我们一共有三个 hook，而 print 为一个主流程，我们为这个主流程里面插入的我们注册的操作，就是 hook。再来一张丑图：<br><img src="/images/hook01.png" alt="hook 图解"><br>start-&gt;end 是一个完整的流程，我们需要在这个流程里面插入我们想要自己实现的功能，就可以将这些功能先注册到一个数组中，然后调用的时候，可以 Array[key]这种方式，执行我们的 hook。</p>
<h2 id="js-中的函数劫持"><a href="#js-中的函数劫持" class="headerlink" title="js 中的函数劫持"></a>js 中的函数劫持</h2><p>劫持的意思，大家都懂，在程序中的劫持，可以理解在一个常规的程序流程中，可以插入一些我们自己想执行的一些操作，进而改变整个过程。举个简单的例子，比如，我想劫持 alert，可以这么做：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _alert = alert;</span><br><span class="line"><span class="built_in">window</span>.alert = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Hooked!"</span>);</span><br><span class="line">    _alert(s);</span><br><span class="line">&#125;;</span><br><span class="line">alert(<span class="string">"hello world"</span>);</span><br></pre></td></tr></table></figure>
<p>这个过程可以理解为：先保存原来的 alert，然后重写 alert，这样在执行 alert 的时候，就是执行的重写之后的。那么重写的过程我们可以不暴露出来，那么对于用 alert 的用户来说，好像和以前的执行结果不太一样了。这就是<code>alert 函数被劫持了</code>。<br>我们可以再联想一下 hook 思想，hook 就是在一个完整流程中，插入我们想要实现的功能，那么原本的 alert 就是一个完整的执行流程，我们执行它，就是弹一个对话框，但是上面的例子展示了，在 alert 中添加了一条 console.log(“Hooked!”)这样的语句，这就是 hook 的思想。</p>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
