<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[探索garfish源码]]></title>
      <url>https://skhon.github.io/2021/12/28/fe/garfish/</url>
      <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>首先，可以在github上把代码拉到本地，地址为：<a href="https://github.com/modern-js-dev/garfish" target="_blank" rel="noopener">https://github.com/modern-js-dev/garfish</a><br>然后就需要把项目跑起来，方便调试。总共四步即可：</p>
<ol>
<li>全局安装pnpm：<blockquote>
<p>$ npm i -g pnpm</p>
</blockquote>
</li>
<li>安装依赖<blockquote>
<p>$ pnpm install</p>
</blockquote>
</li>
<li>启动build:watch<blockquote>
<p>$ pnpm build:watch</p>
</blockquote>
</li>
<li>启动dev<blockquote>
<p>$ pnpm dev<br>这样就跑起来了。整体框架代码讲解主要以流程为主，一些细节性逻辑就直接跳过，有兴趣的同学可以翻源码。</p>
</blockquote>
<h1 id="在主应用中引入Garfish实例："><a href="#在主应用中引入Garfish实例：" class="headerlink" title="在主应用中引入Garfish实例："></a>在主应用中引入Garfish实例：</h1>在主应用中，首先引入Garfish实例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// dev/main/src/index.ts</span><br><span class="line">import GarfishInstance from &apos;garfish&apos;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>先看一下这个实例是个啥，追溯一下源码，发现Garfish实例是一个函数返回的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// packages/garfish/src/index.ts</span><br><span class="line">function createContext(): Garfish &#123;</span><br><span class="line">  // ...</span><br><span class="line">  // Existing garfish instance, direct return</span><br><span class="line">  if (inBrowser() &amp;&amp; window[&apos;__GARFISH__&apos;] &amp;&amp; window[&apos;Garfish&apos;]) &#123;</span><br><span class="line">    return window[&apos;Garfish&apos;];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const GarfishInstance = new Garfish(&#123;</span><br><span class="line">    plugins: [GarfishRouter(), GarfishBrowserVm(), GarfishBrowserSnapshot()],</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line">  </span><br><span class="line">  return GarfishInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>createContext可以理解为创建上下文环境，从上至下捋一下，如果是浏览器环境，并且window上存在Garfish对象，则直接返回（熟悉设计模式的同学，应该知道这是一个单例模式）。接下来new了一个Garfish对象，并且默认传入了一个对象 { plugins: [GarfishRouter(), GarfishBrowserVm(), GarfishBrowserSnapshot()] }。这是初始化了三个插件，我们继续看一下这三个插件长什么样子。<br>我们先看一下GarfishRouter<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// packages/router/src/index.ts</span><br><span class="line">export function GarfishRouter(_args?: Options) &#123;</span><br><span class="line">  return function (Garfish: interfaces.Garfish): interfaces.Plugin &#123;</span><br><span class="line">    Garfish.apps = &#123;&#125;;</span><br><span class="line">    Garfish.router = router;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      name: &apos;router&apos;,</span><br><span class="line">      version: __VERSION__,</span><br><span class="line"></span><br><span class="line">      bootstrap(options: interfaces.Options) &#123;</span><br><span class="line">        // ...</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      registerApp(appInfos) &#123;</span><br><span class="line">        // ...</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到GarfishRouter()返回的是一个function，形成闭包，最后会返回一个对象。这个对象其实是一个插件的格式，有name、version，还有生命周期钩子bootstrap、registerApp，生命周期钩子我们后续会介绍到，这里大家了解就行。再看看其他两个插件是什么：<br>GarfishBorwserVm:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// packages/browser-vm/src/pluginify.ts</span><br><span class="line">export function GarfishBrowserVm() &#123;</span><br><span class="line">  return function (Garfish: interfaces.Garfish): interfaces.Plugin &#123;</span><br><span class="line">    Garfish.getGlobalObject = function () &#123;</span><br><span class="line">      return Sandbox.getNativeWindow();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Garfish.setGlobalValue = function (key, value) &#123;</span><br><span class="line">      return (this.getGlobalObject()[key] = value);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Garfish.clearEscapeEffect = function (key, value) &#123;</span><br><span class="line">      const global = this.getGlobalObject();</span><br><span class="line">      if (key in global) &#123;</span><br><span class="line">        global[key] = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return createOptions(Garfish);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createOptions(Garfish: interfaces.Garfish) &#123;</span><br><span class="line">  // ...</span><br><span class="line">  const options: interfaces.Plugin = &#123;</span><br><span class="line">    name: &apos;browser-vm&apos;,</span><br><span class="line">    version: __VERSION__,</span><br><span class="line"></span><br><span class="line">    afterLoad(appInfo, appInstance) &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    // If the app is uninstalled, the sandbox needs to clear all effects and then reset</span><br><span class="line">    afterUnmount(appInfo, appInstance, isCacheMode) &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    afterMount(appInfo, appInstance) &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  return options;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>GarfishBrowserSnapshot:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// packages/browser-snapshot/src/index.ts</span><br><span class="line">export function GarfishBrowserSnapshot(op?: BrowserConfig) &#123;</span><br><span class="line">  return function (Garfish: interfaces.Garfish): interfaces.Plugin &#123;</span><br><span class="line">    const config: BrowserConfig = op || &#123; open: true &#125;;</span><br><span class="line"></span><br><span class="line">    const options = &#123;</span><br><span class="line">      openBrowser: false,</span><br><span class="line">      version: __VERSION__,</span><br><span class="line">      name: &apos;browser-snapshot&apos;,</span><br><span class="line"></span><br><span class="line">      afterLoad(appInfo, appInstance) &#123;</span><br><span class="line">        // ...</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      beforeMount(appInfo, appInstance) &#123;</span><br><span class="line">        // ...</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      afterUnmount(appInfo, appInstance) &#123;</span><br><span class="line">        // ...</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    return options;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到都是返回一个函数，并且这个函数的返回格式有点类似，其实这就是garfish插件的形式，返回一个函数，该函数返回一个对象，这个对象包含了这个插件的一些信息，可以总结成这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name: &apos;&apos;,</span><br><span class="line">    version: &apos;&apos;,</span><br><span class="line">    lifecycle: &apos;&apos; // 这里的lifecycle是泛指生命周期的钩子函数，具体指bootstrap、beforeBootstrap等等</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>插件中生命周期的具体实现，放在后面讲述。这里暂时把代码运行链路拉通。接下来再返回Garfish类的实现，它的实例是什么样子的。<br>Garfish类的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">// packages/core/src/garfish.ts</span><br><span class="line">export class Garfish extends EventEmitter2 &#123;</span><br><span class="line">  public running = false;</span><br><span class="line">  public version = __VERSION__;</span><br><span class="line">  public flag = __GARFISH_FLAG__; // A unique identifier</span><br><span class="line">  public loader = new Loader();</span><br><span class="line">  public hooks = globalLifecycle();</span><br><span class="line">  public channel = new EventEmitter2();</span><br><span class="line">  public options = createDefaultOptions();</span><br><span class="line">  public externals: Record&lt;string, any&gt; = &#123;&#125;;</span><br><span class="line">  public activeApps: Array&lt;interfaces.App&gt; = [];</span><br><span class="line">  public plugins: interfaces.Plugins = &#123;&#125; as any;</span><br><span class="line">  public cacheApps: Record&lt;string, interfaces.App&gt; = &#123;&#125;;</span><br><span class="line">  public appInfos: Record&lt;string, interfaces.AppInfo&gt; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  private nestedSwitch = false;</span><br><span class="line">  private loading: Record&lt;string, Promise&lt;any&gt; | null&gt; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  get props(): Record&lt;string, any&gt; &#123;</span><br><span class="line">    return (this.options &amp;&amp; this.options.props) || DEFAULT_PROPS.get(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  constructor(options: interfaces.Options) &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.setOptions(options);</span><br><span class="line">    DEFAULT_PROPS.set(this, &#123;&#125;);</span><br><span class="line">    this.options.plugins?.forEach((plugin) =&gt; this.usePlugin(plugin));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private setOptions(options: Partial&lt;interfaces.Options&gt;) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  createPluginSystem&lt;T extends (api: typeof HOOKS_API) =&gt; any&gt;(callback: T) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  usePlugin(</span><br><span class="line">    plugin: (context: Garfish) =&gt; interfaces.Plugin,</span><br><span class="line">    ...args: Array&lt;any&gt;</span><br><span class="line">  ) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run(options: interfaces.Options = &#123;&#125;) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  registerApp(list: interfaces.AppInfo | Array&lt;interfaces.AppInfo&gt;) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setExternal(nameOrExtObj: string | Record&lt;string, any&gt;, value?: any) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async loadApp(</span><br><span class="line">    appName: string,</span><br><span class="line">    optionsOrUrl?: Omit&lt;interfaces.AppInfo, &apos;name&apos;&gt;,</span><br><span class="line">  ): Promise&lt;interfaces.App | null&gt; &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>先看一下钩子函数中，做了什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// packages/core/src/garfish.ts</span><br><span class="line">constructor(options: interfaces.Options) &#123;</span><br><span class="line">    super();</span><br><span class="line">    // 传入的options（其实就是默认的那三个插件） 深度merge到默认的options上。</span><br><span class="line">    this.setOptions(options);</span><br><span class="line">    DEFAULT_PROPS.set(this, &#123;&#125;);</span><br><span class="line">    // 这里分别执行默认的三个插件</span><br><span class="line">    this.options.plugins?.forEach((plugin) =&gt; this.usePlugin(plugin));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>this.setOptions(options)主要是把传入的options深度merge到默认的options中。而传入的options就是传入的那三个默认插件。我们看一下默认的options有哪些属性吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// packages/core/src/config.ts</span><br><span class="line">export const createDefaultOptions = (nested = false) =&gt; &#123;</span><br><span class="line">  const config: interfaces.Options = &#123;</span><br><span class="line">    // global config</span><br><span class="line">    appID: &apos;&apos;,</span><br><span class="line">    apps: [],</span><br><span class="line">    autoRefreshApp: true,</span><br><span class="line">    disableStatistics: false,</span><br><span class="line">    disablePreloadApp: false,</span><br><span class="line">    // app config</span><br><span class="line">    basename: &apos;/&apos;,</span><br><span class="line">    props: &#123;&#125;,</span><br><span class="line">    // Use an empty div by default</span><br><span class="line">    domGetter: () =&gt; document.createElement(&apos;div&apos;),</span><br><span class="line">    sandbox: &#123;</span><br><span class="line">      snapshot: false,</span><br><span class="line">      disableWith: false,</span><br><span class="line">      strictIsolation: false,</span><br><span class="line">    &#125;,</span><br><span class="line">    // global hooks</span><br><span class="line">    beforeLoad: () =&gt; &#123;&#125;,</span><br><span class="line">    afterLoad: () =&gt; &#123;&#125;,</span><br><span class="line">    errorLoadApp: (e) =&gt; error(e),</span><br><span class="line">    // Router</span><br><span class="line">    onNotMatchRouter: () =&gt; &#123;&#125;,</span><br><span class="line">    // app hooks</span><br><span class="line">    // Code eval hooks</span><br><span class="line">    beforeEval: () =&gt; &#123;&#125;,</span><br><span class="line">    afterEval: () =&gt; &#123;&#125;,</span><br><span class="line">    // App mount hooks</span><br><span class="line">    beforeMount: () =&gt; &#123;&#125;,</span><br><span class="line">    afterMount: () =&gt; &#123;&#125;,</span><br><span class="line">    beforeUnmount: () =&gt; &#123;&#125;,</span><br><span class="line">    afterUnmount: () =&gt; &#123;&#125;,</span><br><span class="line">    // Error hooks</span><br><span class="line">    errorMountApp: (e) =&gt; error(e),</span><br><span class="line">    errorUnmountApp: (e) =&gt; error(e),</span><br><span class="line">    customLoader: null, // deprecated</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  if (nested) &#123;</span><br><span class="line">    invalidNestedAttrs.forEach((key) =&gt; delete config[key]);</span><br><span class="line">  &#125;</span><br><span class="line">  return config;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>再回到构造函数中，接下来分别对plugins进行usePlugin操作，其实就是为了拿到插件中的一些属性，并且进行一些注册操作。我们看一下usePlugin做了些什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// packages/core/src/garfish.ts</span><br><span class="line">usePlugin(</span><br><span class="line">    plugin: (context: Garfish) =&gt; interfaces.Plugin,</span><br><span class="line">    ...args: Array&lt;any&gt;</span><br><span class="line">  ) &#123;</span><br><span class="line">   // ...</span><br><span class="line">   </span><br><span class="line">    // this指向是Garfish类</span><br><span class="line">    args.unshift(this); </span><br><span class="line">    </span><br><span class="line">    // 执行传入的plugin</span><br><span class="line">    const pluginConfig = plugin.apply(null, args) as interfaces.Plugin;</span><br><span class="line">    assert(pluginConfig.name, &apos;The plugin must have a name.&apos;);</span><br><span class="line"></span><br><span class="line">    // 如果没有注册过，则进行注册 </span><br><span class="line">    if (!this.plugins[pluginConfig.name]) &#123;</span><br><span class="line">      this.plugins[pluginConfig.name] = pluginConfig;</span><br><span class="line">      // Register hooks, Compatible with the old api</span><br><span class="line">      this.hooks.usePlugin(pluginConfig);</span><br><span class="line">    &#125; else if (__DEV__) &#123;</span><br><span class="line">      warn(&apos;Please do not register the plugin repeatedly.&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>args数组首位是Garfish自己，然后获取插件配置，前面我们提到了，插件最后的返回是一个对象，里面包含name、version、生命周期钩子等。然后plugin.apply()就是返回的这些配置，并且赋值给了pluginConfig。接下来就是注册逻辑了，如果之前没有注册过该plugin，则进行注册，就是key为plugin的name，value为具体的配置形式，放在this.plugins对象中，这个好理解，接下来是进行this.hooks.usePlugin(pluginConfig)操作，这个其实是用来注册生命周期的，看一下this.hooks是啥，再构造函数中，是这么初始化hooks的：<br>// packages/core/src/garfish.ts<br>public hooks = globalLifecycle();<br>通过函数名，也应该能猜得到，全局生命周期的hooks。接着看globalLifeCycle实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// packages/core/src/lifecycle.ts</span><br><span class="line">export function globalLifecycle() &#123;</span><br><span class="line">  return new PluginSystem(&#123;</span><br><span class="line">    beforeBootstrap: new SyncHook&lt;[interfaces.Options], void&gt;(),</span><br><span class="line">    bootstrap: new SyncHook&lt;[interfaces.Options], void&gt;(),</span><br><span class="line">    beforeRegisterApp: new SyncHook&lt;[interfaces.AppInfo | Array&lt;interfaces.AppInfo&gt;], void&gt;(),</span><br><span class="line">    registerApp: new SyncHook&lt;[Record&lt;string, interfaces.AppInfo&gt;], void&gt;(),</span><br><span class="line">    beforeLoad: new AsyncHook&lt;[interfaces.AppInfo], Promise&lt;boolean | void&gt; | void | boolean&gt;(),</span><br><span class="line">    afterLoad: new AsyncHook&lt;[interfaces.AppInfo, interfaces.App], void&gt;(),</span><br><span class="line">    errorLoadApp: new SyncHook&lt;[Error, interfaces.AppInfo], void&gt;(),</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>返回的是一个pluginSystem实例，传入一个对象，包含7个生命周期属性。先看pluginSystem类的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// packages/hooks/src/pluginSystem.ts</span><br><span class="line">export class PluginSystem&lt;T extends Record&lt;string, any&gt;&gt; &#123;</span><br><span class="line">  lifecycle: T;</span><br><span class="line">  lifecycleKeys: Array&lt;keyof T&gt;;</span><br><span class="line">  private registerPlugins: Record&lt;string, Plugin&lt;T&gt;&gt; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  constructor(lifecycle: T) &#123;</span><br><span class="line">    /*</span><br><span class="line">      lifecycle: </span><br><span class="line">      &#123;</span><br><span class="line">        beforeBootstrap: new SyncHook&lt;[interfaces.Options], void&gt;(),</span><br><span class="line">        bootstrap: new SyncHook&lt;[interfaces.Options], void&gt;(),</span><br><span class="line">        beforeRegisterApp: new SyncHook&lt;[interfaces.AppInfo | Array&lt;interfaces.AppInfo&gt;], void&gt;(),</span><br><span class="line">        registerApp: new SyncHook&lt;[Record&lt;string, interfaces.AppInfo&gt;], void&gt;(),</span><br><span class="line">        beforeLoad: new AsyncHook&lt;[interfaces.AppInfo], Promise&lt;boolean | void&gt; | void | boolean&gt;(),</span><br><span class="line">        afterLoad: new AsyncHook&lt;[interfaces.AppInfo, interfaces.App], void&gt;(),</span><br><span class="line">        errorLoadApp: new SyncHook&lt;[Error, interfaces.AppInfo], void&gt;(),</span><br><span class="line">      &#125;</span><br><span class="line">    */</span><br><span class="line">    this.lifecycle = lifecycle;</span><br><span class="line">    this.lifecycleKeys = Object.keys(lifecycle);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  usePlugin(plugin: Plugin&lt;T&gt;) &#123;</span><br><span class="line">    assert(isPlainObject(plugin), &apos;Invalid plugin configuration.&apos;);</span><br><span class="line">    // Plugin name is required and unique</span><br><span class="line">    const pluginName = plugin.name;</span><br><span class="line">    assert(pluginName, &apos;Plugin must provide a name.&apos;);</span><br><span class="line"></span><br><span class="line">    if (!this.registerPlugins[pluginName]) &#123;</span><br><span class="line">      this.registerPlugins[pluginName] = plugin;</span><br><span class="line"></span><br><span class="line">      for (const key in this.lifecycle) &#123;</span><br><span class="line">        const pluginLife = plugin[key as string];</span><br><span class="line">        if (pluginLife) &#123;</span><br><span class="line">          // Differentiate different types of hooks and adopt different registration strategies</span><br><span class="line">          this.lifecycle[key].on(pluginLife);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (__DEV__) &#123;</span><br><span class="line">      warn(`Repeat to register plugin hooks &quot;$&#123;pluginName&#125;&quot;.`);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removePlugin(pluginName: string) &#123;</span><br><span class="line">    assert(pluginName, &apos;Must provide a name.&apos;);</span><br><span class="line">    const plugin = this.registerPlugins[pluginName];</span><br><span class="line">    assert(plugin, `plugin &quot;$&#123;pluginName&#125;&quot; is not registered.`);</span><br><span class="line"></span><br><span class="line">    for (const key in plugin) &#123;</span><br><span class="line">      this.lifecycle[key].remove(plugin[key as string]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到上面提到的this.hooks.usePlugin其实是执行了pluginSystem类中的usePlugin方法，实现逻辑也是会在pluginSystem类中的registerPlugins进行注册，然后会在全局生命周期的不同钩子上，注册每个插件配置中对应的钩子函数。这个大家需要好好理解一下，这个设计我们在写自己的框架时可以学习一下。再返回到创建pluginSystem实例中，传入的几个hooks，主要包含两种，一种是同步的SyncHook，另一种是异步的AsyncHook。看一下这两类hooks的实现。<br>SyncHook：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// packages/hooks/src/syncHook.ts</span><br><span class="line">export class SyncHook&lt;T, K&gt; &#123;</span><br><span class="line">  public type: string = &apos;&apos;;</span><br><span class="line">  public listeners = new Set&lt;Callback&lt;T, K&gt;&gt;();</span><br><span class="line"></span><br><span class="line">  constructor(type?: string) &#123;</span><br><span class="line">    if (type) this.type = type;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  on(fn: Callback&lt;T, K&gt;) &#123;</span><br><span class="line">    if (typeof fn === &apos;function&apos;) &#123;</span><br><span class="line">      this.listeners.add(fn);</span><br><span class="line">    &#125; else if (__DEV__) &#123;</span><br><span class="line">      warn(&apos;Invalid parameter in &quot;Hook&quot;.&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  once(fn: Callback&lt;T, K&gt;) &#123;</span><br><span class="line">    const self = this;</span><br><span class="line">    this.on(function wrapper(...args: Array&lt;any&gt;) &#123;</span><br><span class="line">      self.remove(wrapper);</span><br><span class="line">      return fn.apply(null, args);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  emit(...data: ArgsType&lt;T&gt;) &#123;</span><br><span class="line">    if (this.listeners.size &gt; 0) &#123;</span><br><span class="line">      this.listeners.forEach((fn) =&gt; fn.apply(null, data));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  remove(fn: Callback&lt;T, K&gt;) &#123;</span><br><span class="line">    return this.listeners.delete(fn);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeAll() &#123;</span><br><span class="line">    this.listeners.clear();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>就是一个简单的发布订阅模式。<br>AsyncHook：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// packages/hooks/src/asyncHook.ts</span><br><span class="line">export class AsyncHook&lt;T, K&gt; extends SyncHook&lt;T, K&gt; &#123;</span><br><span class="line">  emit(...data: ArgsType&lt;T&gt;): Promise&lt;void | false&gt; &#123;</span><br><span class="line">    let result;</span><br><span class="line">    const ls = Array.from(this.listeners);</span><br><span class="line">    if (ls.length &gt; 0) &#123;</span><br><span class="line">      let i = 0;</span><br><span class="line">      const call = (prev?: any) =&gt; &#123;</span><br><span class="line">        if (prev === false) &#123;</span><br><span class="line">          return false; // Abort process</span><br><span class="line">        &#125; else if (i &lt; ls.length) &#123;</span><br><span class="line">          return Promise.resolve(ls[i++].apply(null, data)).then(call);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      result = call();</span><br><span class="line">    &#125;</span><br><span class="line">    return Promise.resolve(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AsyncHook的emit实现，可以理解将一串的异步函数，进行同步处理，上一个异步函数的返回，是下一个异步函数的入参，如果看过Koa中间件的实现，就很容易明白这样逻辑的实现了。<br>到目前为止，当主应用引入Garfish后，初步的注册工作基本完成了。</p>
<h1 id="主应用中启动Garfish"><a href="#主应用中启动Garfish" class="headerlink" title="主应用中启动Garfish"></a>主应用中启动Garfish</h1><p>我们先假设主应用默认路由就是/，不默认展示子应用。<br>再看主应用如何进行下一步的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// main/src/index.ts</span><br><span class="line">import GarfishInstance from &apos;garfish&apos;; </span><br><span class="line">import &#123; Config &#125; from &apos;./config&apos;;</span><br><span class="line"></span><br><span class="line">GarfishInstance.run(Config);</span><br><span class="line">第一行代码，我们已经在上面介绍过了，继续往下走，看看Config是什么：</span><br><span class="line">// dev/main/src/config.ts</span><br><span class="line">let defaultConfig: interfaces.Options = &#123;</span><br><span class="line">  basename: &apos;/garfish_master&apos;,</span><br><span class="line">  domGetter: () =&gt; &#123;</span><br><span class="line">    // await asyncTime();</span><br><span class="line">    return document.querySelector(&apos;#submoduleByRouter&apos;);</span><br><span class="line">  &#125;,</span><br><span class="line">  apps: [</span><br><span class="line">    // &#123;</span><br><span class="line">    //   name: &apos;vue&apos;,</span><br><span class="line">    //   activeWhen: &apos;/vue&apos;,</span><br><span class="line">    //   cache: false,</span><br><span class="line">    //   entry: &apos;http://localhost:2666&apos;,</span><br><span class="line">    // &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name: &apos;vue2&apos;,</span><br><span class="line">      cache: false,</span><br><span class="line">      activeWhen: &apos;/vue2&apos;,</span><br><span class="line">      entry: &apos;http://localhost:2777&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name: &apos;react&apos;,</span><br><span class="line">      activeWhen: &apos;/react&apos;,</span><br><span class="line">      entry: &apos;http://localhost:2444&apos;,</span><br><span class="line">      props: &#123;</span><br><span class="line">        appName: &apos;react&apos;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  autoRefreshApp: false,</span><br><span class="line">  disablePreloadApp: true,</span><br><span class="line">  protectVariable: [&apos;MonitoringInstance&apos;, &apos;Garfish&apos;],</span><br><span class="line">  sandbox: &#123;</span><br><span class="line">    open: true,</span><br><span class="line">    // strictIsolation: true,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // beforeMount(appInfo) &#123;</span><br><span class="line">  //   console.log(&apos;beforeMount&apos;, appInfo);</span><br><span class="line">  // &#125;,</span><br><span class="line"></span><br><span class="line">  // afterLoad(info, app) &#123;</span><br><span class="line">  //   console.log(app.vmSandbox);</span><br><span class="line">  // &#125;,</span><br><span class="line"></span><br><span class="line">  customLoader() &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个默认配置，是用户可以自定义的，通过之前的源码分析，这些配置最后会深度merge到Garfish类中的默认配置。接下来就是GarfishInstance.run(Config)，将配置传入，然后执行Garfish类中的run方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// packages/core/src/garfish.ts</span><br><span class="line">run(options: interfaces.Options = &#123;&#125;) &#123;</span><br><span class="line">    if (this.running) &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.setOptions(options);</span><br><span class="line">    // Register plugins</span><br><span class="line">    this.usePlugin(GarfishHMRPlugin());</span><br><span class="line">    this.usePlugin(GarfishPerformance());</span><br><span class="line">    if (!this.options.disablePreloadApp) &#123;</span><br><span class="line">      this.usePlugin(GarfishPreloadPlugin());</span><br><span class="line">    &#125;</span><br><span class="line">    options.plugins?.forEach((plugin) =&gt; this.usePlugin(plugin));</span><br><span class="line">    // Put the lifecycle plugin at the end, so that you can get the changes of other plugins</span><br><span class="line">    this.usePlugin(GarfishOptionsLife(this.options, &apos;global-lifecycle&apos;));</span><br><span class="line"></span><br><span class="line">    // Emit hooks and register apps</span><br><span class="line">    this.hooks.lifecycle.beforeBootstrap.emit(this.options);</span><br><span class="line">    this.registerApp(this.options.apps || []);</span><br><span class="line">    this.running = true;</span><br><span class="line">    this.hooks.lifecycle.bootstrap.emit(this.options);</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>首先还是把传入的options参数深度merge到Garfish默认的options中，接着进行一些插件注册，最后注册了一个名为global-lifecycle的插件，这个插件主要是用来兜底的，因为插件注册是有先后顺序的，先注册的插件，在实行生命钩子方法时，是先执行的，所以global-lifecycle这个插件中，传入的生命周期钩子方法是用户可以自定义传入的，那么最后执行的时候，global-lifecycle拿到的是所有插件中最后的数据，方便调试。<br>接下来就是触发生命周期中beforeBootstrap，之前所有的插件中，所有beforeBootstrap的钩子都注册到了全局beforeBootstrap中，这个时候进行emit操作。如果用户没有传入自定义plugin(已经定义了beforeBootstrap方法)的话，这里应该是没有可执行方法的，因为框架内置的一些插件中没有该方法。<br>接下来就是注册app了，我们在主应用中的options中，有个apps的属性，里面注册着所有子应用。看一下registreApp的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// packages/core/src/garfish.ts</span><br><span class="line">registerApp(list: interfaces.AppInfo | Array&lt;interfaces.AppInfo&gt;) &#123;</span><br><span class="line">    const currentAdds = &#123;&#125;;</span><br><span class="line">    this.hooks.lifecycle.beforeRegisterApp.emit(list);</span><br><span class="line">    if (!Array.isArray(list)) list = [list];</span><br><span class="line"></span><br><span class="line">    for (const appInfo of list) &#123;</span><br><span class="line">      assert(appInfo.name, &apos;Miss app.name.&apos;);</span><br><span class="line">      if (!this.appInfos[appInfo.name]) &#123;</span><br><span class="line">        assert(</span><br><span class="line">          appInfo.entry,</span><br><span class="line">          `$&#123;appInfo.name&#125; application entry is not url: $&#123;appInfo.entry&#125;`,</span><br><span class="line">        );</span><br><span class="line">        currentAdds[appInfo.name] = appInfo;</span><br><span class="line">        this.appInfos[appInfo.name] = appInfo;</span><br><span class="line">      &#125; else if (__DEV__) &#123;</span><br><span class="line">        warn(`The &quot;$&#123;appInfo.name&#125;&quot; app is already registered.`);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    this.hooks.lifecycle.registerApp.emit(currentAdds);</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>首先执行生命周期beforeRegisterApp中的方法，然后将apps注册到currentAdds和this.appInfos中，再执行registerApp中的方法。<br>再返回到run方法中，继续往下执行，就会执行生命周期bootstrap中的方法。我们主要看一下router中的bootstrap方法，看看在启动时做了什么<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">// packages/router/src/index.ts</span><br><span class="line">bootstrap(options: interfaces.Options) &#123;</span><br><span class="line">        let activeApp = null;</span><br><span class="line">        const unmounts: Record&lt;string, Function&gt; = &#123;&#125;;</span><br><span class="line">        const &#123; basename &#125; = options;</span><br><span class="line">        const &#123; autoRefreshApp = true, onNotMatchRouter = () =&gt; null &#125; =</span><br><span class="line">          Garfish.options;</span><br><span class="line"></span><br><span class="line">        async function active(appInfo: interfaces.AppInfo, rootPath: string) &#123;</span><br><span class="line">          const &#123; name, cache = true, active &#125; = appInfo;</span><br><span class="line">          if (active) return active(appInfo, rootPath);</span><br><span class="line">          appInfo.rootPath = rootPath;</span><br><span class="line"></span><br><span class="line">          const currentApp = (activeApp = createKey());</span><br><span class="line">          const app = await Garfish.loadApp(appInfo.name, &#123;</span><br><span class="line">            basename: rootPath,</span><br><span class="line">            entry: appInfo.entry,</span><br><span class="line">            cache: true,</span><br><span class="line">            domGetter: appInfo.domGetter,</span><br><span class="line">          &#125;);</span><br><span class="line">          app.appInfo.basename = rootPath;</span><br><span class="line"></span><br><span class="line">          const call = (app: interfaces.App, isRender: boolean) =&gt; &#123;</span><br><span class="line">            if (!app) return;</span><br><span class="line">            const isDes = cache &amp;&amp; app.mounted;</span><br><span class="line">            const fn = isRender</span><br><span class="line">              ? app[isDes ? &apos;show&apos; : &apos;mount&apos;]</span><br><span class="line">              : app[isDes ? &apos;hide&apos; : &apos;unmount&apos;];</span><br><span class="line">            return fn.call(app);</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">          Garfish.apps[name] = app;</span><br><span class="line">          unmounts[name] = () =&gt; call(app, false);</span><br><span class="line"></span><br><span class="line">          if (currentApp === activeApp) &#123;</span><br><span class="line">            await call(app, true);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        async function deactive(appInfo: interfaces.AppInfo, rootPath: string) &#123;</span><br><span class="line">          activeApp = null;</span><br><span class="line">          const &#123; name, deactive &#125; = appInfo;</span><br><span class="line">          if (deactive) return deactive(appInfo, rootPath);</span><br><span class="line"></span><br><span class="line">          const unmount = unmounts[name];</span><br><span class="line">          unmount &amp;&amp; unmount();</span><br><span class="line">          delete Garfish.apps[name];</span><br><span class="line"></span><br><span class="line">          // Nested scene to remove the current application of nested data</span><br><span class="line">          // To avoid the main application prior to application</span><br><span class="line">          const needToDeleteApps = router.routerConfig.apps.filter((app) =&gt; &#123;</span><br><span class="line">            if (appInfo.rootPath === app.basename) return true;</span><br><span class="line">          &#125;);</span><br><span class="line">          if (needToDeleteApps.length &gt; 0) &#123;</span><br><span class="line">            needToDeleteApps.forEach((app) =&gt; &#123;</span><br><span class="line">              delete Garfish.appInfos[app.name];</span><br><span class="line">              delete Garfish.cacheApps[app.name];</span><br><span class="line">            &#125;);</span><br><span class="line">            router.setRouterConfig(&#123;</span><br><span class="line">              apps: router.routerConfig.apps.filter((app) =&gt; &#123;</span><br><span class="line">                return !needToDeleteApps.some(</span><br><span class="line">                  (needDelete) =&gt; app.name === needDelete.name,</span><br><span class="line">                );</span><br><span class="line">              &#125;),</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        const apps = Object.values(Garfish.appInfos);</span><br><span class="line"></span><br><span class="line">        const appList = apps.filter((app) =&gt; &#123;</span><br><span class="line">          if (!app.basename) app.basename = basename;</span><br><span class="line">          return !!app.activeWhen;</span><br><span class="line">        &#125;) as Array&lt;Required&lt;interfaces.AppInfo&gt;&gt;;</span><br><span class="line"></span><br><span class="line">        const listenOptions = &#123;</span><br><span class="line">          basename,</span><br><span class="line">          active,</span><br><span class="line">          deactive,</span><br><span class="line">          autoRefreshApp,</span><br><span class="line">          notMatch: onNotMatchRouter,</span><br><span class="line">          apps: appList,</span><br><span class="line">        &#125;;</span><br><span class="line">        listenRouterAndReDirect(listenOptions);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法可以直接看最后，就是执行了一个listenRouterAndReDirect方法，并传入了listenOptions对象。接着找listenRouterAndReDirect方法的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// packages/router/src/context.ts</span><br><span class="line">export const listenRouterAndReDirect = (&#123;</span><br><span class="line">  apps,</span><br><span class="line">  basename,</span><br><span class="line">  autoRefreshApp,</span><br><span class="line">  active,</span><br><span class="line">  deactive,</span><br><span class="line">  notMatch,</span><br><span class="line">&#125;: Options) =&gt; &#123;</span><br><span class="line">  // 注册子应用、注册激活、销毁钩子</span><br><span class="line">  registerRouter(apps);</span><br><span class="line"></span><br><span class="line">  // 初始化信息</span><br><span class="line">  setRouterConfig(&#123;</span><br><span class="line">    basename,</span><br><span class="line">    autoRefreshApp,</span><br><span class="line">    // supportProxy: !!window.Proxy,</span><br><span class="line">    active,</span><br><span class="line">    deactive,</span><br><span class="line">    notMatch,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 开始监听路由变化触发、子应用更新。重载默认初始子应用</span><br><span class="line">  listen();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>主要就是注册子应用，初始化配置，最后进行监听。再看listen方法的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// packages/router/src/agentRouter.ts</span><br><span class="line">export const listen = () =&gt; &#123;</span><br><span class="line">  normalAgent();</span><br><span class="line">  initRedirect();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>然后执行了两个方法normalAgent和initRedirect，继续往下看实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">// packages/router/src/agentRouter.ts</span><br><span class="line">export const normalAgent = () =&gt; &#123;</span><br><span class="line">  // By identifying whether have finished listening, if finished listening, listening to the routing changes do not need to hijack the original event</span><br><span class="line">  // Support nested scene</span><br><span class="line">  const addRouterListener = function () &#123;</span><br><span class="line">    window.addEventListener(__GARFISH_BEFORE_ROUTER_EVENT__, function (env) &#123;</span><br><span class="line">      RouterConfig.routerChange &amp;&amp; RouterConfig.routerChange(location.pathname);</span><br><span class="line">      linkTo((env as any).detail);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  if (!window[__GARFISH_ROUTER_FLAG__]) &#123;</span><br><span class="line">    // Listen for pushState and replaceState, call linkTo, processing, listen back</span><br><span class="line">    // Rewrite the history API method, triggering events in the call</span><br><span class="line">    const rewrite = function (type: keyof History) &#123;</span><br><span class="line">      const hapi = history[type];</span><br><span class="line">      return function () &#123;</span><br><span class="line">        const urlBefore = window.location.pathname + window.location.hash;</span><br><span class="line">        const stateBefore = history?.state;</span><br><span class="line">        const res = hapi.apply(this as any, arguments);</span><br><span class="line">        const urlAfter = window.location.pathname + window.location.hash;</span><br><span class="line">        const stateAfter = history?.state;</span><br><span class="line"></span><br><span class="line">        const e = createEvent(type);</span><br><span class="line">        (e as any).arguments = arguments;</span><br><span class="line"></span><br><span class="line">        if (urlBefore !== urlAfter || stateBefore !== stateAfter) &#123;</span><br><span class="line">          if (history.state &amp;&amp; history.state === &apos;object&apos;)</span><br><span class="line">            delete history.state[__GARFISH_ROUTER_UPDATE_FLAG__];</span><br><span class="line">          window.dispatchEvent(</span><br><span class="line">            new CustomEvent(__GARFISH_BEFORE_ROUTER_EVENT__, &#123;</span><br><span class="line">              detail: &#123;</span><br><span class="line">                toRouterInfo: &#123;</span><br><span class="line">                  fullPath: urlAfter,</span><br><span class="line">                  query: parseQuery(location.search),</span><br><span class="line">                  path: getPath(RouterConfig.basename!, urlAfter),</span><br><span class="line">                  state: stateAfter,</span><br><span class="line">                &#125;,</span><br><span class="line">                fromRouterInfo: &#123;</span><br><span class="line">                  fullPath: urlBefore,</span><br><span class="line">                  query: parseQuery(location.search),</span><br><span class="line">                  path: getPath(RouterConfig.basename!, urlBefore),</span><br><span class="line">                  state: stateBefore,</span><br><span class="line">                &#125;,</span><br><span class="line">                eventType: type,</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;),</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">        // window.dispatchEvent(e);</span><br><span class="line">        return res;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    history.pushState = rewrite(&apos;pushState&apos;);</span><br><span class="line">    history.replaceState = rewrite(&apos;replaceState&apos;);</span><br><span class="line"></span><br><span class="line">    // Before the collection application sub routing, forward backward routing updates between child application</span><br><span class="line">    window.addEventListener(</span><br><span class="line">      &apos;popstate&apos;,</span><br><span class="line">      function (event) &#123;</span><br><span class="line">        // Stop trigger collection function, fire again match rendering</span><br><span class="line">        if (event &amp;&amp; typeof event === &apos;object&apos; &amp;&amp; (event as any).garfish)</span><br><span class="line">          return;</span><br><span class="line">        if (history.state &amp;&amp; history.state === &apos;object&apos;)</span><br><span class="line">          delete history.state[__GARFISH_ROUTER_UPDATE_FLAG__];</span><br><span class="line">        window.dispatchEvent(</span><br><span class="line">          new CustomEvent(__GARFISH_BEFORE_ROUTER_EVENT__, &#123;</span><br><span class="line">            detail: &#123;</span><br><span class="line">              toRouterInfo: &#123;</span><br><span class="line">                fullPath: location.pathname,</span><br><span class="line">                query: parseQuery(location.search),</span><br><span class="line">                path: getPath(RouterConfig.basename!),</span><br><span class="line">              &#125;,</span><br><span class="line">              fromRouterInfo: &#123;</span><br><span class="line">                fullPath: RouterConfig.current!.fullPath,</span><br><span class="line">                path: getPath(</span><br><span class="line">                  RouterConfig.basename!,</span><br><span class="line">                  RouterConfig.current!.path,</span><br><span class="line">                ),</span><br><span class="line">                query: RouterConfig.current!.query,</span><br><span class="line">              &#125;,</span><br><span class="line">              eventType: &apos;popstate&apos;,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;),</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">      false,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    window[__GARFISH_ROUTER_FLAG__] = true;</span><br><span class="line">  &#125;</span><br><span class="line">  addRouterListener();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>normalAgent方法的实现，其实就是重写了history.pushState和history.replaceState两个方法，并且会触发一个自定义事件<strong>GARFISH_BEFORE_ROUTER_EVENT</strong>，那么addRouterListener其实就是注册了<strong>GARFISH_BEFORE_ROUTER_EVENT</strong>自定义事件。而initRedirect方法就是初始默认化路由的。无论是normalAgent还是initRedirect，最后都会进入linkTo方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">// packages/router/src/linkTo.ts</span><br><span class="line">export const linkTo = async (&#123;</span><br><span class="line">  toRouterInfo,</span><br><span class="line">  fromRouterInfo,</span><br><span class="line">  eventType,</span><br><span class="line">&#125;: &#123;</span><br><span class="line">  toRouterInfo: RouterInfo;</span><br><span class="line">  fromRouterInfo: RouterInfo;</span><br><span class="line">  eventType: keyof History | &apos;popstate&apos;;</span><br><span class="line">&#125;) =&gt; &#123;</span><br><span class="line">  const &#123;</span><br><span class="line">    current,</span><br><span class="line">    apps,</span><br><span class="line">    deactive,</span><br><span class="line">    active,</span><br><span class="line">    notMatch,</span><br><span class="line">    beforeEach,</span><br><span class="line">    afterEach,</span><br><span class="line">    autoRefreshApp,</span><br><span class="line">  &#125; = RouterConfig;</span><br><span class="line">  const deactiveApps = current!.matched.filter(</span><br><span class="line">    (appInfo) =&gt;</span><br><span class="line">      !hasActive(</span><br><span class="line">        appInfo.activeWhen,</span><br><span class="line">        getPath(appInfo.basename, location.pathname),</span><br><span class="line">      ),</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  // Activate the corresponding application</span><br><span class="line">  const activeApps = apps.filter((appInfo) =&gt; &#123;</span><br><span class="line">    return hasActive(</span><br><span class="line">      appInfo.activeWhen,</span><br><span class="line">      getPath(appInfo.basename, location.pathname),</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  const needToActive = activeApps.filter((&#123; name &#125;) =&gt; &#123;</span><br><span class="line">    return !current!.matched.some((&#123; name: cName &#125;) =&gt; name === cName);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // router infos</span><br><span class="line">  const to = &#123;</span><br><span class="line">    ...toRouterInfo,</span><br><span class="line">    matched: needToActive,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  const from = &#123;</span><br><span class="line">    ...fromRouterInfo,</span><br><span class="line">    matched: deactiveApps,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  await toMiddleWare(to, from, beforeEach!);</span><br><span class="line"></span><br><span class="line">  // Pause the current application of active state</span><br><span class="line">  if (current!.matched.length &gt; 0) &#123;</span><br><span class="line">    await asyncForEach(</span><br><span class="line">      deactiveApps,</span><br><span class="line">      async (appInfo) =&gt;</span><br><span class="line">        await deactive(appInfo, getPath(appInfo.basename, location.pathname)),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setRouterConfig(&#123;</span><br><span class="line">    current: &#123;</span><br><span class="line">      path: getPath(RouterConfig.basename!),</span><br><span class="line">      fullPath: location.pathname,</span><br><span class="line">      matched: activeApps,</span><br><span class="line">      state: history.state,</span><br><span class="line">      query: parseQuery(location.search),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // Within the application routing jump, by collecting the routing function for processing.</span><br><span class="line">  // Filtering gar-router popstate hijacking of the router</span><br><span class="line">  // In the switch back and forth in the application is provided through routing push method would trigger application updates</span><br><span class="line">  // application will refresh when autoRefresh configuration to true</span><br><span class="line">  const curState = window.history.state || &#123;&#125;;</span><br><span class="line">  if (</span><br><span class="line">    eventType !== &apos;popstate&apos; &amp;&amp;</span><br><span class="line">    (curState[__GARFISH_ROUTER_UPDATE_FLAG__] || autoRefreshApp)</span><br><span class="line">  ) &#123;</span><br><span class="line">    callCapturedEventListeners(eventType);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  await asyncForEach(needToActive, async (appInfo) =&gt; &#123;</span><br><span class="line">    // Function using matches character and routing using string matching characters</span><br><span class="line">    const appRootPath = getAppRootPath(appInfo);</span><br><span class="line">    await active(appInfo, appRootPath);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  if (activeApps.length === 0 &amp;&amp; notMatch) notMatch(location.pathname);</span><br><span class="line"></span><br><span class="line">  await toMiddleWare(to, from, afterEach!);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>再归纳一下，有两个中间件可以执行，afterEach和beforeEach，就是在active之前和之后的执行时机。然后主要的就是active了，其实active这个方法，是router插件中，bootstrap钩子里的active方法。到目前为止，我们主应用就run起来了，接下来就是通过路由来show或者hide子应用了。</p>
<h1 id="路由trigger子应用"><a href="#路由trigger子应用" class="headerlink" title="路由trigger子应用"></a>路由trigger子应用</h1><p>接下来点击vue按钮，展示vue子应用。<br>我们前面已经介绍过了，在normalAgent实现中劫持了history.push方法，那么在进行路由变化时，就会触发自定义事件<strong>GARFISH_BEFORE_ROUTER_EVENT</strong>，然后会再次进入linkTo方法，这个时候needToActive就是true了，会执行active，而active就是router插件中bootstrap的active方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// packages/router/src/index.ts</span><br><span class="line">async function active(appInfo: interfaces.AppInfo, rootPath: string) &#123;</span><br><span class="line">          const &#123; name, cache = true, active &#125; = appInfo;</span><br><span class="line">          if (active) return active(appInfo, rootPath);</span><br><span class="line">          appInfo.rootPath = rootPath;</span><br><span class="line"></span><br><span class="line">          const currentApp = (activeApp = createKey());</span><br><span class="line">          const app = await Garfish.loadApp(appInfo.name, &#123;</span><br><span class="line">            basename: rootPath,</span><br><span class="line">            entry: appInfo.entry,</span><br><span class="line">            cache: true,</span><br><span class="line">            domGetter: appInfo.domGetter,</span><br><span class="line">          &#125;);</span><br><span class="line">          app.appInfo.basename = rootPath;</span><br><span class="line"></span><br><span class="line">          const call = (app: interfaces.App, isRender: boolean) =&gt; &#123;</span><br><span class="line">            if (!app) return;</span><br><span class="line">            const isDes = cache &amp;&amp; app.mounted;</span><br><span class="line">            const fn = isRender</span><br><span class="line">              ? app[isDes ? &apos;show&apos; : &apos;mount&apos;]</span><br><span class="line">              : app[isDes ? &apos;hide&apos; : &apos;unmount&apos;];</span><br><span class="line">            return fn.call(app);</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">          Garfish.apps[name] = app;</span><br><span class="line">          unmounts[name] = () =&gt; call(app, false);</span><br><span class="line"></span><br><span class="line">          if (currentApp === activeApp) &#123;</span><br><span class="line">            await call(app, true);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法中会有个app，这个app是Garfish类中loadApp方法返回的，那我们看一下返回的这个app是啥：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">// packages/core/src/garfish.ts</span><br><span class="line">async loadApp(</span><br><span class="line">    appName: string,</span><br><span class="line">    optionsOrUrl?: Omit&lt;interfaces.AppInfo, &apos;name&apos;&gt;,</span><br><span class="line">  ): Promise&lt;interfaces.App | null&gt; &#123;</span><br><span class="line">    assert(appName, &apos;Miss appName.&apos;);</span><br><span class="line">    const appInfo = generateAppOptions(appName, this, optionsOrUrl);</span><br><span class="line"></span><br><span class="line">    const asyncLoadProcess = async () =&gt; &#123;</span><br><span class="line">      // Return not undefined type data directly to end loading</span><br><span class="line">      const stop = await this.hooks.lifecycle.beforeLoad.emit(appInfo);</span><br><span class="line">      if (stop === false) &#123;</span><br><span class="line">        warn(`Load $&#123;appName&#125; application is terminated by beforeLoad.`);</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line">      // Existing cache caching logic</span><br><span class="line">      let appInstance: interfaces.App = null;</span><br><span class="line">      const cacheApp = this.cacheApps[appName];</span><br><span class="line">      if (appInfo.cache &amp;&amp; cacheApp) &#123;</span><br><span class="line">        appInstance = cacheApp;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          const [manager, resources, isHtmlMode] = await processAppResources(</span><br><span class="line">            this.loader,</span><br><span class="line">            appInfo,</span><br><span class="line">          );</span><br><span class="line"></span><br><span class="line">          appInstance = new App(</span><br><span class="line">            this,</span><br><span class="line">            appInfo,</span><br><span class="line">            manager,</span><br><span class="line">            resources,</span><br><span class="line">            isHtmlMode,</span><br><span class="line">            appInfo.customLoader,</span><br><span class="line">          );</span><br><span class="line"></span><br><span class="line">          // The registration hook will automatically remove the duplication</span><br><span class="line">          for (const key in this.plugins) &#123;</span><br><span class="line">            appInstance.hooks.usePlugin(this.plugins[key]);</span><br><span class="line">          &#125;</span><br><span class="line">          if (appInfo.cache) &#123;</span><br><span class="line">            this.cacheApps[appName] = appInstance;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">          __DEV__ &amp;&amp; warn(e);</span><br><span class="line">          this.hooks.lifecycle.errorLoadApp.emit(e, appInfo);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      await this.hooks.lifecycle.afterLoad.emit(appInfo, appInstance);</span><br><span class="line">      return appInstance;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    if (!this.loading[appName]) &#123;</span><br><span class="line">      this.loading[appName] = asyncLoadProcess().finally(() =&gt; &#123;</span><br><span class="line">        this.loading[appName] = null;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return this.loading[appName];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数稍微有点长，我总结一下，this.loading是为了保存当前要加载的app，通过一个asyncLoadProcess返回，这里注意一下，asyncLoadProcess是async函数，没有await，所以返回的是一个Promise对象，而resolve的是appInstance，在asyncLoadProcess中，也是执行了app生命周期中的几个钩子。我们再简单了解一下App类是什么样的，由于代码太多，我们只列个大概，并且说明用途即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">// packages/core/src/module/app.ts</span><br><span class="line">export class App &#123;</span><br><span class="line">  public appId = appId++;</span><br><span class="line">  public display = false;</span><br><span class="line">  public mounted = false;</span><br><span class="line">  public esModule = false;</span><br><span class="line">  public strictIsolation = false;</span><br><span class="line">  public name: string;</span><br><span class="line">  public isHtmlMode: boolean;</span><br><span class="line">  public global: any = window;</span><br><span class="line">  public appContainer: HTMLElement;</span><br><span class="line">  public cjsModules: Record&lt;string, any&gt;;</span><br><span class="line">  public htmlNode: HTMLElement | ShadowRoot;</span><br><span class="line">  public customExports: Record&lt;string, any&gt; = &#123;&#125;; // If you don&apos;t want to use the CJS export, can use this</span><br><span class="line">  public sourceList: Array&lt;&#123; tagName: string; url: string &#125;&gt; = [];</span><br><span class="line">  public appInfo: AppInfo;</span><br><span class="line">  public hooks: interfaces.AppHooks;</span><br><span class="line">  public provider: interfaces.Provider;</span><br><span class="line">  public entryManager: TemplateManager;</span><br><span class="line">  public appPerformance: SubAppObserver;</span><br><span class="line">  /** @deprecated */</span><br><span class="line">  public customLoader: CustomerLoader;</span><br><span class="line"></span><br><span class="line">  private active = false;</span><br><span class="line">  private mounting = false;</span><br><span class="line">  private unmounting = false;</span><br><span class="line">  private context: Garfish;</span><br><span class="line">  private resources: interfaces.ResourceModules;</span><br><span class="line">  // Environment variables injected by garfish for linkage with child applications</span><br><span class="line">  private globalEnvVariables: Record&lt;string, any&gt;;</span><br><span class="line">  // es-module save lifeCycle to appGlobalId，appGlobalId in script attr</span><br><span class="line">  private appGlobalId: string;</span><br><span class="line"></span><br><span class="line">  constructor(</span><br><span class="line">    context: Garfish,</span><br><span class="line">    appInfo: AppInfo,</span><br><span class="line">    entryManager: TemplateManager,</span><br><span class="line">    resources: interfaces.ResourceModules,</span><br><span class="line">    isHtmlMode: boolean,</span><br><span class="line">    customLoader: CustomerLoader,</span><br><span class="line">  ) &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get rootElement() &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getProvider() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  execScript(</span><br><span class="line">    code: string,</span><br><span class="line">    env: Record&lt;string, any&gt;,</span><br><span class="line">    url?: string,</span><br><span class="line">    options?: &#123; async?: boolean; noEntry?: boolean &#125;,</span><br><span class="line">  ) &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // `vm sandbox` can override this method</span><br><span class="line">  runCode(</span><br><span class="line">    code: string,</span><br><span class="line">    env: Record&lt;string, any&gt;,</span><br><span class="line">    url?: string,</span><br><span class="line">    options?: &#123; async?: boolean; noEntry?: boolean &#125;,</span><br><span class="line">  ) &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async show() &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  hide() &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  async mount() &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  unmount() &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getExecScriptEnv(noEntry: boolean) &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Performs js resources provided by the module, finally get the content of the export</span><br><span class="line">  async compileAndRenderContainer() &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private canMount() &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // If asynchronous task encountered in the rendering process, such as triggering the beforeEval before executing code,</span><br><span class="line">  // after the asynchronous task, you need to determine whether the application has been destroyed or in the end state.</span><br><span class="line">  // If in the end state will need to perform the side effects of removing rendering process, adding a mount point to a document,</span><br><span class="line">  // for example, execute code of the environmental effects, and rendering the state in the end.</span><br><span class="line">  private stopMountAndClearEffect() &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Calls to render do compatible with two different sandbox</span><br><span class="line">  private callRender(provider: interfaces.Provider, isMount: boolean) &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Call to destroy do compatible with two different sandbox</span><br><span class="line">  private callDestroy(provider: interfaces.Provider, isUnmount: boolean) &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Create a container node and add in the document flow</span><br><span class="line">  // domGetter Have been dealing with</span><br><span class="line">  private async addContainer() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private async renderTemplate() &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private async checkAndGetProvider() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总结起来，这个App类提供的能力如下：</p>
<ol>
<li>提供静态资源，HTML、CSS、js的结构。</li>
<li>可以在CJS中提取或者推导出子应用的 provider。<br>3.通过execCode传入模块的CJS规范、require、exports等环境变量实现对外共享</li>
<li>触发渲染：应用相关节点放置在文档流中，依次执行应用脚本，最终渲染功能，执行子应用提供完整的应用独立运行时执行。</li>
<li>触发销毁：执行子应用程序的销毁功能，应用子节点从文档流中移除。<br>再回到active方法中，最核心的地方是call方法，最后调用了App中的show、mount、hide、unmount方法。show和hide可以理解为之前已经加载过了，就是show和hide一下，mount是要和unmount是挂载和卸载，我们这里主要以mount为例，看一下是如何加载子应用环境并且加载子应用的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// packages/core/src/module/app.ts</span><br><span class="line">async mount() &#123;</span><br><span class="line">    if (!this.canMount()) return false;</span><br><span class="line">    this.hooks.lifecycle.beforeMount.emit(this.appInfo, this, false);</span><br><span class="line"></span><br><span class="line">    this.active = true;</span><br><span class="line">    this.mounting = true;</span><br><span class="line">    try &#123;</span><br><span class="line">      // add container and compile js with cjs</span><br><span class="line">      const asyncJsProcess = await this.compileAndRenderContainer();</span><br><span class="line"></span><br><span class="line">      // Good provider is set at compile time</span><br><span class="line">      const provider = await this.getProvider();</span><br><span class="line">      // Existing asynchronous functions need to decide whether the application has been unloaded</span><br><span class="line">      if (!this.stopMountAndClearEffect()) return false;</span><br><span class="line"></span><br><span class="line">      this.callRender(provider, true);</span><br><span class="line">      this.display = true;</span><br><span class="line">      this.mounted = true;</span><br><span class="line">      this.context.activeApps.push(this);</span><br><span class="line">      this.hooks.lifecycle.afterMount.emit(this.appInfo, this, false);</span><br><span class="line"></span><br><span class="line">      await asyncJsProcess;</span><br><span class="line">      if (!this.stopMountAndClearEffect()) return false;</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      this.entryManager.DOMApis.removeElement(this.appContainer);</span><br><span class="line">      this.hooks.lifecycle.errorMountApp.emit(e, this.appInfo);</span><br><span class="line">      return false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      this.mounting = false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>大概意思就是说，添加了一个子应用容器，拿到子应用资源（主要通过fetch方式获取，继续深挖compileAndRenderContainer就知道了），然后获取子应用export出来的provider，最后执行代码，子应用就成功展示出来了。<br>再说一下子应用的代码执行，子应用中如果使用了window，那么在子应用接入主应用后，如果不做任何处理，那么两个应用的window是一个，这样就会有逻辑问题，为了解决这个问题，就有了沙箱概念。garfish中提供了两种沙箱机制：vm沙箱和snapshot沙箱。<br>我们可以看一个简单的vm沙箱原理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const varBox = &#123;&#125;;</span><br><span class="line">const fakeWindow = new Proxy(window, &#123;</span><br><span class="line">    get(target, key) &#123;</span><br><span class="line">        return varBox[key] || window[key]</span><br><span class="line">    &#125;,</span><br><span class="line">    set(target, key, value) &#123;</span><br><span class="line">        varBox[key] = value;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">const fn = new Function(&apos;window&apos;, code);</span><br><span class="line">fn(fakeWindow);</span><br></pre></td></tr></table></figure></p>
<p>主要是通过es6中proxy实现的，当然这只是一个原理性代码，实际中还会兼容很多case。其实在最初注册garfish插件的时候，初始化garfish实例的时候，就初始化了vm沙箱和snapshot沙箱。我们前面也说了，在每个插件中都会定义一些生命周期的钩子方法，其实在Garfish.loadApp的时候，就在App上挂载了vmSandbox属性，在后续的子应用执行代码时，环境都是在沙箱中执行。</p>
]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Web </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[架构师的职责]]></title>
      <url>https://skhon.github.io/2021/12/20/architecture/base/</url>
      <content type="html"><![CDATA[<p>经常有人问，架构师是干嘛的？那么今天谈谈，架构师的职责是什么。</p>
<h3 id="什么是架构"><a href="#什么是架构" class="headerlink" title="什么是架构"></a>什么是架构</h3><p>谈架构师职责之前，我们要先了解什么是架构。那么提到架构，很多人也会提到框架这个概念，多数情况下，我们都不怎么区分这两个概念，如果细分一下的话，架构偏向于结构，框架偏向于规范。比如linux中有架构，window有架构，微信有架构，淘宝也有架构…那么框架呢，比如一款mvvm框架，mvc框架，使用这个框架需要遵循一些规定好的设计。</p>
<p>我们这里主要说一下架构吧，以微信为例，一款app，它其实是分很多模块的，比如好友模块，朋友圈模块，消息模块等，而朋友圈模块又分为留言模块，点赞模块，发表模块等。架构就是说，这些不同的模块如何的各司其职，又能如何的互相配合，如果要增加一个摇一摇模块，如何能够扩展方便。把这些所有因素都考虑进来，最后能够组装在一起的能力，就是架构能力，整个系统的所有组成统一叫做架构。感觉还是有点绕。。。不管了，我觉得能够解决业务痛点，使得业务能够做到高性能、高可用、易扩展、成本低、安全高…，说白了就是能解决掉业务排在前面一半的痛点，就是牛逼的架构师。</p>
<h3 id="为什么需要架构"><a href="#为什么需要架构" class="headerlink" title="为什么需要架构"></a>为什么需要架构</h3><p>大家有没有发现，一般小公司没有架构师这个职位，只有达到一定量级才会有架构师，因为小公司不需要架构，10个人开个会碰一碰，你做这个，我做这个，撸起袖子写代码，尽快上线，比花时间搞架构有意义。你以为淘宝一开始就搞的这么牛吗？不是的，淘宝第一版是买的！当年杭州马在2013年的时候，4月7号决定要做淘宝，要求5月10号上线，要是你想着搞架构，黄花菜都凉了，基于当时公司、市场情况，只要买一个是最快的，当然要考虑买一个什么样的，买一个轻量的还是买个复杂的，各有优势，但是基于后续可能要持续发展，就买了个轻量的，方便后续二次开发。等到了后续，业务大爆发，当前项目承载不了那么高的流量，才开始搞架构。所以，好的架构都是业务逼出来的。如果架构脱离业务，那没有太大的意义。</p>
<p>回到主题，我们为什么需要架构，我理解的架构就是为了解决复杂业务中遇到的问题。</p>
<h3 id="架构要做什么"><a href="#架构要做什么" class="headerlink" title="架构要做什么"></a>架构要做什么</h3><p>我们上面也说到了，当业务发展一定程度时，由于市场需求、公司老板要求等，必须要对业务进行优化，可能因为旧结构会有一些问题，比如难扩张，加一个新需求，依赖的东西太多，人员成本大，也可以是用户量急剧上升，需要承载更高的qps等，那么架构要做的，我这里整理了几个方面：高性能、高可用、可扩展、低成本、高安全，当然还有很多，但多数的复杂业务都会遇到这几个问题。</p>
<h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><p>之前做过一个bff框架，支持公司内部服务，当时一台8核32G服务器，裸压hello world，记得qps最高压到了2500。记得当时公司有个活动，预计当天参与人数会到20万，qps峰值保险一点就是20w了，那么如何让这个qps只能到2500的框架支持这么多的用户量呢？最简单的办法也是最合适的，用机器的数量来提升qps的上限，一台机器可以承载2500的qps，那就操作20w/2500多台机器，当然由于目前虚拟化技术等实现，可能很多机器是虚拟机，所有，真实的服务器也可能不需要那么多。这就是一个简单的用量来提升性能的方式。</p>
<p>当然，高性能，也会体现在其他方面，比如一些调度算法、负载均衡等，都是提升高性能的方式，好的调度算法，也能减少一些资源都浪费。</p>
<h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><p>我们还以我做的那个bff框架为例，说白了，业务方用了你的框架，上线后，发现程序经常崩溃，排查原因还非常困难，日志难找。这就说明，你这个架构设计的有问题。那么如何做到高可用呢，首先作为一个架构师，妳得有一定都预测性，可能会出现什么情况，如果出了什么情况你有什么备选方案，可以让业务还能够稳定运行，不被用户察觉的情况下，业务不受影响。记得之前出现过一个案例，线上服务有时候会经常莫名重启，后来经排查发现，在一个异步操作里，抛了一个异常，但是这个异常没有被catch到，导致进程直接退出了，退出后，由于机器上有保活机制，进程又被拉起来了，这就出现了服务重启的情况。最后我做了一个兜底的方案，在进程中监听了uncaughtException事件，防止异常退出。</p>
<p>另外很多情况需要我们考虑，比如线上服务重启，有一段短暂的事件，请求是打不进来的，那如何解决这段时间的服务不可用对用户的影响呢，那就可以做到平滑重启，多个进程配合就可以做到，这些都是需要架构师要想的，再比如，有一些服务是链接ElasticSearch（后面简称es）的，一般es都是部署到公司特定的机器上，如果某个时刻es挂了，你的服务就会受到影响，这个也是你需要考虑的，如果es挂了，你得有降级方案，比如可以熔断，数据拿备机数据。</p>
<p>总之，高可用就是要尽可能的想到所有线上可能遇到的各种问题，你想，阿里双11前，都要突然断电，就是为了验证服务的高可用。</p>
<h3 id="可扩展"><a href="#可扩展" class="headerlink" title="可扩展"></a>可扩展</h3><p>这个大家应该也容易理解，服务的升级和迭代，有时候是需要在某一些能力做扩展的，还以bff框架为例，多数通用的中间间，我们一般都内置到框架里了，但是有些业务，需要自定义中间件，那就需要框架本身暴露出一个口子，用来用户的自定义扩展。如果一个bff框架没有可扩展功能，给你用的话，我估计你也不想用。所以可扩展也是一个用户体验到问题。再往大一点产品讲，大家都在用微信，如果微信哪天在朋友圈做一个新功能，比如要做广告，总不能把朋友圈整体都要搞一下把，这个成本也太大了。另外大家在微信的设置里，可以看到有一个发现页的设置，里面可以动态关闭展示你喜欢的功能，这就是可扩展性。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>其他还有很多因素需要架构师考虑，反正架构师的职责就是为了业务的高效、稳定、安全等考虑，脱离业务的架构师，不是好架构师。</p>
]]></content>
      
        <categories>
            
            <category> 架构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Architecture </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[谈谈我喜欢的候选人]]></title>
      <url>https://skhon.github.io/2021/12/17/interview/mymind/</url>
      <content type="html"><![CDATA[<p>其实作为面试官有几年了，在第一家公司2016年的时候，就开始这方面工作了，这几年的面试经历中，遇到的多数候选人普普通通，当然也遇到过优秀的，但是非常少。其实作为面试官，我是非常不赞成抛开简历中的项目，直接各种八股文去考察候选人，这样的面试是片面的，还有一些面试官，也是抛开候选人简历，只问面试官自己会的。我觉得像这些面试官，他本身的技能就不是很扎实，不是合格的面试官，但是有很多时候，公司需要大量招人，就会让一些级别不高的同学也去做面试官，就会导致一些问题。那么接下来我就谈谈，我心目中优秀的候选人，是什么样的。</p>
<h3 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h3><p>简历很重要，我了解候选人的整体情况，第一印象都来自于候选人的简历。简历如果没有亮点，按照我的经验，多少情况最终的结果都是fail。我们先看看千篇一律的简历，如下：<br><img src="/images/interview/jianli1.png" width="50%"><br>这个候选人，工作4年，其实也不短，专业技能写的很泛泛，面比较广，这些技能都学的怎么样，通过简历还是看不出来，需要面试中沟通。另外再看项目，就是普通的前端项目，也看不到任何的难点和亮点。所以，像这种简历，第一印象都不是很好，如果学校、工作经历都不好的情况下，简历基本过不了。<br>那么什么样的简历是有亮点的呢？可以看一下这个：<br><img src="/images/interview/jianli2.png" width="50%"><br>首先个人优势比较突出，是一个开源项目的主要负责人，并且是vue-router的Contributor，另外在极客帮做过技术分享，这几点就很多人做不到的了。这就是亮点！我们为什么喜欢对开源社区有贡献的候选人呢，因为一般开源社区中比较知名的框架或者技术都是有一定难度的，都是从架构设计到实现，是值得我们很多人去学习的，所以它出名，而对于这些优秀的开源项目有共享的同学，他们对其实现肯定是了解甚至掌握的，而这就是体现出了候选人的实力。<br>一个人的亮点可以是方方面面的，比如曾经写过《xxx》书籍，在公司申请过《xxx》专利，甚至你在leetcode上涮了200道题都是你的亮点，如果你说我就是没有亮点，那我觉得就是懒，行动上和思想上都懒。那为啥优秀的那个人不可以是你呢？</p>
<h3 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h3><p>我一般在面试中，除了计算机基础之外，基本上都是会按照候选人的简历去聊，由浅入深，探索候选人的深度，比如候选人主要用的技术栈是react，那我会先聊一下react的一些特性，比如生命周期、一些副作用的操作在哪里写比较合适。再往深聊，就会问一些react优化的问题，hooks的使用。如果候选人答的不错，我还会往原理上聊，比如如果要实现一个xxx需求，如何写一个自定义hooks。再往深聊，就会聊到react设计、源码这部分，如果候选人能把所有问题都答的非常好，那就是牛批的候选人。这是深度。另外也会探索一下候选人的广度，比如跳出浏览器会问一些其他的技能，比如nodejs、数据库、运维相关的，如果候选人平时后端需求也写，那可以理解为是一个全栈工程师，这样的候选人有个优势就是面对一些复杂的场景需求时，可以自己搞定，进来也好带，不用特别费劲。如果技术的深度和广度都没问题的话，我可能还会问一些解决方案的思路，比如一些工程化问题，如何分析公共依赖，确定前端页面的回归范围、如何统计相似函数以提升代码质量等。总之我的面试中，可能会问很多原理性问题，如果我们聊的来，那我觉得你就是我喜欢的那种候选人。</p>
<h3 id="代码能力"><a href="#代码能力" class="headerlink" title="代码能力"></a>代码能力</h3><p>我的面试中，一般都会有代码题，题目不难，都是leetcode中简单题目。考代码能力的主要目的，不是为了考的你不会，而是看你的代码能力过不过关，主要看你的代码速度、代码思路、代码规范等，通过你写代码，大概能了解你的代码能力，甚至你的性格。因为个别候选人，理论知识确实不错，进来写项目需求的时候，巨慢，这种就是代码不过关导致的问题。</p>
<h3 id="软性技能"><a href="#软性技能" class="headerlink" title="软性技能"></a>软性技能</h3><p>软性技能的话，对于候选人来说，可能比较好答一些，但是也分好坏。这个就是主要观察一些候选人的沟通能力、性格之类的，可能更具候选人的性格，也需要安排不同的工作，比如内向一点都，可能会擅长偏技术攻关之类的工作，因为偏内向的人，一般都有一定的耐力或者耐性。对于乐观开朗一点的候选人，会适合做一些需求联动的工作，因为他擅于和各种人（测试、产品）沟通，也会促进工作更好的完成。<br>另外就是看看他的一些学习渠道，比如喜欢看凯源的一些技术或者框架，那可以看到这样的候选人对技术还是有热情的。喜欢看书、看博客，这样的候选人也是喜欢学习的，像这样的候选人，我也比较青睐。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我觉得以上几个方面做的不错的同学，我觉得就是我喜欢的那类候选人。</p>
]]></content>
      
        <categories>
            
            <category> 面试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Interview </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[原型链攻击]]></title>
      <url>https://skhon.github.io/2021/12/17/security/prototype/</url>
      <content type="html"><![CDATA[<p>安全问题是公司非常重视的问题，但是在我面试过程中，很多候选人只知道xss、csrf这两种，因为多数面经中，只会提到这两种。可以看到，前端工程师在平时的开发中，还是很少考虑安全问题的。由于本人在公司负责工程化建设相关工作，会涉及到项目的安全漏洞检测，所以后续多写一些相关的文章。<br>今天聊的是原型链污染攻击问题，我们先以一个非常简单的程序入手，我们知道在JavaScript中，一个对象有一个<strong>proto</strong>属性，它是指向Object.prototype的，像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;;</span><br><span class="line">console.log(obj.__proto === Object.prototype); // true</span><br></pre></td></tr></table></figure></p>
<p>有了这个前置知识后，大家可以看下面的程序会输出什么。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;;</span><br><span class="line">obj.__proto__.name = &apos;obj&apos;;</span><br><span class="line">console.log(obj.name); // 这个很明显，是obj</span><br><span class="line"></span><br><span class="line">let newObj = &#123;&#125;;</span><br><span class="line">console.log(newObj.name); // ???</span><br></pre></td></tr></table></figure></p>
<p>执行后，你会发现，newObj.name也为obj！什么情况，我新定义的newObj对象，居然可以输出name属性？？没错，这就是原型链污染。<strong>原因就是：改obj.<strong>proto</strong>,其实就是改了Object.prototype,而newObj的<strong>proto</strong>也是指向Object.prototype，这样Object的原型对象被偷偷改了，导致后面的对象不知道，这就是原型链污染的实质</strong></p>
<p>这种漏洞一般会出现在类似merge操作中，而很多工具库就提供merge方法，之前lodash就存在过原型链漏洞问题，后来修复了，如果存在漏洞，有些人就会故意往原型链上merge一些具有危险的属性，给系统带来危机。我们可以看一个简单的merge函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function merge(target, source) &#123;</span><br><span class="line">  for (let key in source) &#123;</span><br><span class="line">    if (key in source &amp;&amp; key in target) &#123;</span><br><span class="line">      merge(target[key], source[key])</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      target[key] = source[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们来验证一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let o1 = &#123;&#125;</span><br><span class="line">let o2 = &#123;a: 1, &quot;__proto__&quot;: &#123;b: 2&#125;&#125;</span><br><span class="line">merge(o1, o2)</span><br><span class="line">console.log(o1.a, o1.b) // 1 2</span><br><span class="line"></span><br><span class="line">o3 = &#123;&#125;</span><br><span class="line">console.log(o3.b) // undefined</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到这么搞，是没有污染的，原因是o2这么定义，<strong>proto</strong>会直接放在原型链上，不会当作o2的属性，可以这么理解：<br>o2.<strong>proto</strong> ==&gt; { b: 2, <strong>proto</strong>: Object.prototype}，而for in是能够遍历到原型链上的属性，所以会直接在o1中增加属性b为2。加入这么写会是啥样，看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let o1 = &#123;&#125;</span><br><span class="line">let o2 = JSON.parse(&apos;&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;b&quot;: 2&#125;&#125;&apos;)</span><br><span class="line">merge(o1, o2)</span><br><span class="line">console.log(o1.a, o1.b) // 1 2</span><br><span class="line"></span><br><span class="line">o3 = &#123;&#125;</span><br><span class="line">console.log(o3.b) // 2</span><br></pre></td></tr></table></figure></p>
<p>这么写就污染了，因为这么写，<strong>proto</strong>会当作o2的一个属性，就是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">o2 = &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  __proto__: &#123;</span><br><span class="line">    b: 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这么会让o1.<strong>proto</strong> = {b: 2},而o1的<strong>proto</strong>就是Object.prototype，随意就会导致Object的原型对象被悄悄的改了。</p>
<p>如何缓解原型链漏洞呢？这里提供了几种方式可参考：</p>
<blockquote>
<p>Object.freeze 将缓解几乎所有情况。冻结 Object 阻止添加新的 Prototype。<br>使用模式验证确保 JSON 数据包含预期属性，从而删除 JSON 中出现的 <em>proto</em>。<br>使用映射原语。它在 EcmaScript6 标准中引入，目前在 NodeJS 环境中备受支持。<br>使用 Object.creat(null) 函数创建的Objects 不具有 <em>proto</em> 属性。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Security </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[代码覆盖率]]></title>
      <url>https://skhon.github.io/2021/12/16/engineering/coverage/</url>
      <content type="html"><![CDATA[<p>最近为了防止因为漏测导致线上问题，做了一些统计测试覆盖率的工作。这个过程中用到了一个检测代码覆盖率的工具，叫：istanbul。它主要能够从几个维度来分析对应的覆盖率。比如下面几个指标：</p>
<blockquote>
<ul>
<li>行覆盖率（line coverage）：是否每一行都执行了？</li>
<li>函数覆盖率（function coverage）：是否每个函数都调用了？</li>
<li>分支覆盖率（branch coverage）：是否每个if代码块都执行了？</li>
<li>语句覆盖率（statement coverage）：是否每个语句都执行了？</li>
</ul>
</blockquote>
<p>使用起来也比较简单：</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Istanbul 是一个 npm 模块，安装非常简单，就一行命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g istanbul</span><br></pre></td></tr></table></figure></p>
<h3 id="覆盖率测试"><a href="#覆盖率测试" class="headerlink" title="覆盖率测试"></a>覆盖率测试</h3><p>来看一个例子，怎么使用 Istanbul 。下面是脚本文件 simple.js 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">var b = 1;</span><br><span class="line">if ((a + b) &gt; 2) &#123;</span><br><span class="line">  console.log(&apos;more than two&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用 istanbul cover 命令，就能得到覆盖率。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ istanbul cover simple.js</span><br><span class="line"></span><br><span class="line">===== Coverage summary =====</span><br><span class="line">Statements   : 75% ( 3/4 )</span><br><span class="line">Branches     : 50% ( 1/2 )</span><br><span class="line">Functions    : 100% ( 0/0 )</span><br><span class="line">Lines        : 75% ( 3/4 )</span><br><span class="line">=============================</span><br></pre></td></tr></table></figure></p>
<p>返回结果显示，simple.js 有4个语句（statement），执行了3个；有2个分支（branch），执行了1个；有0个函数，调用了0个；有4行代码，执行了3行。</p>
<p>这条命令同时还生成了一个 coverage 子目录，其中的 coverage.json 文件包含覆盖率的原始数据，coverage/lcov-report 是可以在浏览器打开的覆盖率报告，其中有详细信息，到底哪些代码没有覆盖到。</p>
<h3 id="覆盖率门槛"><a href="#覆盖率门槛" class="headerlink" title="覆盖率门槛"></a>覆盖率门槛</h3><p>完美的覆盖率当然是 100%，但是现实中很难达到。需要有一个门槛，衡量覆盖率是否达标。</p>
<p>istanbul check-coverage 命令用来设置门槛，同时检查当前代码是否达标。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ istanbul check-coverage --statement 90</span><br><span class="line"></span><br><span class="line">ERROR: Coverage for statements (75%) does not meet global threshold (90%)</span><br></pre></td></tr></table></figure>
<p>上面命令设置语句覆盖率的门槛是 90% ，结果就报错了，因为实际覆盖率只有75%。</p>
<p>除了百分比门槛，我们还可以设置绝对值门槛，比如只允许有一个语句没有被覆盖到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ istanbul check-coverage --statement -1</span><br></pre></td></tr></table></figure>
<p>上面命令使用负数，表示绝对值门槛。这样一来，上面的例子就通过了覆盖率测试，不会再报错了。</p>
<p>百分比门槛和绝对值门槛，可以结合使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ istanbul check-coverage --statement -5 --branch -3 --function 100</span><br></pre></td></tr></table></figure>
<p>上面命令设置了3个覆盖率门槛：5个语句、3个 if 代码块、100%的函数。注意，这三个门槛是”与”（and）的关系，只要有一个没有达标，就会报错。</p>
<h3 id="与测试框架的结合"><a href="#与测试框架的结合" class="headerlink" title="与测试框架的结合"></a>与测试框架的结合</h3><p>实际开发时，istanbul 总是与测试框架结合使用，下面以常用的 Mocha 框架为例。</p>
<p>sqrt.js 是一个计算平方根的脚本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var My = &#123;</span><br><span class="line">  sqrt: function(x) &#123;</span><br><span class="line">    if (x &lt; 0) throw new Error(&quot;负值没有平方根&quot;);</span><br><span class="line">      return Math.exp(Math.log(x)/2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = My;</span><br></pre></td></tr></table></figure>
<p>它的测试脚本 test.sqrt.js 放在 test 子目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var chai = require(&apos;chai&apos;);</span><br><span class="line">var expect = chai.expect;</span><br><span class="line">var My = require(&apos;../sqrt.js&apos;);</span><br><span class="line"></span><br><span class="line">describe(&quot;sqrt&quot;, function() &#123;</span><br><span class="line"></span><br><span class="line">  it(&quot;4的平方根应该等于2&quot;, function() &#123;</span><br><span class="line">    expect(My.sqrt(4)).to.equal(2);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(&quot;参数为负值时应该报错&quot;, function() &#123;</span><br><span class="line">    expect(function()&#123; My.sqrt(-1); &#125;).to.throw(&quot;负值没有平方根&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>然后，执行下面的命令得到代码覆盖率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ istanbul cover _mocha</span><br><span class="line">// or</span><br><span class="line">$ istanbul cover _mocha test/test.sqrt.js</span><br><span class="line"></span><br><span class="line">  sqrt</span><br><span class="line">    ✓ 4的平方根应该等于2 </span><br><span class="line">    ✓ 参数为负值时应该报错 </span><br><span class="line"></span><br><span class="line">  2 passing (7ms)</span><br><span class="line"></span><br><span class="line">===== Coverage summary =====</span><br><span class="line">Statements   : 100% ( 5/5 )</span><br><span class="line">Branches     : 100% ( 2/2 )</span><br><span class="line">Functions    : 100% ( 1/1 )</span><br><span class="line">Lines        : 100% ( 4/4 )</span><br><span class="line">=============================</span><br></pre></td></tr></table></figure>
<p>上面命令中，istanbul cover 命令后面跟的是 _mocha 命令，前面的下划线是不能省略的。</p>
<p>因为，mocha 和 _mocha 是两个不同的命令，前者会新建一个进程执行测试，而后者是在当前进程（即 istanbul 所在的进程）执行测试，只有这样， istanbul 才会捕捉到覆盖率数据。其他测试框架也是如此，必须在同一个进程执行测试。</p>
<p>如果要向 mocha 传入参数，可以写成下面的样子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ istanbul cover _mocha -- tests/test.sqrt.js -R spec</span><br></pre></td></tr></table></figure></p>
<p>上面命令中，两根连词线后面的部分，都会被当作参数传入 Mocha 。如果不加那两根连词线，它们就会被当作 istanbul 的参数（参考链接1，2）。</p>
<p>如果想在浏览器运行 Istanbul ，可以参考这篇文章。</p>
<p>五、忽略某些代码<br>istanbul 提供注释语法，允许某些代码不计入覆盖率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var object = parameter || /* istanbul ignore next */ &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码是为 object 指定默认值（一个空对象）。如果由于种种原因，没有为 object 为空对象的情况写测试，可以用注释，不将这种情况计入覆盖率。注意，注释要写在”或”运算符的后面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* istanbul ignore if  */</span><br><span class="line">if (hardToReproduceError)) &#123;</span><br><span class="line">    return callback(hardToReproduceError);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的 if 语句块，在计算覆盖率的时候会被忽略。</p>
]]></content>
      
        <categories>
            
            <category> 工程化建设 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Engineering </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[搭一个小窝]]></title>
      <url>https://skhon.github.io/2021/07/15/my-heart/index/</url>
      <content type="html"><![CDATA[<p>加入字节跳动已经半年多了，后续多做一些技术积累。所以在这里搭建一个小窝，记录一些自己的思想，可能是技术，也可能是扯淡。<a id="more"></a>为的就是以后可以再回忆回忆这段时光。哪怕以后不在互联网工作了，有时间也能再看看曾经走过的这段路程。</p>
]]></content>
      
        <categories>
            
            <category> 杂谈 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Talking to oneself </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
